<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>Hexo</title>
    <meta charset="UTF-8">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="数据结构与算法1. 数据结构1.1 二叉排序树1234567891011class Node&amp;#123;public:    ElemType data;    Node *left, *right;    Node(ElemType _data, Node* _left, Node* _right)        : data(_data), left(_left), right(_right)">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/Notes/DataStuctureAndAlgorithm.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据结构与算法1. 数据结构1.1 二叉排序树1234567891011class Node&amp;#123;public:    ElemType data;    Node *left, *right;    Node(ElemType _data, Node* _left, Node* _right)        : data(_data), left(_left), right(_right)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Notes/images/BstDeleteNode.png">
<meta property="og:image" content="http://example.com/Notes/images/AvlRotate.png">
<meta property="og:image" content="http://example.com/Notes/images/RbtUncleRed.jpg">
<meta property="og:image" content="http://example.com/Notes/images/RbtUncleBlackRchild.jpg">
<meta property="og:image" content="http://example.com/Notes/images/RbtUncleBlackLchild.jpg">
<meta property="og:image" content="http://example.com/Notes/images/RbtDelBBCase1.jpg">
<meta property="og:image" content="http://example.com/Notes/images/RbtDelBBCase2.jpg">
<meta property="og:image" content="http://example.com/Notes/images/RbtDelBBCase3.jpg">
<meta property="og:image" content="http://example.com/Notes/images/RbtDelBBCase4.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BTreeM4.png">
<meta property="og:image" content="http://example.com/Notes/images/BTreeInsert1.png">
<meta property="og:image" content="http://example.com/Notes/images/BTreeInsert2.png">
<meta property="og:image" content="http://example.com/Notes/images/BTreeDelete1.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BTreeDelete2.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BTreeDelete3.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BTreeDelete4.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BTreeDelete4p.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BTreeDelete6.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BPlusTree.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BPlusTreeInsert1.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BPlusTreeInsert2.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BPlusTreeDelete1.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BPlusTreeDelete2.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BPlusTreeDelete3.jpg">
<meta property="og:image" content="http://example.com/Notes/images/BStarTreeEx.jpg">
<meta property="og:image" content="http://example.com/Notes/images/TrieTree.jpg">
<meta property="og:image" content="http://example.com/Notes/images/ShellSort.jpg">
<meta property="og:image" content="http://example.com/Notes/images/QSort.jpg">
<meta property="og:image" content="http://example.com/Notes/images/MergeSort.jpg">
<meta property="article:published_time" content="2021-09-04T17:48:30.566Z">
<meta property="article:modified_time" content="2021-06-19T07:36:06.825Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Notes/images/BstDeleteNode.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
    <link rel="stylesheet" href="/css/style.css?v=1630854088402">
     
    
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1630854088402">
    
        <link rel="stylesheet" href="/custom.css">
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="John Doe" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="John Doe"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="John Doe">
            <img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="John Doe" alt="John Doe">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>1</div>
        <div><span>Tags</span>0</div>
        <div><span>Categories</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://jq.qq.com/?_wv=1027&k=5CfKHun" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    

    
    
    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 John Doe
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img src="https://i.dawnlab.me/c0268c1e6cfd0863d6ba35be1575941a.png" width="150px"></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 66.66666666666666%;"> 
              <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="" class="lazyload">
              <h1></h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2021年09月05日</a>
    <a><i class="nexmoefont icon-areachart"></i>5.8k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 27 分钟</a>
</div>

      

      <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><h3 id="1-1-二叉排序树"><a href="#1-1-二叉排序树" class="headerlink" title="1.1 二叉排序树"></a>1.1 二叉排序树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ElemType data;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="built_in">Node</span>(ElemType _data, Node* _left, Node* _right)</span><br><span class="line">        : <span class="built_in">data</span>(_data), <span class="built_in">left</span>(_left), <span class="built_in">right</span>(_right)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Node* BiTree;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-1-查找"><a href="#1-1-1-查找" class="headerlink" title="1.1.1 查找"></a>1.1.1 查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree root, KeyType target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root.<span class="built_in">isEmpty</span>() || target == root-&gt;data.key )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到或者查找失败</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data.key &lt; target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在左子树上查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(root-&gt;left, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在右子树上查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(root-&gt;right, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上二叉排序树在查找失败时应该确定目标的插入位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SearchBST</span><span class="params">(BiTree root, KeyType target, BiTree parrent, BiTree&amp; ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果没找到，ret指向最后访问节点的双亲（即插入位置），返回false</span></span><br><span class="line">    <span class="comment">// 如果找到，ret指向查找结果</span></span><br><span class="line">    <span class="keyword">if</span>(!root.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ret = parrent;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == root-&gt;data.key)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = root;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;data.key &lt; target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(root-&gt;left, target, root, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(root-&gt;right, target, root, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-插入元素"><a href="#1-1-2-插入元素" class="headerlink" title="1.1.2 插入元素"></a>1.1.2 插入元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertBST</span><span class="params">(BiTree&amp; root, ElemType elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">SearchBST</span>(root, elem.key, <span class="literal">nullptr</span>, p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果元素已经存在，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// p指向插入点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> <span class="built_in">Node</span>(elem, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 插入点就是根节点，说明之前是空树</span></span><br><span class="line">            root = node;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;data.key &gt; elem.key)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;left = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-删除元素"><a href="#1-1-3-删除元素" class="headerlink" title="1.1.3 删除元素"></a>1.1.3 删除元素</h4><p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BstDeleteNode.png" alt="dst_delete_node" class="lazyload"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteBST</span><span class="params">(BiTree&amp; root, KeyType target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SearchBST</span>(root, target, <span class="literal">nullptr</span>, p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没找到节点，直接退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DeleteNode</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(BiTree&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == p-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有左子树，重接右子树即可</span></span><br><span class="line">        BiTree q = p;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">nullptr</span> == p-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有右子树，重接左子树即可</span></span><br><span class="line">        BiTree q = p;</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 左孩子的右子树最终节点与待删除节点互换</span></span><br><span class="line">        <span class="comment">// 原左孩子右子树最终节点的左子树交给其父节点作为右子树</span></span><br><span class="line">      	BiTree q = p;</span><br><span class="line">        BiTree s = p-&gt;left;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">nullptr</span> != s-&gt;right) </span><br><span class="line">        &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q != p) q-&gt;right = s-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;left = s-&gt;left;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-平衡二叉树-（-AVL-Tree-）"><a href="#1-2-平衡二叉树-（-AVL-Tree-）" class="headerlink" title="1.2 平衡二叉树 （ AVL Tree ）"></a>1.2 平衡二叉树 （ AVL Tree ）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  	ElemType data;</span><br><span class="line">    <span class="keyword">int</span> bf;		<span class="comment">// 平衡因子</span></span><br><span class="line">    AVLNode *left, *right;</span><br><span class="line">    <span class="built_in">AVLNode</span>(ElemType _data, <span class="keyword">int</span> _bf, AVLNode* _left, AVLNode* _right)</span><br><span class="line">        : <span class="built_in">data</span>(_data), <span class="built_in">bf</span>(_bf), <span class="built_in">left</span>(_left), <span class="built_in">right</span>(_right)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> AVLNode* AVLTree;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-1-失衡旋转"><a href="#1-2-1-失衡旋转" class="headerlink" title="1.2.1 失衡旋转"></a>1.2.1 失衡旋转</h4><p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/AvlRotate.png" alt="avl_rotate" class="lazyload"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rc: right child</span></span><br><span class="line"><span class="comment">// lc: left child</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRotate</span><span class="params">(AVLTree&amp; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree rc = root-&gt;right;</span><br><span class="line">    root-&gt;right = rc-&gt;left;</span><br><span class="line">    rc-&gt;left = root;</span><br><span class="line">    root = rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RRotate</span><span class="params">(AVLTree&amp; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree lc = root-&gt;left;</span><br><span class="line">    lc-&gt;right = root-&gt;left;</span><br><span class="line">    lc-&gt;left = root;</span><br><span class="line">    root = lc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH +1 <span class="comment">// 左子树高</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0  <span class="comment">// 等高</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH -1 <span class="comment">// 右子树高</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左平衡旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LBalence</span><span class="params">(AVLTree&amp; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree lc = root-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(lc-&gt;bf == LH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// LL型插入，做单右旋即可平衡</span></span><br><span class="line">        root-&gt;bf = lc-&gt;bf = EH;</span><br><span class="line">        <span class="built_in">RRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(lc-&gt;bf == RH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// LR型插入，先左后右旋转</span></span><br><span class="line">        AVLTree lcrc = lc-&gt;right;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(lcrc-&gt;bf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> LH:</span><br><span class="line">            &#123;</span><br><span class="line">                root-&gt;bf = RH;</span><br><span class="line">                lc-&gt;bf = EH;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> EH:</span><br><span class="line">            &#123;</span><br><span class="line">            	root-&gt;bf = lc-&gt;bf = EH;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> RH:</span><br><span class="line">            &#123;</span><br><span class="line">            	root-&gt;bf = EH;</span><br><span class="line">                lc-&gt;bf = RH;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lcrc-&gt;bf = EH;</span><br><span class="line">        <span class="built_in">LRotate</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">RRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBalence</span><span class="params">(AVLTree&amp; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree rc = root-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(rc-&gt;bf == RH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// RR型插入，做单左旋即可平衡</span></span><br><span class="line">        root-&gt;bf = rc-&gt;bf = EH;</span><br><span class="line">        <span class="built_in">LRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rc-&gt;bf == LH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// RL型插入，先右后左旋转</span></span><br><span class="line">        AVLTree rclc = rc-&gt;left;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(rclc-&gt;bf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> LH:</span><br><span class="line">                &#123;</span><br><span class="line">                	root-&gt;bf = EH;</span><br><span class="line">                    rc-&gt;bf = RH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> EH:</span><br><span class="line">                &#123;</span><br><span class="line">                    root-&gt;bf = rc-&gt;bf = EH;</span><br><span class="line">                   	<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> RH:</span><br><span class="line">                &#123;</span><br><span class="line">                	root-&gt;bf = LH;</span><br><span class="line">                    rc-&gt;bf = EH;</span><br><span class="line">               		<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rclc-&gt;bf = EH;</span><br><span class="line">            <span class="built_in">RRotate</span>(root-&gt;right);</span><br><span class="line">            <span class="built_in">LRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二叉排序树平衡因子的更改画示意图即可。</p>
</blockquote>
<h4 id="1-2-2-删除元素"><a href="#1-2-2-删除元素" class="headerlink" title="1.2.2  删除元素"></a>1.2.2  删除元素</h4><p>先按照 BST 的方法删除元素，然后重新处理平衡。</p>
<blockquote>
<p>TODO: BST 删除元素后重新平衡的 Code</p>
</blockquote>
<h3 id="1-3-红黑树-（-Red-Black-Tree"><a href="#1-3-红黑树-（-Red-Black-Tree" class="headerlink" title="1.3 红黑树 （ Red-Black Tree )"></a>1.3 红黑树 （ Red-Black Tree )</h3><p>AVL 树虽然解决了普通二叉排序树畸形的问题，但是平衡操作过多。红黑树是一个自平衡（但不是绝对平衡）的 BST 。参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3245399.html">这篇文章</a>。</p>
<h4 id="1-3-1-构造规则"><a href="#1-3-1-构造规则" class="headerlink" title="1.3.1 构造规则"></a>1.3.1 构造规则</h4><ul>
<li>每个节点都有红色或者黑色</li>
<li>树的根节点必为黑色</li>
<li>没有两个<strong>相邻</strong>的<strong>红色节点</strong>（红色节点不能有红色父节点或红色子节点。但是<strong>并没有说不能出现连续的黑色节点</strong>）</li>
<li><code>NULL</code> 节点视为黑色 </li>
<li>从任意节点（包括根节点）到其任何后代 <code>NULL</code> 节点的每条路径都具有<strong>相同数量</strong>的黑色节点</li>
</ul>
<h4 id="1-3-2-插入节点"><a href="#1-3-2-插入节点" class="headerlink" title="1.3.2 插入节点"></a>1.3.2 插入节点</h4><p>假设新插入节点为 X 。</p>
<ol>
<li><p>将新插入节点标记为红色</p>
</li>
<li><p>如果 X 是根节点，则重新标记为黑色，结束</p>
</li>
<li><p>如果 X 的父节点是红色，同时 X 也不是根节点</p>
<ul>
<li>如果 X 的叔叔节点是红色<ul>
<li>将父节点和叔叔节点标记为黑色</li>
<li>将祖父节点标记为红色</li>
<li>让 X 颜色与祖父节点颜色相同，将祖父节点设置为当前节点 X ，重复步骤 2 和步骤 3<br><img data-fancybox="gallery" data-sizes="auto" data-src="./images/RbtUncleRed.jpg" alt="RBTreeUncleRed" class="lazyload"></li>
</ul>
</li>
<li>如果 X 的叔叔节点是黑色，且 X 是右孩子<ul>
<li>将父节点作为新的当前节点 X</li>
<li>以 X 为支点进行左旋</li>
<li>重复步骤 2 和步骤 3<br><img data-fancybox="gallery" data-sizes="auto" data-src="./images/RbtUncleBlackRchild.jpg" alt="RBTreeUncleBlackRchild" class="lazyload"></li>
</ul>
</li>
<li>如果 X 的叔叔节点是黑色，且 X 是左孩子<ul>
<li> 将父节点标记为黑色</li>
<li> 将祖父节点标记为红色</li>
<li> 以祖父节点作为支点进行右旋<br><img data-fancybox="gallery" data-sizes="auto" data-src="./images/RbtUncleBlackLchild.jpg" alt="RBTreeUncleBlackLchild" class="lazyload"><blockquote>
<p><strong>注意：</strong> 第 2 图和第 3 图有误。按照已有的图，插入节点 35R 后，节点 50R 和 75R 变为 50B 和 70B ，60B 变为 60R 并作为当前节点； 40R 和 120R 变为 40B 和 120B ，80B 变为 80R 并作为当前节点； 80R 变为 80B ，重染色结束。 如果要符合操作描述，节点 120R 应该为 120B (忽略树的不平衡)。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="1-3-3-删除节点"><a href="#1-3-3-删除节点" class="headerlink" title="1.3.3 删除节点"></a>1.3.3 删除节点</h4><p>首先将 RBT 当作普通的 BST 找到待删除节点。分三种情况：</p>
<ul>
<li>被删除节点是叶子节点，则直接删除</li>
<li>被删除节点只有一个子节点，则直接删除，并且用子节点替代原节点位置</li>
<li>被删除节点有两个子节点，则先找出后继节点，然后将后继节点的内容复制给被删除节点，之后删除后继节点。删除后继节点的情况必为上面两条之一。注意这一步的复制只复制内容，<strong>不复制颜色</strong></li>
</ul>
<p>删除节点后的树不一定满足红黑树的性质，因此要对树重新染色。假设删除节点 Y 之后，替代 Y 位置的节点为 X （ <code>NULL</code> 节点也算）。如果 Y 的颜色为黑色，则路径上少了一个黑节点，颜色平衡被破坏。因此我们假设 X 除了原本的颜色之外，还带有一个额外的黑色。假设 X 原本的颜色为 x ，我们用 xB 表示 X 现在的颜色。</p>
<ul>
<li><p>如果 X 是 RB 节点，直接将 X 的颜色设置为黑色，红黑树性质即可恢复</p>
</li>
<li><p>如果 X 是 BB 节点且为根，什么都不做</p>
</li>
<li><p>如果 X 是 BB 节点且不为根</p>
<ul>
<li><p>如果 X 的兄弟节点是红色（此时 X 的父节点和 X 兄弟节点的子节点都是黑色）</p>
<blockquote>
<p>处理思路是将该情况转换为后面三种情况</p>
</blockquote>
<ul>
<li>将 X 的兄弟节点设置为黑色</li>
<li>将 X 的父节点设置为红色</li>
<li>以 X 的父节点为支点左旋</li>
<li>左旋后，更新 X 的兄弟节点</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/RbtDelBBCase1.jpg" alt="RBTreeDelBBCase1" class="lazyload"></p>
<blockquote>
<p><strong>注意：</strong> 此图有误，旋转后 B 应该染红，D 应该染黑</p>
</blockquote>
</li>
<li><p>如果 X 的兄弟节点是黑色，且兄弟节点的两个孩子都是黑色</p>
<blockquote>
<p>处理思路是将 X 中多余的一个黑色往根方向移动。多余的黑色属性移动到 X 的父节点后，到 X 和其兄弟的路径上黑色节点数目不一致，因此将其兄弟染红，使其一致</p>
</blockquote>
<ul>
<li>将 X 的兄弟节点设置为红色</li>
<li>将 X 的父节点设置为新的 X 节点</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/RbtDelBBCase2.jpg" alt="RBTreeDelBBCase2" class="lazyload"></p>
</li>
<li><p>如果 X 的兄弟节点是黑色，兄弟节点的左孩子是红色，右孩子是黑色</p>
<blockquote>
<p>处理思路是将该情况转换为最后一种情况</p>
</blockquote>
<ul>
<li>将 X 的兄弟节点的左孩子设置为黑色</li>
<li>将 X 的兄弟节点设置为红色</li>
<li>以 X 的兄弟节点为支点右旋</li>
<li>右旋后，更新 X 的兄弟节点</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/RbtDelBBCase3.jpg" alt="RBTreeDelBBCase3" class="lazyload"></p>
</li>
<li><p>如果 X 的兄弟节点是黑色，兄弟节点的右孩子为红色（左孩子任意颜色均可）</p>
<blockquote>
<p>处理思路是去掉 X 中的额外黑色，将 X 变成单独的黑色</p>
</blockquote>
<ul>
<li>将 X 的父节点颜色赋值给 X 的兄弟节点</li>
<li>将 X 的父节点设置为黑色</li>
<li>将 X 兄弟节点的右孩子设置为黑色</li>
<li>以 X 的父节点为支点左旋</li>
<li>将根节点设置为 X</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/RbtDelBBCase4.jpg" alt="RBTreeDelBBCase4" class="lazyload"></p>
</li>
</ul>
</li>
</ul>
<h3 id="1-4-B-树"><a href="#1-4-B-树" class="headerlink" title="1.4 B 树"></a>1.4 B 树</h3><h4 id="1-4-1-构造规则"><a href="#1-4-1-构造规则" class="headerlink" title="1.4.1 构造规则"></a>1.4.1 构造规则</h4><p>B 树是多路平衡查找树，m 阶 B 树的定义如下。</p>
<ul>
<li>树中每个节点至多有 m 棵子树</li>
<li>每个节点最多有 m-1 个关键字 （可以存有的键值对）</li>
<li>根节点最少可以只有 1 个关键字</li>
<li>非根节点至少有 $\lceil m/2\rceil$ 棵子树</li>
<li>每个节点中的关键字都按照从小到大的顺序排列。每个关键字的左子树中所有关键字都小于它，而右子树中所有的关键字都大于它</li>
<li>所有的叶子节点位于同一层，并且不带任何信息</li>
</ul>
<p>因此根节点的<strong>关键字</strong>范围是 $1\leq k\leq m-1$ ，非根节点的<strong>关键字</strong>范围是 $\lceil m/2\rceil\leq k\leq m-1$ 。一棵 4 阶 B 树的示例图如下。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeM4.png" alt="BTreeM4" class="lazyload"></p>
<h4 id="1-4-2-插入节点"><a href="#1-4-2-插入节点" class="headerlink" title="1.4.2 插入节点"></a>1.4.2 插入节点</h4><blockquote>
<p>  B 树的插入删除可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83028825">这篇文章</a></p>
</blockquote>
<p>B 树的插入首先要找到最底层的某个非终端节点。如果添加后节点的关键字个数超过 $m-1$ ，则要产生节点的“分裂”。一个 3 阶 B 树的插入过程示例图如下。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeInsert1.png" alt="BTreeInsert1" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeInsert2.png" alt="BTreeInsert2" class="lazyload"></p>
<h4 id="1-4-3-删除节点"><a href="#1-4-3-删除节点" class="headerlink" title="1.4.3 删除节点"></a>1.4.3 删除节点</h4><p>在 B 树上删除一个关键字，首先查找到关键字所在节点并删除该关键字。然后</p>
<ul>
<li><p>如果该节点是最下层节点，且关键字数目不小于 $\lceil m/2\rceil - 1$ ，则删除结束。如下图所示：</p>
<p>  <img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeDelete1.jpg" alt="BTreeDelete1" class="lazyload"></p>
</li>
<li><p>如果节点不是最下层节点，删除时需要用后继节点替代，如下图所示</p>
<p>  <img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeDelete2.jpg" alt="BTreeDelete2" class="lazyload"></p>
<p>  <img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeDelete3.jpg" alt="BTreeDelete3" class="lazyload"></p>
<ul>
<li>如果替代后，最下层节点的关键字数目不小于 $\lceil m/2\rceil$ ，则删除结束</li>
<li>如果替代后，最下层节点的关键字数目小于 $\lceil m/2\rceil - 1$ ，则需要从其兄弟节点处借用一个关键字，该借用过程需要通过父节点进行。具体如图所示</li>
</ul>
<p>  <img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeDelete4.jpg" alt="BTreeDelete4" class="lazyload"></p>
<ul>
<li>  如果兄弟节点自己的关键字数目也不够，没法借用，那么要进行节点合并。具体如图所示</li>
</ul>
<p>  <img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeDelete4p.jpg" alt="BTreeDelete5" class="lazyload"></p>
<p>  <img data-fancybox="gallery" data-sizes="auto" data-src="./images/BTreeDelete6.jpg" alt="BTreeDelete6" class="lazyload"></p>
</li>
</ul>
<h3 id="1-5-B-树"><a href="#1-5-B-树" class="headerlink" title="1.5 B$^+$ 树"></a>1.5 B$^+$ 树</h3><p>B$^+$ 树是 B 树的变种。图示是一棵 3 阶 B$^+$ 树。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BPlusTree.jpg" alt="BPlusTree" class="lazyload"></p>
<h4 id="1-5-1-与-B-树的异同"><a href="#1-5-1-与-B-树的异同" class="headerlink" title="1.5.1 与 B 树的异同"></a>1.5.1 与 B 树的异同</h4><ul>
<li>相同点<ul>
<li>  根节点至少有一个关键字</li>
<li>  非根节点的关键字范围 $m/2 \leq k\leq m-1$</li>
</ul>
</li>
<li>不同点<ul>
<li>  B$^+$ 树有两种类型的节点：内部节点（索引节点）和叶子节点。内部节点不储存数据，只储存索引，数据都储存在叶子节点</li>
<li>  内部节点和叶子节点中的关键字按从小到大的顺序排列</li>
<li>  每个叶子节点都存有相邻叶子节点的指针，叶子节点本身依照关键字大小自小到大排序</li>
<li>  父节点存有其子节点中最大或最小关键字</li>
<li>  通常使用 B$^+$ 树时会有两个头指针，一个指向根节点，另一个指向最小关键字的叶子节点</li>
</ul>
</li>
</ul>
<h4 id="1-5-2-插入节点"><a href="#1-5-2-插入节点" class="headerlink" title="1.5.2 插入节点"></a>1.5.2 插入节点</h4><ul>
<li>  B$^+$ 树的插入只在叶子节点上进行</li>
<li>  当节点中的关键字多于 $m-1$ 时，分裂节点并更新父节点</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BPlusTreeInsert1.jpg" alt="BPlusTreeInsert1" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BPlusTreeInsert2.jpg" alt="BPlusTreeInsert2" class="lazyload"></p>
<h4 id="1-5-3-删除节点"><a href="#1-5-3-删除节点" class="headerlink" title="1.5.3 删除节点"></a>1.5.3 删除节点</h4><ul>
<li>  删除节点的操作类似 B 树</li>
<li>  删除关键字后，如果关键字数目少于 $\lceil m/2\rceil - 1$ ，借用节点时直接通过兄弟节点即可，然后修改父节点的索引。如图所示（父节点记录最小关键字）</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BPlusTreeDelete1.jpg" alt="BPlusTreeDel1" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BPlusTreeDelete2.jpg" alt="BPlusTreeDel2" class="lazyload"></p>
<ul>
<li>  如果关键字数目少于 $\lceil m/2\rceil - 1$ 且左右兄弟都无关键字可借，则合并叶子节点</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BPlusTreeDelete3.jpg" alt="BPlusTreeDel3" class="lazyload"></p>
<h4 id="1-5-4-B-树相对-B-树的优势"><a href="#1-5-4-B-树相对-B-树的优势" class="headerlink" title="1.5.4 B$^+$ 树相对 B 树的优势"></a>1.5.4 B$^+$ 树相对 B 树的优势</h4><ul>
<li>  单一节点储存的元素更多，使得查询的 IO 次数更少</li>
<li>  所有的查询都要查找到叶子节点，查询性能是稳定的</li>
<li>  所有的叶子节点形成了一个有序链表，更加便于查找</li>
</ul>
<h3 id="1-6-B-树"><a href="#1-6-B-树" class="headerlink" title="1.6 B$^*$ 树"></a>1.6 B$^*$ 树</h3><p>B$^*$ 树是 B$^+$ 树的变体。B$^+$ 树的块最低使用率是 1/2 ，B$^*$ 树的块最低使用率是 2/3 。B$^*$ 树的非根非叶子节点也添加了指向兄弟的指针。如图所示</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/BStarTreeEx.jpg" alt="BStarTree" class="lazyload"></p>
<p>B*树的分裂</p>
<ul>
<li><p>  当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）</p>
</li>
<li><p>  如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针</p>
</li>
</ul>
<h3 id="1-7-前缀树"><a href="#1-7-前缀树" class="headerlink" title="1.7 前缀树"></a>1.7 前缀树</h3><p>前缀树又称字典树，用于保存关联数组，其中的键通常是字符串。</p>
<h4 id="1-7-1-构造规则"><a href="#1-7-1-构造规则" class="headerlink" title="1.7.1 构造规则"></a>1.7.1 构造规则</h4><ul>
<li>  根节点不包含字符，除根节点以外每个节点只包含一个字符</li>
<li>  从根节点到某一节点，路径上经过的字符连接起来是该节点对应的字符串</li>
<li>  每个节点的所有子节点包含的字符串不相同</li>
</ul>
<h4 id="1-7-2-多重链表实现（Trie-树）"><a href="#1-7-2-多重链表实现（Trie-树）" class="headerlink" title="1.7.2 多重链表实现（Trie 树）"></a>1.7.2 多重链表实现（Trie 树）</h4><p>用多重链表实现的前缀树又称 Trie 树，如下图所示</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/TrieTree.jpg" alt="TrieTree" class="lazyload"></p>
<p>具体实现的程序如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> MAX_KEY_LEN = <span class="number">16</span>;	<span class="comment">// 关键字最大长度</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">NodeKind</span> &#123;</span> Leaf, Branch &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeysType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAX_KEY_LEN]; <span class="comment">// 关键字</span></span><br><span class="line">    <span class="keyword">int</span> len; 			 <span class="comment">// 关键字长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeKind kind;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>KeysType key; Record* value;&#125; leaf; 	<span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>TrieNode* ptr[<span class="number">27</span>]; <span class="keyword">int</span> num;&#125;  branch; 	<span class="comment">// 分支节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> TrieNode* TrieTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetIndex</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c<span class="number">-64</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找操作</span></span><br><span class="line"><span class="function">Record* <span class="title">SearchTrieTree</span><span class="params">(TrieTree T, KeysType K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrieNode* p = T;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;kind == NodeKind::Branch &amp;&amp; i &lt; K.len)</span><br><span class="line">    <span class="comment">// 对K的每个字符逐个查找，不满足条件则跳出</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;branch.ptr[<span class="built_in">GetOrder</span>(K.ch[i])];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;kind == NodeKind::Leaf &amp;&amp; p-&gt;leaf.key == K) <span class="comment">// 查找成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;leaf.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 查找失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-8-并查集"><a href="#1-8-并查集" class="headerlink" title="1.8 并查集"></a>1.8 并查集</h3><p>并查集是支持一组互不相交集合的数据结构，通常用森林实现。开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，期间要反复查找元素在哪个集合中。并查集常用的操作有初始化，查找元素所属集合 <code>Find</code> 和合并子集 <code>Bind</code> 。</p>
<h4 id="1-8-1-parent-数组实现"><a href="#1-8-1-parent-数组实现" class="headerlink" title="1.8.1 parent 数组实现"></a>1.8.1 parent 数组实现</h4><p>我们用 parent  数组来表示树。数组下标表示树的一个节点，下标所对应的值表示树的父节点，并规定树的根节点以自己为父节点（即 parent 中的元素值为下标本身）。</p>
<p>假设待查找元素为 x ，查找操作只需要比较 x 的父节点是否为其自身。代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == parent[x]? x: <span class="built_in">Find</span>(parent[x]); &#125;</span><br></pre></td></tr></table></figure>

<p>对于合并操作，分别找到两个元素的根节点，然后使其中一个根节点的父节点为另一个根节点即可。代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="built_in">Find</span>(x1);</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="built_in">Find</span>(x2);</span><br><span class="line">    parent[p1] = p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集的完整实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisjointSet</span>(<span class="keyword">int</span> max_size) : <span class="built_in">parent</span>(std::vector&lt;<span class="keyword">int</span>&gt;(max_size))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == parent[x]? x: <span class="built_in">Find</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        parent[<span class="built_in">Find</span>(x1)] = <span class="built_in">Find</span>(x2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsSameSubset</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(x1) == <span class="built_in">Find</span>(x2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-2-优化"><a href="#1-8-2-优化" class="headerlink" title="1.8.2 优化"></a>1.8.2 优化</h4><p>对上面的实现，因为没有对树进行特殊处理，所以树的不断合并可能导致树的严重不平衡，最坏情况会使查找操作的复杂度达到 $O(N)$ 。有两种优化思路。</p>
<ul>
<li>  按秩合并：秩为 $r$ 的树高度上界为 $r+1$ ，只有一个节点的树秩记为 0 。两棵树合并时，如果秩不相等，则将秩小的树合并到秩大的树上。如果相等，两棵树任意合并，秩 +1 </li>
<li>  路径压缩：在执行查找操作的过程中，将路径上的所有节点直接连到根节点上</li>
</ul>
<p>可以证明，同时使用这两种方法的平均复杂度为 $O(\alpha(N))$ ，其中 $\alpha(N)$ 是阿克曼函数的反函数。优化后的并查集实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisjointSet</span>(<span class="keyword">int</span> max_size) : <span class="built_in">parent</span>(std::vector&lt;<span class="keyword">int</span>&gt;(max_size)), <span class="built_in">rank</span>(std::vector&lt;<span class="keyword">int</span>&gt;(max_size, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == parent[x]? x: (parent[x] == <span class="built_in">Find</span>(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="built_in">Find</span>(x1);</span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="built_in">Find</span>(x2);</span><br><span class="line">        <span class="keyword">if</span>(rank[f1] &gt; rank[f2])</span><br><span class="line">        &#123;</span><br><span class="line">            parent[f2] = f1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[f1] = f2;</span><br><span class="line">            <span class="keyword">if</span>(rank[f1] == rank[f2])</span><br><span class="line">            &#123;</span><br><span class="line">                ++rank[f2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsSameSubset</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(x1) == <span class="built_in">Find</span>(x2);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h2><h3 id="2-1-直接插入排序"><a href="#2-1-直接插入排序" class="headerlink" title="2.1 直接插入排序"></a>2.1 直接插入排序</h3><h4 id="2-1-1-原理"><a href="#2-1-1-原理" class="headerlink" title="2.1.1 原理"></a>2.1.1 原理</h4><p>设待排序序列为 v 。先将序列中第 1 个记录看成是有序的子序列，然后从第 2 个记录开始逐个进行插入。在自 $i-1$ 起往前搜索的过程中，可以同时后移记录。</p>
<h4 id="2-1-2-复杂度"><a href="#2-1-2-复杂度" class="headerlink" title="2.1.2 复杂度"></a>2.1.2 复杂度</h4><p>$O(N^2)$ </p>
<p>数组基本有序时，直接插入排序效率最高。</p>
<h4 id="2-1-3-实现"><a href="#2-1-3-实现" class="headerlink" title="2.1.3 实现"></a>2.1.3 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] &lt; v[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = v[i];</span><br><span class="line">            v[i] = v[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 如果插入第 2 个元素，j 越界，此时不需要做任何操作</span></span><br><span class="line">            <span class="comment">// 可以通过把 flag 设置在 v[0] 避免对 j 的特判</span></span><br><span class="line">            <span class="comment">// 相应的数组长度要改为 &lt;= len</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-2</span>; j&gt;=<span class="number">0</span> &amp;&amp; (v[j] &gt; flag); --j)</span><br><span class="line">            &#123;</span><br><span class="line">                v[j+<span class="number">1</span>] = v[j];</span><br><span class="line">            &#125;</span><br><span class="line">            v[j+<span class="number">1</span>] = flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-Shell-排序"><a href="#2-2-Shell-排序" class="headerlink" title="2.2 Shell 排序"></a>2.2 Shell 排序</h3><h4 id="2-2-1-原理"><a href="#2-2-1-原理" class="headerlink" title="2.2.1 原理"></a>2.2.1 原理</h4><p>希尔排序先将整个待排序序列分为若干子序列，分别进行直接插入排序，当整个序列基本有序时，再对全体进行一次直接插入排序。如图所示</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/ShellSort.jpg" alt="ShellSort" class="lazyload"></p>
<h4 id="2-2-2-复杂度"><a href="#2-2-2-复杂度" class="headerlink" title="2.2.2 复杂度"></a>2.2.2 复杂度</h4><p>大约为 $O(N^{1.3})$</p>
<h3 id="2-3-冒泡排序"><a href="#2-3-冒泡排序" class="headerlink" title="2.3 冒泡排序"></a>2.3 冒泡排序</h3><h4 id="2-3-1-原理"><a href="#2-3-1-原理" class="headerlink" title="2.3.1 原理"></a>2.3.1 原理</h4><p>比较相邻记录，如果逆序则交换之。</p>
<h4 id="2-3-2-复杂度"><a href="#2-3-2-复杂度" class="headerlink" title="2.3.2 复杂度"></a>2.3.2 复杂度</h4><p>平均 $O(N^2)$</p>
<h4 id="2-3-3-实现"><a href="#2-3-3-实现" class="headerlink" title="2.3.3 实现"></a>2.3.3 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len-i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j] &gt; v[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(v[j], v[j+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-快速排序"><a href="#2-4-快速排序" class="headerlink" title="2.4 快速排序"></a>2.4 快速排序</h3><h4 id="2-4-1-原理"><a href="#2-4-1-原理" class="headerlink" title="2.4.1 原理"></a>2.4.1 原理</h4><p>通过一趟排序，将待排序记录分割为独立的两部分，其中一部分的关键字均比另一部分的关键字小。对这两个部分递归调用快速排序，以达到整个序列有序。</p>
<p>附设两个指针 low 和 high 。假设枢轴记录的关键字为 pivotkey ，先从 high 指定位置向前找到第一个小于 pivotkey 的记录并与 pivotkey 交换，再从 low 指定位置向后找到第一个关键字大于 pivotkey 的记录并与 pivotkey 交换，直到 low 和 high 重合。可以将 pivotkey 暂存，直到一趟排序结束后再将 pivotkey 移动到正确位置，并返回该位置。示意图如下</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/QSort.jpg" alt="QSort" class="lazyload"></p>
<h4 id="2-4-2-复杂度"><a href="#2-4-2-复杂度" class="headerlink" title="2.4.2 复杂度"></a>2.4.2 复杂度</h4><p>平均复杂度为 $O(N log N)$ ，最坏情况复杂度为 $O(N^2)$</p>
<h4 id="2-4-3-实现"><a href="#2-4-3-实现" class="headerlink" title="2.4.3 实现"></a>2.4.3 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotkey = v[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; v[high] &gt;= pivotkey) --high;</span><br><span class="line">        v[low] = v[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; v[low] &lt;= pivotkey) ++low;</span><br><span class="line">        v[high] = v[low];</span><br><span class="line">    &#125;</span><br><span class="line">    v[low] = pivotkey;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotloc = <span class="built_in">Partition</span>(v, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(v, low, pivotloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(v, pivotloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在一趟排序后比对两边的长度，并优先对较短部分进行快速排序，栈最大深度可下降为 $O(log N)$ 。</p>
<h3 id="2-5-归并排序"><a href="#2-5-归并排序" class="headerlink" title="2.5 归并排序"></a>2.5 归并排序</h3><h4 id="2-5-1-原理"><a href="#2-5-1-原理" class="headerlink" title="2.5.1 原理"></a>2.5.1 原理</h4><p>将初始序列看成 n 个有序的子序列，再两两归并。迭代进行该步骤直到整个序列有序。二路归并的示意图如下</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="./images/MergeSort.jpg" alt="MergeSort" class="lazyload"></p>
<h4 id="2-5-2-复杂度"><a href="#2-5-2-复杂度" class="headerlink" title="2.5.2 复杂度"></a>2.5.2 复杂度</h4><p>二路归并的时间复杂度为 $O(NlogN)$</p>
<h4 id="2-5-3-实现"><a href="#2-5-3-实现" class="headerlink" title="2.5.3 实现"></a>2.5.3 实现</h4><ul>
<li>  递归实现</li>
</ul>
<blockquote>
<p>  递归形式的二路归并实用性很差</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 复制分割点左右数组到临时数组</span></span><br><span class="line">    <span class="comment">// 比void Merge(std::vector&lt;int&gt;&amp; lhs, std::vector&lt;int&gt;&amp; rhs, int left, int mid, int right)清晰</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">lhs</span><span class="params">(v.begin()+left, v.begin()+mid+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">rhs</span><span class="params">(v.begin()+mid+<span class="number">1</span>, v.begin()+right+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 插入哨兵，避免检测数组是否为空</span></span><br><span class="line">    lhs.<span class="built_in">push_back</span>(INT_MAX);</span><br><span class="line">    rhs.<span class="built_in">push_back</span>(INT_MAX);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lhs[l] &lt; rhs[r]) v[i] = lhs[l++];</span><br><span class="line">        <span class="keyword">else</span> v[i] = rhs[r++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(v, left, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(v, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">Merge</span>(v, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MergeSort</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">MergeSort</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: v) std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  非递归实现</li>
</ul>
<blockquote>
<p>  非递归实现从间隔 1 开始，每次归并后间隔变为 2 倍，直到间隔达到长度的一半</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">lhs</span><span class="params">(v.begin()+left, v.begin()+mid+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">rhs</span><span class="params">(v.begin()+mid+<span class="number">1</span>, v.begin()+right+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 插入哨兵，避免检测数组是否为空</span></span><br><span class="line">    lhs.<span class="built_in">push_back</span>(INT_MAX);</span><br><span class="line">    rhs.<span class="built_in">push_back</span>(INT_MAX);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lhs[l] &lt; rhs[r]) v[i] = lhs[l++];</span><br><span class="line">        <span class="keyword">else</span> v[i] = rhs[r++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; len; seg &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; len; left += <span class="number">2</span>*seg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + seg - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = std::<span class="built_in">min</span>(left + <span class="number">2</span>*seg - <span class="number">1</span>, len);</span><br><span class="line">            <span class="built_in">Merge</span>(v, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>John Doe<br>
        <strong>Link：</strong><a href="http://example.com/Notes/DataStuctureAndAlgorithm.html" title="http:&#x2F;&#x2F;example.com&#x2F;Notes&#x2F;DataStuctureAndAlgorithm.html" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;Notes&#x2F;DataStuctureAndAlgorithm.html</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1630854088402"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
