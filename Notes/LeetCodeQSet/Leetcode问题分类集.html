<!DOCTYPE html>

<html lang="en">

<head>
    
    <title>Hexo</title>
    <meta charset="UTF-8">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="0. 贪心0.1 贪心算法概述贪心法用于求解最优化问题，即求解某一问题的最优解。 既然能用贪心法求解的问题是一个最优化问题，那么我们首先来了解下最优化问题的几个基本概念。 0.1.1 最优化问题的几个基本概念 目标函数   解决一个最优化问题，首先要将问题抽象成一个数学函数，这也就是一个数学建模的过程，这个能够描述问题的函数就称为『目标函数』，这个函数的最大&#x2F;小值就是我们要求的最优值。  约束条件">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/Notes/LeetCodeQSet/Leetcode%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB%E9%9B%86.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="0. 贪心0.1 贪心算法概述贪心法用于求解最优化问题，即求解某一问题的最优解。 既然能用贪心法求解的问题是一个最优化问题，那么我们首先来了解下最优化问题的几个基本概念。 0.1.1 最优化问题的几个基本概念 目标函数   解决一个最优化问题，首先要将问题抽象成一个数学函数，这也就是一个数学建模的过程，这个能够描述问题的函数就称为『目标函数』，这个函数的最大&#x2F;小值就是我们要求的最优值。  约束条件">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc44q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc44a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc44a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc45q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc45a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc55q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc55a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc134q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc134a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc134a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc134a3.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc134a4.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc134a5.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc22q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc39q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc39a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc40q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc40a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc40a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc46q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc46a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc47q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc47a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc77q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc77a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc77a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc77a3.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc78q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc78a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc79q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc90q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc93q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc93a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc95q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc95a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc113q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc797q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/qianxiangxing1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/qianxiangxing2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/qianxiangxing3.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/qianxiangxing4.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/qianxiangxing5.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/qifashi1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/qifashi2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/qifashi3.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/dij1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/dij2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/dij3.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/astar1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/bellmanford1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/spfa1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/toposort1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc207q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc207a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc207a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/xianduanshu1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/xianduanshu2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/xianduanshu3.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/xianduanshu4.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/xianduanshu5.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/xianduanshu6.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/xianduanshu7.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lic201q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lic202q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lic203q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lic247q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lic439q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lic205q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lic207q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lic751q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/presum1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc560q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc974q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc974a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc1838q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc1838a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc1744q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc_ms17_24q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc238q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc238a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc1074q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc862q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc862a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/yasuodp1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc5856q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc5856a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc5856a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc5856a3.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc5856a4.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc1723q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc1723a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc1723a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc689q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc689a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc526q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc526a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc526a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc124q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc124a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc834q.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc834a1.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc834a2.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc834a3.png">
<meta property="og:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc834a4.png">
<meta property="article:published_time" content="2021-09-04T17:00:21.784Z">
<meta property="article:modified_time" content="2021-09-04T17:00:21.784Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Notes/LeetCodeQSet/imgs/lc44q.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
    <link rel="stylesheet" href="/css/style.css?v=1630854088416">
     
    
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1630854088416">
    
        <link rel="stylesheet" href="/custom.css">
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="John Doe" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="John Doe"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="John Doe">
            <img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="John Doe" alt="John Doe">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>1</div>
        <div><span>Tags</span>0</div>
        <div><span>Categories</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://jq.qq.com/?_wv=1027&k=5CfKHun" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    

    
    
    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 John Doe
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img src="https://i.dawnlab.me/c0268c1e6cfd0863d6ba35be1575941a.png" width="150px"></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 66.66666666666666%;"> 
              <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="" class="lazyload">
              <h1></h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2021年09月05日</a>
    <a><i class="nexmoefont icon-areachart"></i>13.1k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 70 分钟</a>
</div>

      

      <h1 id="0-贪心"><a href="#0-贪心" class="headerlink" title="0. 贪心"></a>0. 贪心</h1><h2 id="0-1-贪心算法概述"><a href="#0-1-贪心算法概述" class="headerlink" title="0.1 贪心算法概述"></a>0.1 贪心算法概述</h2><p>贪心法用于求解最优化问题，即求解某一问题的最优解。<br> 既然能用贪心法求解的问题是一个最优化问题，那么我们首先来了解下最优化问题的几个基本概念。</p>
<h3 id="0-1-1-最优化问题的几个基本概念"><a href="#0-1-1-最优化问题的几个基本概念" class="headerlink" title="0.1.1 最优化问题的几个基本概念"></a>0.1.1 最优化问题的几个基本概念</h3><ul>
<li><p>目标函数<br>   解决一个最优化问题，首先要将问题抽象成一个数学函数，这也就是一个数学建模的过程，这个能够描述问题的函数就称为『目标函数』，这个函数的最大/小值就是我们要求的最优值。</p>
</li>
<li><p>约束条件<br>   任何函数都有它的取值范围，所有取值范围的集合就称为『约束条件』。</p>
</li>
<li><p>可行解<br>   满足所有约束条件的解称为『可行解』。</p>
</li>
<li><p>最优解<br>   满足约束条件，并且使得目标函数最大/小的解称为『最优解』。</p>
</li>
<li><p>贪心法的求解思路<br>  既然贪心法用于解决最优化问题，所以我们首先对问题进行数学建模，找出其中的：目标函数、约束条件。 </p>
<p>  最优化问题的结果需要用一个 n 元组来表示，如  $X=(x_1, x_2, x_3, …… ,x_n)$。 </p>
<p>  贪心法的执行一共需要 n 步，每一步都会确定 n 元组中的一个元素，并保证每一步选取的值都是局部最优的。在经过 n 步之后，一共选取了 n 个值，每个值都是局部最优的，最终我们就可以认为这 n 个局部最优的值是整体最优的。那么，在每一步中，究竟通过怎样的策略来选取一个当前局部最优解呢？这个选取策略就叫做『最优量度标准』（也叫做贪心准则）。最优量度标准选择的好坏，直接影响最终的结果是不是整体最优。而最优量度标准的选择往往是根据经验来确定的，也就是并不是所有的最优量度标准都能达到整体最优。所以你选取的那个最优量度标准能否导致整体最优，这是需要额外证明的。</p>
</li>
</ul>
<h3 id="0-1-2-贪心算法原型"><a href="#0-1-2-贪心算法原型" class="headerlink" title="0.1.2 贪心算法原型"></a>0.1.2 贪心算法原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SolutionType <span class="title">greedy</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一开始结果集为空</span></span><br><span class="line">    SolutionType solution = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 进行n步选值</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ ) &#123;</span><br><span class="line">        <span class="comment">// 选出当前局部最优解x</span></span><br><span class="line">        x = <span class="built_in">select</span>(a);</span><br><span class="line">        <span class="comment">// 判断x是否满足约束条件，若不满足则继续选</span></span><br><span class="line">        <span class="keyword">while</span>( !<span class="built_in">isFeasible</span>(x) )&#123;</span><br><span class="line">            x = <span class="built_in">select</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前最优解添加至结果集中</span></span><br><span class="line">        solution.<span class="built_in">add</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0-1-3-何时使用贪心法"><a href="#0-1-3-何时使用贪心法" class="headerlink" title="0.1.3 何时使用贪心法"></a>0.1.3 何时使用贪心法</h3><p>满足如下条件，可以使用贪心法：</p>
<ul>
<li><p>  要求解的问题是一个最优化问题；</p>
</li>
<li><p>  这个问题的解可以用n元组表示；</p>
</li>
<li><p>  该问题满足最优子结构特性；</p>
</li>
<li><p>可以找到最优量度标准，并可以证明该最优量度标准能导致一个整体最优解；</p>
<blockquote>
<p>   并非对所有最优化问题都能找到最优量度标准，若找不到可以使用动态规划法。</p>
</blockquote>
</li>
</ul>
<h3 id="0-1-4-总结"><a href="#0-1-4-总结" class="headerlink" title="0.1.4 总结"></a>0.1.4 总结</h3><p>贪心法用于求解最优化问题。采用多步决策的方式求解，每一步根据最优量度标准求出结果集的一个分量，保证该分量为当前的局部最优解。那么当进行n步决策后，就求出结果集的所有分量。只要最优量度标准选的合理，最终的结果就是一个最优解。<br>当然，你选取的那个最优量度标准究竟能不能导致整体最优解，这是需要证明的。</p>
<h2 id="LC44-通配符匹配"><a href="#LC44-通配符匹配" class="headerlink" title="LC44 通配符匹配"></a>LC44 通配符匹配</h2><p><img src="./imgs/lc44q.png"></p>
<p><img src="./imgs/lc44a1.png"></p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 我们用 sIndex 和 pIndex 表示当前遍历到 s 和 p 的位置</span><br><span class="line">// 此时我们正在 s 中寻找某个 u_i</span><br><span class="line">// 其在 s 和 p 中的起始位置为 sRecord 和 pRecord</span><br><span class="line"></span><br><span class="line">// sIndex 和 sRecord 的初始值为 <span class="number">0</span></span><br><span class="line">// 即我们从字符串 s 的首位开始匹配</span><br><span class="line">sIndex = sRecord = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">// pIndex 和 pRecord 的初始值为 <span class="number">1</span></span><br><span class="line">// 这是因为模式 p 的首位是星号，那么 u_1 的起始位置为 <span class="number">1</span></span><br><span class="line">pIndex = pRecord = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> sIndex &lt; s.length <span class="keyword">and</span> pIndex &lt; p.length do</span><br><span class="line">    <span class="keyword">if</span> p[pIndex] == <span class="comment">&#x27;*&#x27; then</span></span><br><span class="line">        // 如果遇到星号，说明找到了 u_i，开始寻找 u_i+<span class="number">1</span></span><br><span class="line">        pIndex += <span class="number">1</span></span><br><span class="line">        // 记录下起始位置</span><br><span class="line">        sRecord = sIndex</span><br><span class="line">        pRecord = pIndex</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> match(s[sIndex], p[pIndex]) <span class="keyword">then</span></span><br><span class="line">        // 如果两个字符可以匹配，就继续寻找 u_i 的下一个字符</span><br><span class="line">        sIndex += <span class="number">1</span></span><br><span class="line">        pIndex += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> sRecord + <span class="number">1</span> &lt; s.length <span class="keyword">then</span></span><br><span class="line">        // 如果两个字符不匹配，那么需要重新寻找 u_i</span><br><span class="line">        // 枚举下一个 s 中的起始位置</span><br><span class="line">        sRecord += <span class="number">1</span></span><br><span class="line">        sIndex = sRecord</span><br><span class="line">        pIndex = pRecord</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        // 如果不匹配并且下一个起始位置不存在，那么匹配失败</span><br><span class="line">        <span class="keyword">return</span> False</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span></span><br><span class="line"></span><br><span class="line">// 由于 p 的最后一个字符是星号，那么 s 未匹配完，那么没有关系</span><br><span class="line">// 但如果 p 没有匹配完，那么 p 剩余的字符必须都是星号</span><br><span class="line"><span class="keyword">return</span> all(p[pIndex] ~ p[p.length - <span class="number">1</span>] == <span class="comment">&#x27;*&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><img src="./imgs/lc44a2.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> p[i<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;?&#x27;</span> || s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC45-跳跃游戏2"><a href="#LC45-跳跃游戏2" class="headerlink" title="LC45 跳跃游戏2"></a>LC45 跳跃游戏2</h2><p><img src="./imgs/lc45q.png"></p>
<p><img src="./imgs/lc45a1.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    end := <span class="number">0</span></span><br><span class="line">    maxPosition := <span class="number">0</span></span><br><span class="line">    steps := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        maxPosition = max(maxPosition, i + nums[i])</span><br><span class="line">        <span class="keyword">if</span> i == end &#123;</span><br><span class="line">            end = maxPosition</span><br><span class="line">            steps++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC55-跳跃游戏"><a href="#LC55-跳跃游戏" class="headerlink" title="LC55 跳跃游戏"></a>LC55 跳跃游戏</h2><p><img src="./imgs/lc55q.png"></p>
<p><img src="./imgs/lc55a1.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= rightmost) &#123;</span><br><span class="line">                rightmost = <span class="built_in">max</span>(rightmost, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC134-加油站"><a href="#LC134-加油站" class="headerlink" title="LC134 加油站"></a>LC134 加油站</h2><p><img src="./imgs/lc134q.png"></p>
<p><img src="./imgs/lc134a1.png"></p>
<p><img src="./imgs/lc134a2.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; gas, vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   <span class="comment">// 当前累加rest[i]和 curSum一旦小于0</span></span><br><span class="line">                start = i + <span class="number">1</span>;  <span class="comment">// 起始位置更新为i+1</span></span><br><span class="line">                curSum = <span class="number">0</span>;     <span class="comment">// curSum从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 说明怎么走都不可能跑一圈了</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="./imgs/lc134a3.png"></p>
<p><img src="./imgs/lc134a4.png"></p>
<p><img src="./imgs/lc134a5.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = gas.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gas[start] &lt; cost[start]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = gas[start] - cost[start];</span><br><span class="line">                <span class="keyword">int</span> idx = start + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (idx % n != start) &#123;</span><br><span class="line">                    cur += gas[idx % n] - cost[idx % n];</span><br><span class="line">                    <span class="keyword">if</span> (cur &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    idx++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (idx % n == start) <span class="keyword">return</span> start;</span><br><span class="line">                <span class="keyword">else</span> start = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC179-最大数"><a href="#LC179-最大数" class="headerlink" title="LC179 最大数"></a>LC179 最大数</h2><h1 id="1-回溯"><a href="#1-回溯" class="headerlink" title="1.回溯"></a>1.回溯</h1><h2 id="1-1-回溯算法概述"><a href="#1-1-回溯算法概述" class="headerlink" title="1.1 回溯算法概述"></a>1.1 回溯算法概述</h2><p>回溯算法是对树形或者图形结构执行一次深度优先遍历，实际上类似枚举的搜索尝试过程，在遍历的过程中寻找问题的解。</p>
<p>深度优先遍历有个特点：当发现已不满足求解条件时，就返回，尝试别的路径。此时对象类型变量就需要重置成为和之前一样，称为「状态重置」。</p>
<p>许多复杂的，规模较大的问题都可以使用回溯法，有「通用解题方法」的美称。实际上，回溯算法就是暴力搜索算法，它是早期的人工智能里使用的算法，借助计算机强大的计算能力帮助我们找到问题的解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<h2 id="LC22-括号生成"><a href="#LC22-括号生成" class="headerlink" title="LC22 括号生成"></a>LC22 括号生成</h2><p><img src="./imgs/lc22q.png"></p>
<p>题解其实就一句话：有规律啊，剩余左括号总数要小于等于右括号。 递归把所有符合要求的加上去就行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">string</span>&#123;<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">string</span>&#123;<span class="string">&quot;()&quot;</span>&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">		tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">		backtrack(n, n, &amp;tmp, &amp;ret)</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(l, r <span class="keyword">int</span>, tmp *[]<span class="keyword">byte</span>, ret *[]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span> &#123;</span><br><span class="line">		(*ret) = <span class="built_in">append</span>((*ret), <span class="keyword">string</span>(*tmp))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">		(*tmp) = <span class="built_in">append</span>((*tmp), <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">		backtrack(l, r<span class="number">-1</span>, tmp, ret)</span><br><span class="line">		(*tmp) = (*tmp)[:<span class="built_in">len</span>(*tmp)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l &gt; <span class="number">0</span> &#123;</span><br><span class="line">		(*tmp) = <span class="built_in">append</span>((*tmp), <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">		backtrack(l<span class="number">-1</span>, r, tmp, ret)</span><br><span class="line">		(*tmp) = (*tmp)[:<span class="built_in">len</span>(*tmp)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC39-组合总和"><a href="#LC39-组合总和" class="headerlink" title="LC39 组合总和"></a>LC39 组合总和</h2><p><img src="./imgs/lc39q.png"></p>
<p><img src="./imgs/lc39a1.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	path := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	sort.Ints(candidates)</span><br><span class="line">	backtrack(<span class="number">0</span>, target, &amp;path, &amp;ret, &amp;candidates)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(idx, target <span class="keyword">int</span>, path *[]<span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>, candidates *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">		dummy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(*path))</span><br><span class="line">		<span class="keyword">for</span> i, val := <span class="keyword">range</span> *path &#123;</span><br><span class="line">			dummy[i] = val</span><br><span class="line">		&#125;</span><br><span class="line">		(*ret) = <span class="built_in">append</span>((*ret), dummy)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> idx == <span class="built_in">len</span>(*candidates) &#123;</span><br><span class="line">		<span class="comment">// 凑不出 target 了</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := idx; i &lt; <span class="built_in">len</span>(*candidates); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> (*candidates)[i] &lt;= target &#123;</span><br><span class="line">			(*path) = <span class="built_in">append</span>((*path), (*candidates)[i])</span><br><span class="line">			backtrack(i, target-(*candidates)[i], path, ret, candidates)</span><br><span class="line">			(*path) = (*path)[:<span class="built_in">len</span>(*path)<span class="number">-1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC40-组合总和2"><a href="#LC40-组合总和2" class="headerlink" title="LC40 组合总和2"></a>LC40 组合总和2</h2><p><img src="./imgs/lc40q.png"></p>
<p><img src="./imgs/lc40a1.png"></p>
<p><img src="./imgs/lc40a2.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(sequence);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == freq.<span class="built_in">size</span>() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(pos + <span class="number">1</span>, rest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> most = <span class="built_in">min</span>(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.<span class="built_in">push_back</span>(freq[pos].first);</span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: candidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq.<span class="built_in">empty</span>() || num != freq.<span class="built_in">back</span>().first) &#123;</span><br><span class="line">                freq.<span class="built_in">emplace_back</span>(num, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++freq.<span class="built_in">back</span>().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  其实在 LC 39的代码里加一句判断即可</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	path := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	sort.Ints(candidates)</span><br><span class="line">	backtrack(<span class="number">0</span>, target, &amp;path, &amp;ret, &amp;candidates)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(idx, target <span class="keyword">int</span>, path *[]<span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>, candidates *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">		dummy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(*path))</span><br><span class="line">		<span class="built_in">copy</span>(dummy, (*path))</span><br><span class="line">		(*ret) = <span class="built_in">append</span>(*ret, dummy)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> idx == <span class="built_in">len</span>(*candidates) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := idx; i &lt; <span class="built_in">len</span>(*candidates); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; idx &amp;&amp; (*candidates)[i] == (*candidates)[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*candidates)[i] &lt;= target &#123;</span><br><span class="line">			(*path) = <span class="built_in">append</span>((*path), (*candidates)[i])</span><br><span class="line">			backtrack(i+<span class="number">1</span>, target-(*candidates)[i], path, ret, candidates)</span><br><span class="line">			(*path) = (*path)[:<span class="built_in">len</span>(*path)<span class="number">-1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC46-全排列"><a href="#LC46-全排列" class="headerlink" title="LC46 全排列"></a>LC46 全排列</h2><p><img src="./imgs/lc46q.png"></p>
<p><img src="./imgs/lc46a1.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	path := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	backtrack(&amp;nums, &amp;path, &amp;ret)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上可以不用 visit 数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums *[]<span class="keyword">int</span>, path *[]<span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(*path) == <span class="built_in">len</span>(*nums) &#123;</span><br><span class="line">		dummy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(*path))</span><br><span class="line">		<span class="built_in">copy</span>(dummy, (*path))</span><br><span class="line">		(*ret) = <span class="built_in">append</span>((*ret), dummy)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, num := <span class="keyword">range</span> *nums &#123;</span><br><span class="line">			i := <span class="number">0</span></span><br><span class="line">			<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(*path); i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> num == (*path)[i] &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> i != <span class="built_in">len</span>(*path) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				(*path) = <span class="built_in">append</span>((*path), num)</span><br><span class="line">				backtrack(nums, path, ret)</span><br><span class="line">				(*path) = (*path)[:<span class="built_in">len</span>(*path)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC47-全排列2"><a href="#LC47-全排列2" class="headerlink" title="LC47 全排列2"></a>LC47 全排列2</h2><p><img src="./imgs/lc47q.png"></p>
<p><img src="./imgs/lc47a1.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	path := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	visit := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	backtrack(<span class="number">0</span>, &amp;nums, &amp;path, &amp;visit, &amp;ret)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这次用 visit 比较省事</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(idx <span class="keyword">int</span>, nums, path, visit *[]<span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> idx == <span class="built_in">len</span>(*nums) &#123;</span><br><span class="line">		dummy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(*path))</span><br><span class="line">		<span class="built_in">copy</span>(dummy, *path)</span><br><span class="line">		(*ret) = <span class="built_in">append</span>((*ret), dummy)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(*nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> (*visit)[i] == <span class="number">1</span> || (i &gt; <span class="number">0</span> &amp;&amp; (*nums)[i] == (*nums)[i<span class="number">-1</span>] &amp;&amp; (*visit)[i<span class="number">-1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		(*path) = <span class="built_in">append</span>((*path), (*nums)[i])</span><br><span class="line">		(*visit)[i] = <span class="number">1</span></span><br><span class="line">		backtrack(idx+<span class="number">1</span>, nums, path, visit, ret)</span><br><span class="line">		(*visit)[i] = <span class="number">0</span></span><br><span class="line">		(*path) = (*path)[:<span class="built_in">len</span>(*path)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC77-组合"><a href="#LC77-组合" class="headerlink" title="LC77 组合"></a>LC77 组合</h2><p><img src="./imgs/lc77q.png"></p>
<p><img src="./imgs/lc77a1.png"></p>
<p><img src="./imgs/lc77a2.png"></p>
<p><img src="./imgs/lc77a3.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有这里 i &lt;= n - (k - path.size()) + 1 与参考代码 1 不同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC78-子集"><a href="#LC78-子集" class="headerlink" title="LC78 子集"></a>LC78 子集</h2><p><img src="./imgs/lc78q.png"></p>
<p><img src="./imgs/lc78a1.png"></p>
<blockquote>
<p>  其实幂集用掩码就完事儿了</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">subsets</span></span>(nums: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt; &#123;</span><br><span class="line">        (<span class="number">0</span>..<span class="number">1</span>&lt;&lt;nums.len()).map(|mask| &#123;</span><br><span class="line">            nums.iter()</span><br><span class="line">                .enumerate()</span><br><span class="line">                .filter_map(|(i, &amp;num)| &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mask &amp; <span class="number">1</span>&lt;&lt;i) != <span class="number">0</span> &#123;<span class="literal">Some</span>(num)&#125; <span class="keyword">else</span> &#123;<span class="literal">None</span>&#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .collect()</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC79-单词搜索"><a href="#LC79-单词搜索" class="headerlink" title="LC79 单词搜索"></a>LC79 单词搜索</h2><p><img src="./imgs/lc79q.png"></p>
<blockquote>
<p>  基础的回溯，无需题解</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	visited := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, <span class="built_in">len</span>(board))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line">		visited[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(board[i]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> backtrack(&amp;board, &amp;visited, i, j, <span class="number">0</span>, word) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(board *[][]<span class="keyword">byte</span>, visited *[][]<span class="keyword">bool</span>, i, j, k <span class="keyword">int</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (*board)[i][j] != word[k] &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	(*visited)[i][j] = <span class="literal">true</span></span><br><span class="line">	directions := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, direction := <span class="keyword">range</span> directions &#123;</span><br><span class="line">		ni, nj := i+direction[<span class="number">0</span>], j+direction[<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; <span class="built_in">len</span>(*board) &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; <span class="built_in">len</span>((*board)[<span class="number">0</span>]) &#123;</span><br><span class="line">			<span class="keyword">if</span> !(*visited)[ni][nj] &#123;</span><br><span class="line">				<span class="keyword">if</span> backtrack(board, visited, ni, nj, k+<span class="number">1</span>, word) &#123;</span><br><span class="line">                    (*visited)[i][j] = <span class="literal">false</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	(*visited)[i][j] = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC90-子集2"><a href="#LC90-子集2" class="headerlink" title="LC90 子集2"></a>LC90 子集2</h2><p><img src="./imgs/lc90q.png"></p>
<p>在递归时，若发现没有选择上一个数，且当前数字与上一个数相同，则可以跳过当前生成的子集。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	path := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	backtrack(&amp;nums, &amp;path, &amp;ret, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums, path *[]<span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> idx == <span class="built_in">len</span>((*nums)) &#123;</span><br><span class="line">		dummy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>((*path)))</span><br><span class="line">		<span class="built_in">copy</span>(dummy, (*path))</span><br><span class="line">		(*ret) = <span class="built_in">append</span>((*ret), dummy)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	(*path) = <span class="built_in">append</span>((*path), (*nums)[idx])</span><br><span class="line">	backtrack(nums, path, ret, idx+<span class="number">1</span>)</span><br><span class="line">	(*path) = (*path)[:<span class="built_in">len</span>((*path))<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">for</span> idx &lt; <span class="built_in">len</span>((*nums))<span class="number">-1</span> &amp;&amp; (*nums)[idx] == (*nums)[idx+<span class="number">1</span>] &#123;</span><br><span class="line">		idx++</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(nums, path, ret, idx+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC93-复原IP地址"><a href="#LC93-复原IP地址" class="headerlink" title="LC93 复原IP地址"></a>LC93 复原IP地址</h2><p><img src="./imgs/lc93q.png"></p>
<p><img src="./imgs/lc93a1.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	segs := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	backtrack(<span class="number">0</span>, <span class="number">0</span>, s, &amp;ret, &amp;segs)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(seg, idx <span class="keyword">int</span>, s <span class="keyword">string</span>, ret *[]<span class="keyword">string</span>, segs *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> seg == <span class="number">4</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> idx == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">			str := <span class="string">&quot;&quot;</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">				str += strconv.Itoa((*segs)[i])</span><br><span class="line">				<span class="keyword">if</span> i != <span class="number">3</span> &#123;</span><br><span class="line">					str += <span class="string">&quot;.&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			(*ret) = <span class="built_in">append</span>((*ret), str)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> idx == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 特判前导0</span></span><br><span class="line">	<span class="keyword">if</span> s[idx] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">		(*segs)[seg] = <span class="number">0</span></span><br><span class="line">		backtrack(seg+<span class="number">1</span>, idx+<span class="number">1</span>, s, ret, segs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addr := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := idx; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		addr = addr*<span class="number">10</span> + <span class="keyword">int</span>(s[i]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> addr &gt; <span class="number">0</span> &amp;&amp; addr &lt; <span class="number">256</span> &#123;</span><br><span class="line">			(*segs)[seg] = addr</span><br><span class="line">			backtrack(seg+<span class="number">1</span>, i+<span class="number">1</span>, s, ret, segs)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC95-不同的二叉搜索树2"><a href="#LC95-不同的二叉搜索树2" class="headerlink" title="LC95  不同的二叉搜索树2"></a>LC95  不同的二叉搜索树2</h2><p><img src="./imgs/lc95q.png"></p>
<p><img src="./imgs/lc95a1.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTrees</span><span class="params">(n <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> backtrack(<span class="number">1</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(start, end <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> start &gt; end &#123;</span><br><span class="line">		<span class="keyword">return</span> []*TreeNode&#123;<span class="literal">nil</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	trees := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">		left := backtrack(start, i<span class="number">-1</span>)</span><br><span class="line">		right := backtrack(i+<span class="number">1</span>, end)</span><br><span class="line">		<span class="keyword">for</span> _, l := <span class="keyword">range</span> left &#123;</span><br><span class="line">			<span class="keyword">for</span> _, r := <span class="keyword">range</span> right &#123;</span><br><span class="line">				curr := &amp;TreeNode&#123;i, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">				curr.Left = l</span><br><span class="line">				curr.Right = r</span><br><span class="line">				trees = <span class="built_in">append</span>(trees, curr)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trees</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC113-路径总和2"><a href="#LC113-路径总和2" class="headerlink" title="LC113 路径总和2"></a>LC113 路径总和2</h2><p><img src="./imgs/lc113q.png"></p>
<blockquote>
<p>  标准的 dfs，也可以理解为回溯</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	path := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	backtrack(root, &amp;path, &amp;ret, targetSum)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(root *TreeNode, path *[]<span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	(*path) = <span class="built_in">append</span>((*path), root.Val)</span><br><span class="line">	<span class="keyword">if</span> target-root.Val == <span class="number">0</span> &amp;&amp; root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">		dummy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>((*path)))</span><br><span class="line">		<span class="built_in">copy</span>(dummy, (*path))</span><br><span class="line">		(*ret) = <span class="built_in">append</span>((*ret), dummy)</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(root.Left, path, ret, target-root.Val)</span><br><span class="line">	backtrack(root.Right, path, ret, target-root.Val)</span><br><span class="line">	(*path) = (*path)[:<span class="built_in">len</span>((*path))<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC797-所有可能的路径"><a href="#LC797-所有可能的路径" class="headerlink" title="LC797 所有可能的路径"></a>LC797 所有可能的路径</h2><p><img src="./imgs/lc797q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HOFunctor&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YCombinator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HOFunctor func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">    <span class="built_in">YCombinator</span>(Function &amp;&amp;func) : <span class="built_in">func</span>((Function &amp;&amp;) func) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args &amp;&amp;...args)</span> -&gt; <span class="title">decltype</span><span class="params">(func(*<span class="keyword">this</span>, (Args &amp;&amp;) args...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(*<span class="keyword">this</span>, (Args &amp;&amp;) args...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;typename Functor&gt;</span></span><br><span class="line"><span class="comment">// YCombinator(Functor) -&gt; YCombinator&lt;Functor&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line"><span class="function">YCombinator&lt;Function&gt; <span class="title">make_YCombinator</span><span class="params">(Function &amp;&amp;func)</span> </span>&#123; <span class="keyword">return</span> YCombinator&lt;Function&gt;(func); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">path</span><span class="params">(&#123;<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dfs = <span class="built_in">make_YCombinator</span>(</span><br><span class="line">            [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="keyword">int</span> x) -&gt; <span class="keyword">void</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == n)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;y : graph[x])</span><br><span class="line">                &#123;</span><br><span class="line">                    path.<span class="built_in">push_back</span>(y);</span><br><span class="line">                    <span class="built_in">self</span>(y);</span><br><span class="line">                    path.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-图"><a href="#2-图" class="headerlink" title="2. 图"></a>2. 图</h1><h2 id="2-1-常用图算法与数据结构概述"><a href="#2-1-常用图算法与数据结构概述" class="headerlink" title="2.1 常用图算法与数据结构概述"></a>2.1 常用图算法与数据结构概述</h2><h3 id="2-1-1-前向星"><a href="#2-1-1-前向星" class="headerlink" title="2.1.1 前向星"></a>2.1.1 前向星</h3><p><img src="./imgs/qianxiangxing1.png"></p>
<p><img src="./imgs/qianxiangxing2.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">针对上图，假设我们输入边的顺序为:</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line">4 1</span><br><span class="line">1 5</span><br><span class="line">4 5</span><br><span class="line">那么依据上述规则排完序后就得到:</span><br><span class="line"></span><br><span class="line">编号:     1   2   3   4   5   6   7</span><br><span class="line"></span><br><span class="line">起点u:    1   1   1   2   3   4   4</span><br><span class="line"></span><br><span class="line">终点v:    2   3   5   3   4   1   5</span><br><span class="line">最终得到head[i]、len[i]值如下：</span><br><span class="line"></span><br><span class="line">head[1] = 1     len[1] = 3</span><br><span class="line"></span><br><span class="line">head[2] = 4     len[2] = 1</span><br><span class="line"></span><br><span class="line">head[3] = 5     len[3] = 1</span><br><span class="line"></span><br><span class="line">head[4] = 6     len[4] = 2</span><br></pre></td></tr></table></figure>

<p><img src="./imgs/qianxiangxing3.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们建立边结构体为:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> next;</span><br><span class="line">     <span class="keyword">int</span> to;</span><br><span class="line">     <span class="keyword">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line">其中：</span><br><span class="line">edge[i].to表示第i条边的终点,</span><br><span class="line">edge[i].next表示与第i条边同起点的下一条边的存储位置,</span><br><span class="line">edge[i].w为边权值.</span><br></pre></td></tr></table></figure>

<p><img src="./imgs/qianxiangxing4.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//加边函数。u为起点，v为终点，w为边权</span></span><br><span class="line"></span><br><span class="line">    edge[cnt].to=v; <span class="comment">//终点</span></span><br><span class="line"></span><br><span class="line">    edge[cnt].w=w; <span class="comment">//权值</span></span><br><span class="line"></span><br><span class="line">    edge[cnt].next=head[u]; <span class="comment">//以u为起点的的最后一条边的编号</span></span><br><span class="line"></span><br><span class="line">    head[u]=cnt++; <span class="comment">//更新以u为起点的上一条边的编号</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一组数据：</span><br><span class="line">第一行表示 <span class="number">5</span> 个顶点 <span class="number">7</span> 条边</span><br><span class="line">接下来是<span class="number">7</span>条边的起点、终点和权值</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><img src="./imgs/qianxiangxing5.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">依据next，head数组的约定，并按边的输入顺序从<span class="number">0</span>开始对边进行编号，</span><br><span class="line">然后按照上面的数据就可以写出下面的过程：</span><br><span class="line"></span><br><span class="line">对于<span class="number">1</span> <span class="number">2</span> <span class="number">1</span>这条边：edge[<span class="number">0</span>].to=<span class="number">2</span>;   edge[<span class="number">0</span>].next=<span class="number">-1</span>;    head[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">对于<span class="number">2</span> <span class="number">3</span> <span class="number">2</span>这条边：edge[<span class="number">1</span>].to=<span class="number">3</span>;   edge[<span class="number">1</span>].next=<span class="number">-1</span>;    head[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">对于<span class="number">3</span> <span class="number">4</span> <span class="number">3</span>这条边：edge[<span class="number">2</span>].to=<span class="number">4</span>;   edge[<span class="number">2</span>],next=<span class="number">-1</span>;    head[<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">对于<span class="number">1</span> <span class="number">3</span> <span class="number">4</span>这条边：edge[<span class="number">3</span>].to=<span class="number">3</span>;   edge[<span class="number">3</span>].next= <span class="number">0</span>;    head[<span class="number">1</span>]=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">对于<span class="number">4</span> <span class="number">1</span> <span class="number">5</span>这条边：edge[<span class="number">4</span>].to=<span class="number">1</span>;   edge[<span class="number">4</span>].next=<span class="number">-1</span>;    head[<span class="number">4</span>]=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">对于<span class="number">1</span> <span class="number">5</span> <span class="number">6</span>这条边：edge[<span class="number">5</span>].to=<span class="number">5</span>;   edge[<span class="number">5</span>].next= <span class="number">3</span>;    head[<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">对于<span class="number">4</span> <span class="number">5</span> <span class="number">7</span>这条边：edge[<span class="number">6</span>].to=<span class="number">5</span>;   edge[<span class="number">6</span>].next= <span class="number">4</span>;    head[<span class="number">4</span>]=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">很明显,head[i]保存的是以i为起点的所有边中编号最大的那个,而把这个当作顶点i的第一条起始边的位置.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">遍历函数如下：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123; <span class="comment">//n个起点    </span></span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i]; j!=<span class="number">-1</span>; j=edge[j].next) <span class="comment">//遍历以i为起点的所有边        </span></span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;edge[j].to&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;edge[j].w&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">第一层<span class="keyword">for</span>循环：依次遍历以<span class="number">1.</span>..n为起点的边的集合。</span><br><span class="line">第二层<span class="keyword">for</span>循环：遍历以i为起点的所有边，j首先等于head[i]。</span><br><span class="line">注意：head[i]表示与点i起点相同的最后一条边的编号。</span><br><span class="line">然后，通过edge[j].next来找与边j起点相同的上一条边的编号，终止条件为edge[j].next=<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-图搜索算法"><a href="#2-1-2-图搜索算法" class="headerlink" title="2.1.2 图搜索算法"></a>2.1.2 图搜索算法</h3><ul>
<li><p>  深度优先搜索</p>
</li>
<li><p>  广度优先搜索</p>
</li>
<li><p>贪婪最佳优先算法</p>
<p>  <img src="./imgs/qifashi1.png"></p>
<p>  <img src="./imgs/qifashi2.png"></p>
<p>  <img src="./imgs/qifashi3.png"></p>
</li>
<li><p>Dijkstra 算法</p>
<p>  <img src="./imgs/dij1.png"></p>
<p>  <img src="./imgs/dij2.png"></p>
<p>  <img src="./imgs/dij3.png"></p>
</li>
<li><p>A* 算法</p>
<p>  <img src="./imgs/astar1.png"></p>
</li>
<li><p>Bellman-Ford 算法</p>
<p>  <img src="./imgs/bellmanford1.png"></p>
</li>
<li><p>SPFA 算法</p>
<p>  <img src="./imgs/spfa1.png"></p>
</li>
</ul>
<h3 id="2-1-3-图排序算法"><a href="#2-1-3-图排序算法" class="headerlink" title="2.1.3 图排序算法"></a>2.1.3 图排序算法</h3><ul>
<li><p>拓扑排序</p>
<p>  <img src="./imgs/toposort1.png"></p>
</li>
<li></li>
</ul>
<h2 id="LC207-课程表"><a href="#LC207-课程表" class="headerlink" title="LC207 课程表"></a>LC207 课程表</h2><p><img src="./imgs/lc207q.png"></p>
<p><img src="./imgs/lc207a1.png"></p>
<p><img src="./imgs/lc207a2.png"></p>
<p>这是一道经典的拓扑排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	degree := <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">	edges := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> edges &#123;</span><br><span class="line">		edges[i] = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, prerequisite := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">		edges[prerequisite[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[prerequisite[<span class="number">1</span>]], prerequisite[<span class="number">0</span>])</span><br><span class="line">		degree[prerequisite[<span class="number">0</span>]]++</span><br><span class="line">	&#125;</span><br><span class="line">	queue := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> degree[i] == <span class="number">0</span> &#123;</span><br><span class="line">			queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">		cur := queue[<span class="number">0</span>]</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[cur] &#123;</span><br><span class="line">			degree[v]--</span><br><span class="line">			<span class="keyword">if</span> degree[v] == <span class="number">0</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, v)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> degree &#123;</span><br><span class="line">		<span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-线段树"><a href="#3-线段树" class="headerlink" title="3 线段树"></a>3 线段树</h1><h2 id="3-1-线段树概述"><a href="#3-1-线段树概述" class="headerlink" title="3.1 线段树概述"></a>3.1 线段树概述</h2><p><img src="./imgs/xianduanshu1.png"></p>
<p><img src="./imgs/xianduanshu2.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 移位运算符的优先级小于加减法，所以加上括号</span></span><br><span class="line">  <span class="comment">// 如果写成 (s + t) &gt;&gt; 1 可能会时间超限</span></span><br><span class="line">  <span class="built_in">build</span>(s, m, p * <span class="number">2</span>), <span class="built_in">build</span>(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./imgs/xianduanshu3.png"></p>
<p><img src="./imgs/xianduanshu4.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [l,r] 为查询区间,[s,t] 为当前节点包含的区间,p 为当前节点的编号</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)</span><br><span class="line">    <span class="keyword">return</span> d[p];  <span class="comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">  <span class="keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>), sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += <span class="built_in">getsum</span>(l, r, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 如果左儿子代表的区间 [l,m] 与询问区间有交集,则递归查询左儿子</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span>(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 如果右儿子代表的区间 [m+1,r] 与询问区间有交集,则递归查询右儿子</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./imgs/xianduanshu5.png"></p>
<p><img src="./imgs/xianduanshu6.png"></p>
<p><img src="./imgs/xianduanshu7.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改（区间加上某个值）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [l,r] 为修改区间,c 为被修改的元素的变化量,[s,t] 为当前节点包含的区间,p</span></span><br><span class="line">  <span class="comment">// 为当前节点的编号</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">    d[p] += (t - s + <span class="number">1</span>) * c, b[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;  <span class="comment">// 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span></span><br><span class="line">  <span class="keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (b[p] &amp;&amp; s != t) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    d[p * <span class="number">2</span>] += b[p] * (m - s + <span class="number">1</span>), d[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] * (t - m);</span><br><span class="line">    b[p * <span class="number">2</span>] += b[p], b[p * <span class="number">2</span> + <span class="number">1</span>] += b[p];  <span class="comment">// 将标记下传给子节点</span></span><br><span class="line">    b[p] = <span class="number">0</span>;                                <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) <span class="built_in">update</span>(l, r, c, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) <span class="built_in">update</span>(l, r, c, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[p * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间查询（区间求和）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [l,r] 为查询区间,[s,t] 为当前节点包含的区间,p为当前节点的编号</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">  <span class="comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">  <span class="keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (b[p]) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    d[p * <span class="number">2</span>] += b[p] * (m - s + <span class="number">1</span>), d[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] * (t - m),</span><br><span class="line">        b[p * <span class="number">2</span>] += b[p], b[p * <span class="number">2</span> + <span class="number">1</span>] += b[p];  <span class="comment">// 将标记下传给子节点</span></span><br><span class="line">    b[p] = <span class="number">0</span>;                                    <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum = <span class="built_in">getsum</span>(l, r, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span>(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你是要实现区间修改为某一个值而不是加上某一个值的话，代码如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">    d[p] = (t - s + <span class="number">1</span>) * c, b[p] = c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (b[p]) &#123;</span><br><span class="line">    d[p * <span class="number">2</span>] = b[p] * (m - s + <span class="number">1</span>), d[p * <span class="number">2</span> + <span class="number">1</span>] = b[p] * (t - m),</span><br><span class="line">          b[p * <span class="number">2</span>] = b[p * <span class="number">2</span> + <span class="number">1</span>] = b[p];</span><br><span class="line">    b[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) <span class="built_in">update</span>(l, r, c, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) <span class="built_in">update</span>(l, r, c, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[p * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">  <span class="keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (b[p]) &#123;</span><br><span class="line">    d[p * <span class="number">2</span>] = b[p] * (m - s + <span class="number">1</span>), d[p * <span class="number">2</span> + <span class="number">1</span>] = b[p] * (t - m),</span><br><span class="line">          b[p * <span class="number">2</span>] = b[p * <span class="number">2</span> + <span class="number">1</span>] = b[p];</span><br><span class="line">    b[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum = <span class="built_in">getsum</span>(l, r, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span>(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-线段树实现"><a href="#3-2-线段树实现" class="headerlink" title="3.2 线段树实现"></a>3.2 线段树实现</h2><p>二叉树的节点区间定义，<code>[start, end]</code>代表节点的区间范围，<code>max</code> 是节点在<code>[start, end]</code>区间上的最大值 <code>left</code> , <code>right</code> 是当前节点区间划分之后的左右节点区间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点区间定义</span></span><br><span class="line"><span class="comment">// [start, end] 代表节点的区间范围</span></span><br><span class="line"><span class="comment">// max 是节点在(start,end)区间上的最大值</span></span><br><span class="line"><span class="comment">// left , right 是当前节点区间划分之后的左右节点区间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> start, end, max;</span><br><span class="line">    <span class="keyword">public</span> SegmentTreeNode left, right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeNode</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.max = max</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个区间，我们要维护线段树中存在的区间中最大的值。这将有利于我们高效的查询任何区间的最大值。给出<code>A</code>数组，基于<code>A</code>数组构建一棵维护最大值的线段树，我们可以在<code>O(logN)</code>的复杂度内查询任意区间的最大值：</p>
<p>比如原数组 <code>A = [1, 4, 2, 3]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造的代码及注释</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">return</span> buildhelper(<span class="number">0</span>, A.length - <span class="number">1</span>, A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">buildhelper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTreeNode root = <span class="keyword">new</span> SegmentTreeNode(left, right, A[left]); <span class="comment">// 根据节点区间的左边界的序列值为节点赋初值</span></span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 如果左边界和右边界相等,节点左边界的序列值就是线段树节点的接节点值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 划分当前区间的左右区间</span></span><br><span class="line">    root.left = buildhelper(left, mid, A);</span><br><span class="line">    root.right = buildhelper(mid + <span class="number">1</span>, right, A);</span><br><span class="line">    root.max = Math.max(root.left.max, root.right.max); <span class="comment">// 根据节点区间的左右区间的节点值得到当前节点的节点值</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举一反三：</strong><br> 如果需要区间的最小值:<br> <code>root.min = Math.min(root.left.min, root.right.min);</code><br> 如果需要区间的和:<br> <code>root.sum = root.left.sum + root.right.sum;</code></p>
<p>更新序列中的一个节点，如何把这种变化体现到线段树中去? 更新所以需要从叶子节点一路走到根节点, 去更新线段树上的值。因为线段树的高度为<code>log(n)</code>,所以更新序列中一个节点的复杂度为<code>log(n)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点更新的代码及注释</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(SegmentTreeNode root, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(root.start == root.end &amp;&amp; root.start == index) &#123; <span class="comment">// 找到被改动的叶子节点</span></span><br><span class="line">        root.max = value; <span class="comment">// 改变value值</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>; <span class="comment">// 将当前节点区间分割为2个区间的分割线</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt;= mid)&#123; <span class="comment">// 如果index在当前节点的左边</span></span><br><span class="line">        modify(root.left, index, value); <span class="comment">// 递归操作</span></span><br><span class="line">        root.max = Math.max(root.right.max, root.left.max); <span class="comment">// 可能对当前节点的影响</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;            <span class="comment">// 如果index在当前节点的右边</span></span><br><span class="line">        modify(root.right, index, value); <span class="comment">// 递归操作</span></span><br><span class="line">        root.max = Math.max(root.left.max, root.right.max); <span class="comment">// 可能对当前节点的影响</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线段树的区间查询操作就是将当前区间分解为较小的子区间,然后由子区间的最大值就可以快速得到需要查询区间的最大值。任意长度的线段，最多被拆分成$log(n)$​条线段树上存在的线段，所以查询的时间复杂度为<code>O(log(n))</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间查询的代码及注释</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(TreeNode root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= root.start &amp;&amp; root.end &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// 如果查询区间在当前节点的区间之内,直接输出结果</span></span><br><span class="line">        <span class="keyword">return</span> root.max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>; <span class="comment">// 将当前节点区间分割为左右2个区间的分割线</span></span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MIN_VALUE; <span class="comment">// 给结果赋初值</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= start) &#123;   <span class="comment">// 如果查询区间和左边节点区间有交集,则寻找查询区间在左边区间上的最大值</span></span><br><span class="line">        ans = Math.max(ans, query(root.left, start, end));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= end) &#123; <span class="comment">// 如果查询区间和右边节点区间有交集,则寻找查询区间在右边区间上的最大值</span></span><br><span class="line">        ans = Math.max(ans, query(root.right, start, end));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">// 返回查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 Segment Tree 线段树逻辑上是一棵二叉树，<strong>但是实际存储时可以通过数组来实现，</strong>通过父子节点的下标的数值关系可以访问父节点的子节点。</p>
<p>例如通过如下代码将一个数组转换为一个 Segment Tree：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a segment tree</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] seg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the element count</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    n = nums.length;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        seg = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span> * n];</span><br><span class="line">    </span><br><span class="line">        build(nums, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build segment tree, set the value of seg[idx]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        seg[idx] = nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// build left tree</span></span><br><span class="line">        build(nums, start, mid, <span class="number">2</span> * idx + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// build right tree</span></span><br><span class="line">        build(nums, mid + <span class="number">1</span>, end, <span class="number">2</span> * idx + <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        seg[idx] = seg[<span class="number">2</span> * idx + <span class="number">1</span>] + seg[<span class="number">2</span> * idx + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更新元素：</strong>更新元素需要更新两个地方，一是原数组对应的下标的值，另外一个是包含了这个元素的 Segment Tree 中的节点的值。具体也是通过递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    update(<span class="number">0</span>, n - <span class="number">1</span>, i, val, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> i, <span class="keyword">int</span> val, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// leaf node. update element.</span></span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        seg[idx] = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// left tree</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">        update(start, mid, i, val, <span class="number">2</span> * idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// right tree</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        update(mid + <span class="number">1</span>, end, i, val, <span class="number">2</span> * idx + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    seg[idx] = seg[<span class="number">2</span> * idx + <span class="number">1</span>] + seg[<span class="number">2</span> * idx + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区间求和：</strong>区间求和也是通过递归实现，关键在于根据当前节点表示的范围以及需要求的区间的范围的关系进行求和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumRange(<span class="number">0</span>, n - <span class="number">1</span>, i, j, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// segment completely outside range, represents a null node</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; j || end &lt; i)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// segment completely inside range</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= start &amp;&amp; j &gt;= end)</span><br><span class="line">        <span class="keyword">return</span> seg[idx];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sumRange(start, mid, i, j, <span class="number">2</span> * idx + <span class="number">1</span>) +</span><br><span class="line">        sumRange(mid + <span class="number">1</span>, end, i, j, <span class="number">2</span> * idx + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LiC201-线段树的构造"><a href="#LiC201-线段树的构造" class="headerlink" title="LiC201 线段树的构造"></a>LiC201 线段树的构造</h2><p><img src="./imgs/lic201q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状的线段树实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    SegmentTreeNode *left, *right;</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start, <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param start: start value.</span></span><br><span class="line"><span class="comment">     * @param end: end value.</span></span><br><span class="line"><span class="comment">     * @return: The root of Segment Tree.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SegmentTreeNode *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SegmentTreeNode* root = <span class="keyword">new</span> <span class="built_in">SegmentTreeNode</span>(start, end);</span><br><span class="line">        <span class="keyword">if</span> (start != end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            root-&gt;left = <span class="built_in">build</span>(start, mid);</span><br><span class="line">            root-&gt;right = <span class="built_in">build</span>(mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LiC202-线段树的查询"><a href="#LiC202-线段树的查询" class="headerlink" title="LiC202 线段树的查询"></a>LiC202 线段树的查询</h2><p><img src="./imgs/lic202q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start, end, max;</span><br><span class="line">    SegmentTreeNode *left, *right;</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start, <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root: The root of segment tree.</span></span><br><span class="line"><span class="comment">     * @param start: start value.</span></span><br><span class="line"><span class="comment">     * @param end: end value.</span></span><br><span class="line"><span class="comment">     * @return: The maximum number in the interval [start, end]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> INT32_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">query</span>(root-&gt;left, start, end), <span class="built_in">query</span>(root-&gt;right, start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LiC203-线段树的修改"><a href="#LiC203-线段树的修改" class="headerlink" title="LiC203 线段树的修改"></a>LiC203 线段树的修改</h2><p><img src="./imgs/lic203q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start, end, max;</span><br><span class="line">    SegmentTreeNode *left, *right;</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start, <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param root: The root of segment tree.</span></span><br><span class="line"><span class="comment">     * @param index: index.</span></span><br><span class="line"><span class="comment">     * @param value: value</span></span><br><span class="line"><span class="comment">     * @return: nothing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(SegmentTreeNode * root, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是叶子节点，修改值</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;max = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在左侧</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= root-&gt;left-&gt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(root-&gt;left, index, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在右侧</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(root-&gt;right, index, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;max = std::<span class="built_in">max</span>(root-&gt;left-&gt;max, root-&gt;right-&gt;max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LiC247-线段树的查询2"><a href="#LiC247-线段树的查询2" class="headerlink" title="LiC247 线段树的查询2"></a>LiC247 线段树的查询2</h2><p><img src="./imgs/lic247q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start, end, count;</span><br><span class="line">    SegmentTreeNode *left, *right;</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">        <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param root: The root of segment tree.</span></span><br><span class="line"><span class="comment">     * @param start: start value.</span></span><br><span class="line"><span class="comment">     * @param end: end value.</span></span><br><span class="line"><span class="comment">     * @return: The count number in the interval [start, end]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 查询到子区间</span></span><br><span class="line">        <span class="comment">// 画个图就能明白，因为越接近根的区间越大，所以一定是先覆盖能覆盖的最大子区间，保证了完全覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(root-&gt;left, start, end) + <span class="built_in">query</span>(root-&gt;right, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LiC439-线段树的构造2"><a href="#LiC439-线段树的构造2" class="headerlink" title="LiC439 线段树的构造2"></a>LiC439 线段树的构造2</h2><p><img src="./imgs/lic439q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start, end, max;</span><br><span class="line">    SegmentTreeNode *left, *right;</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">        <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">        <span class="keyword">this</span>-&gt;max = max;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param A: a list of integer</span></span><br><span class="line"><span class="comment">     * @return: The root of Segment Tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SegmentTreeNode *<span class="title">build</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildhelper</span>(<span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>, A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param start: start index</span></span><br><span class="line"><span class="comment">     * @param end: end index</span></span><br><span class="line"><span class="comment">     * @param A: a list of integer</span></span><br><span class="line"><span class="comment">     * @return: SegmentTreeNode* The root of Segment Tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SegmentTreeNode *<span class="title">buildhelper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, std::vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SegmentTreeNode *root = <span class="keyword">new</span> <span class="built_in">SegmentTreeNode</span>(start, end, INT_MIN);</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;max = A[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            root-&gt;left = <span class="built_in">buildhelper</span>(start, mid, A);</span><br><span class="line">            root-&gt;right = <span class="built_in">buildhelper</span>(mid + <span class="number">1</span>, end, A);</span><br><span class="line">            <span class="comment">// 如果是求和型，这里换成加号就完事了！</span></span><br><span class="line">            root-&gt;max = std::<span class="built_in">max</span>(root-&gt;left-&gt;max, root-&gt;right-&gt;max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LiC205-区间最小数"><a href="#LiC205-区间最小数" class="headerlink" title="LiC205 区间最小数"></a>LiC205 区间最小数</h2><p><img src="./imgs/lic205q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    <span class="built_in">Interval</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">        <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end, min;</span><br><span class="line">    SegmentTreeNode *left, *right;</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> min) : <span class="built_in">start</span>(start), <span class="built_in">end</span>(end), <span class="built_in">min</span>(min) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tree = <span class="built_in">buildhelper</span>(<span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>, A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> Interval&amp; interval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queryhelper</span>(<span class="keyword">this</span>-&gt;tree, interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SegmentTreeNode *tree;</span><br><span class="line"></span><br><span class="line">    <span class="function">SegmentTreeNode *<span class="title">buildhelper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SegmentTreeNode *root = <span class="keyword">new</span> <span class="built_in">SegmentTreeNode</span>(start, end, INT_MAX);</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;min = A[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            root-&gt;left = <span class="built_in">buildhelper</span>(start, mid, A);</span><br><span class="line">            root-&gt;right = <span class="built_in">buildhelper</span>(mid + <span class="number">1</span>, end, A);</span><br><span class="line">            root-&gt;min = std::<span class="built_in">min</span>(root-&gt;left-&gt;min, root-&gt;right-&gt;min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queryhelper</span><span class="params">(SegmentTreeNode *root, <span class="keyword">const</span> Interval&amp; interval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; interval.start || root-&gt;start &gt; interval.end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= interval.start &amp;&amp; root-&gt;end &lt;= interval.end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">min</span>(<span class="built_in">queryhelper</span>(root-&gt;left, interval), <span class="built_in">queryhelper</span>(root-&gt;right, interval));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param A: An integer array</span></span><br><span class="line"><span class="comment">     * @param queries: An query list</span></span><br><span class="line"><span class="comment">     * @return: The result list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">intervalMinNumber</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;A, std::vector&lt;Interval&gt; &amp;queries)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="function">SegmentTree <span class="title">tree</span><span class="params">(A)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; interval : queries)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tree.<span class="built_in">query</span>(interval));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LiC207-区间求和2"><a href="#LiC207-区间求和2" class="headerlink" title="LiC207 区间求和2"></a>LiC207 区间求和2</h2><p><img src="./imgs/lic207q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTreeNode2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    <span class="keyword">int64_t</span> sum;</span><br><span class="line">    SegmentTreeNode2 *left, *right;</span><br><span class="line">    <span class="built_in">SegmentTreeNode2</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> min) : <span class="built_in">start</span>(start), <span class="built_in">end</span>(end), <span class="built_in">min</span>(min) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = <span class="built_in">buildhelper</span>(<span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>, A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int64_t</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SegmentTree::<span class="built_in">queryhelper</span>(<span class="keyword">this</span>-&gt;tree, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SegmentTree::<span class="built_in">modifyhelper</span>(<span class="keyword">this</span>-&gt;tree, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SegmentTreeNode2 *tree;</span><br><span class="line"></span><br><span class="line">    <span class="function">SegmentTreeNode2 *<span class="title">buildhelper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SegmentTreeNode2 *root = <span class="keyword">new</span> <span class="built_in">SegmentTreeNode2</span>(start, end, INT_MAX);</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;sum = (<span class="keyword">int64_t</span>)A[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            root-&gt;left = <span class="built_in">buildhelper</span>(start, mid, A);</span><br><span class="line">            root-&gt;right = <span class="built_in">buildhelper</span>(mid + <span class="number">1</span>, end, A);</span><br><span class="line">            root-&gt;sum = root-&gt;left-&gt;sum + root-&gt;right-&gt;sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyhelper</span><span class="params">(SegmentTreeNode2 *root, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是叶子节点，修改值</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;sum = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在左侧</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= root-&gt;left-&gt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">modifyhelper</span>(root-&gt;left, index, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在右侧</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">modifyhelper</span>(root-&gt;right, index, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;sum = root-&gt;left-&gt;sum + root-&gt;right-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">queryhelper</span><span class="params">(SegmentTreeNode2 *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 查询到子区间</span></span><br><span class="line">        <span class="comment">// 画个图就能明白，因为越接近根的区间越大，所以一定是先覆盖能覆盖的最大子区间，保证了完全覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SegmentTree::<span class="built_in">queryhelper</span>(root-&gt;left, start, end) + SegmentTree::<span class="built_in">queryhelper</span>(root-&gt;right, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* you may need to use some attributes here */</span></span><br><span class="line">    SegmentTree *tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @param A: An integer array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">Solution</span>(std::vector&lt;<span class="keyword">int</span>&gt; A)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do intialization if necessary</span></span><br><span class="line">        tree = <span class="keyword">new</span> <span class="built_in">SegmentTree</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param start: An integer</span></span><br><span class="line"><span class="comment">     * @param end: An integer</span></span><br><span class="line"><span class="comment">     * @return: The sum from start to end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int64_t</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        tree-&gt;<span class="built_in">query</span>(start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param index: An integer</span></span><br><span class="line"><span class="comment">     * @param value: An integer</span></span><br><span class="line"><span class="comment">     * @return: nothing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        tree-&gt;<span class="built_in">modify</span>(index, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LiC751-约翰的生意"><a href="#LiC751-约翰的生意" class="headerlink" title="LiC751 约翰的生意"></a>LiC751 约翰的生意</h2><p><img src="./imgs/lic751q.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTreeNode2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end, min;</span><br><span class="line">    SegmentTreeNode2 *left, *right;</span><br><span class="line">    <span class="built_in">SegmentTreeNode2</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> min) : <span class="built_in">start</span>(start), <span class="built_in">end</span>(end), <span class="built_in">min</span>(min) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = <span class="built_in">buildhelper</span>(<span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>, A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SegmentTree::<span class="built_in">queryhelper</span>(<span class="keyword">this</span>-&gt;tree, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SegmentTreeNode2 *tree;</span><br><span class="line"></span><br><span class="line">    <span class="function">SegmentTreeNode2 *<span class="title">buildhelper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SegmentTreeNode2 *root = <span class="keyword">new</span> <span class="built_in">SegmentTreeNode2</span>(start, end, INT_MAX);</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;min = A[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            root-&gt;left = <span class="built_in">buildhelper</span>(start, mid, A);</span><br><span class="line">            root-&gt;right = <span class="built_in">buildhelper</span>(mid + <span class="number">1</span>, end, A);</span><br><span class="line">            root-&gt;min = std::<span class="built_in">min</span>(root-&gt;left-&gt;min, root-&gt;right-&gt;min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queryhelper</span><span class="params">(SegmentTreeNode2 *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询到子区间</span></span><br><span class="line">        <span class="comment">// 画个图就能明白，因为越接近根的区间越大，所以一定是先覆盖能覆盖的最大子区间，保证了完全覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(SegmentTree::<span class="built_in">queryhelper</span>(root-&gt;left, start, end) ,SegmentTree::<span class="built_in">queryhelper</span>(root-&gt;right, start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param A: The prices [i]</span></span><br><span class="line"><span class="comment">     * @param k: </span></span><br><span class="line"><span class="comment">     * @return: The ans array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">business</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> <span class="built_in">SegmentTree</span>(A);</span><br><span class="line">        <span class="keyword">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = std::<span class="built_in">max</span>(<span class="number">0</span>, i - k);</span><br><span class="line">            <span class="keyword">int</span> right = std::<span class="built_in">min</span>(i + k, len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> max = A[i] - root-&gt;<span class="built_in">query</span>(left, right);</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(std::<span class="built_in">max</span>(max, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-前缀和"><a href="#4-前缀和" class="headerlink" title="4. 前缀和"></a>4. 前缀和</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>前缀和思想和滑动窗口会经常用在求子数组和子串问题上，当我们遇到此类问题时，则应该需要想到此类解题方式，该文章深入浅出描述前缀和思想，读完这个文章就会有属于自己的解题框架，遇到此类问题时就能够轻松应对。</p>
<p>下面我们先来了解一下什么是前缀和。</p>
<p>前缀和其实我们很早之前就了解过的，我们求数列的和时，$Sn = a1+a2+a3+…an$; 此时Sn就是数列的前 n 项和。例 $S5 = a1 + a2 + a3 + a4 + a5$; $S2 = a1 + a2$。所以我们完全可以通过 $S5-S2$ 得到 $a3+a4+a5$ 的值，这个过程就和我们做题用到的前缀和思想类似。我们的前缀和数组里保存的就是前 n 项的和。见下图</p>
<p><img src="./imgs/presum1.png"></p>
<p>所以我们通过前缀和数组可以轻松得到每个区间的和。</p>
<h2 id="LC560-和为-k-的子数组"><a href="#LC560-和为-k-的子数组" class="headerlink" title="LC560 和为 k 的子数组"></a>LC560 和为 k 的子数组</h2><p><img src="./imgs/lc560q.png"></p>
<blockquote>
<p>  前缀和 + HashMap</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraySum</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	cumsum := <span class="number">0</span></span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        cumsum += num</span><br><span class="line">        <span class="keyword">if</span> _, ok := mp[cumsum-k]; ok &#123;</span><br><span class="line">            ret += mp[cumsum-k]</span><br><span class="line">        &#125;</span><br><span class="line">        mp[cumsum] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC974-和可被-K-整除的子数组"><a href="#LC974-和可被-K-整除的子数组" class="headerlink" title="LC974 和可被 K 整除的子数组"></a>LC974 和可被 K 整除的子数组</h2><p><img src="./imgs/lc974q.png"></p>
<p><img src="./imgs/lc974a1.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同余类的简单应用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraysDivByK</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	mp := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>&#125;</span><br><span class="line">	cumsum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		cumsum += num</span><br><span class="line">		mp[(cumsum%k+k)%k]++</span><br><span class="line">	&#125;</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">		ret += (v - <span class="number">1</span>) * v / <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC1838-最高频元素的频次"><a href="#LC1838-最高频元素的频次" class="headerlink" title="LC1838 最高频元素的频次"></a>LC1838 最高频元素的频次</h2><p><img src="./imgs/lc1838q.png"></p>
<p><img src="./imgs/lc1838a1.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxFrequency</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		sum = <span class="built_in">append</span>(sum, sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	checker := <span class="function"><span class="keyword">func</span><span class="params">(sum []<span class="keyword">int</span>, n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> l := <span class="number">0</span>; l+n<span class="number">-1</span> &lt; <span class="built_in">len</span>(sum)<span class="number">-1</span>; l++ &#123;</span><br><span class="line">			r := l + n - <span class="number">1</span></span><br><span class="line">			cur := sum[r+<span class="number">1</span>] - sum[l]</span><br><span class="line">			t := nums[r] * n</span><br><span class="line">			<span class="keyword">if</span> t-cur &lt;= k &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">		m := (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> checker(sum, m, k) &#123;</span><br><span class="line">			l = m</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r = m - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC1744-吃糖问题"><a href="#LC1744-吃糖问题" class="headerlink" title="LC1744 吃糖问题"></a>LC1744 吃糖问题</h2><p><img src="./imgs/lc1744q.png"></p>
<blockquote>
<p>  前缀和问题，求在第 t 类之前有多少糖，然后按最快速度和最慢速度分别吃即可。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">canEat</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;candiesCount, std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;queries)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> len = candiesCount.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">size_t</span> qlen = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int64_t</span>&gt; <span class="title">sum</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        std::vector&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + candiesCount[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; qlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; q = queries[i];</span><br><span class="line">            <span class="comment">// d+1是因为sum数组有前导0</span></span><br><span class="line">            <span class="keyword">int64_t</span> t = q[<span class="number">0</span>], d = q[<span class="number">1</span>] + <span class="number">1</span>, c = q[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int64_t</span> l = (sum[t]/c) + <span class="number">1</span>, r = sum[t+<span class="number">1</span>];</span><br><span class="line">            ans.<span class="built_in">push_back</span>(l &lt;= d &amp;&amp; d &lt;= r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LCMS17-24-最大子矩阵"><a href="#LCMS17-24-最大子矩阵" class="headerlink" title="LCMS17.24 最大子矩阵"></a>LCMS17.24 最大子矩阵</h2><p><img src="./imgs/lc_ms17_24q.png"></p>
<blockquote>
<p>  遍历列的上下边界，按列求和得到数组d，寻找d的最大子序列和即可</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> <span class="params">(ans []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	sum := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	maxsum := -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">	<span class="comment">// r1, c1, r2, c2</span></span><br><span class="line">	ans = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="comment">// r, c</span></span><br><span class="line">	cur := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		sum = <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">		<span class="keyword">for</span> j := i; j &lt; n; j++ &#123;</span><br><span class="line">			dpsum := <span class="number">0</span></span><br><span class="line">			<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; m; k++ &#123;</span><br><span class="line">				sum[k] += matrix[j][k]</span><br><span class="line">				<span class="comment">// 最大子序和只用判断前面的和是不是负数，是就从这里重新开始</span></span><br><span class="line">				<span class="keyword">if</span> dpsum &gt; <span class="number">0</span> &#123;</span><br><span class="line">					dpsum += sum[k]</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					dpsum = sum[k]</span><br><span class="line">					cur[<span class="number">0</span>], cur[<span class="number">1</span>] = i, k</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> dpsum &gt; maxsum &#123;</span><br><span class="line">					maxsum = dpsum</span><br><span class="line">					ans[<span class="number">2</span>], ans[<span class="number">3</span>] = j, k</span><br><span class="line">					ans[<span class="number">0</span>], ans[<span class="number">1</span>] = cur[<span class="number">0</span>], cur[<span class="number">1</span>]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC238-除自身以外数组的乘积"><a href="#LC238-除自身以外数组的乘积" class="headerlink" title="LC238 除自身以外数组的乘积"></a>LC238 除自身以外数组的乘积</h2><p><img src="./imgs/lc238q.png"></p>
<blockquote>
<p>  前缀积（大雾</p>
</blockquote>
<p><img src="./imgs/lc238a1.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftmul</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            leftmul[i] = leftmul[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rightmul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            leftmul[i] *= rightmul;</span><br><span class="line">            rightmul *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        leftmul[<span class="number">0</span>] = rightmul;</span><br><span class="line">        <span class="keyword">return</span> leftmul;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC1074-元素和为目标值的子矩阵数量"><a href="#LC1074-元素和为目标值的子矩阵数量" class="headerlink" title="LC1074 元素和为目标值的子矩阵数量"></a>LC1074 元素和为目标值的子矩阵数量</h2><p><img src="./imgs/lc1074q.png"></p>
<blockquote>
<p>  依旧是遍历列的上下边界子矩阵前缀和</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraySum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mp := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	mp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	prv := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		prv += num</span><br><span class="line">		<span class="keyword">if</span> _, ok := mp[prv-target]; ok &#123;</span><br><span class="line">			ans += mp[prv-target]</span><br><span class="line">		&#125;</span><br><span class="line">		mp[prv]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m, n := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">		sum := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">		<span class="keyword">for</span> j := i; j &lt; m; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> c := <span class="number">0</span>; c &lt; n; c++ &#123;</span><br><span class="line">				sum[c] += matrix[j][c]</span><br><span class="line">			&#125;</span><br><span class="line">			ans += subarraySum(sum, target)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC862-和至少为-K-的最短子数组"><a href="#LC862-和至少为-K-的最短子数组" class="headerlink" title="LC862 和至少为 K 的最短子数组"></a>LC862 和至少为 K 的最短子数组</h2><p><img src="./imgs/lc862q.png"></p>
<p><img src="./imgs/lc862a1.png"></p>
<blockquote>
<ul>
<li><p>为什么要用单调队列？</p>
<p>  因为是求区间最短，可以很显然可以想到滑动窗，但是这个数组并不满足单调性：数组中存在负数，导致窗口值不单调，但是因为有负数所以才会导致当我们找到某个窗口和蔚K，窗内依然可能存在可行解，原因如下：<br>  对于j前面满足≥K的所有i，如果$i_1 &lt; i_2, arr[i_1] &gt; arr[i_2]$,那么可行解一定是i2，因为$i_2$更大且$arr[i_2]$更小<br>  所以我们可以维护一个单调队列保证窗口内值的单调性：<br>  思路：基于最近我们总是希望对于每个右指针j，左指针能够尽可能的靠近，并且值尽可能地大，如果有一个i-1的值&gt;i处的值，那么i-1处的值就一定不是正确解，因为i处的值更近并且能够得到的数组和更大，如果i-1满足i一定满足，以此来减少我们的判断量<br>  如果队首的值满足当前值-队首值&gt;=K,记录长度并弹出队首<br>  如果当前值&lt;队列尾，那么弹出队尾保持队列单调</p>
<p>  作者：ppppjcute<br>  链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/solution/java-qian-zhui-he-yu-shuang-duan-by-ppppjqute/">https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/solution/java-qian-zhui-he-yu-shuang-duan-by-ppppjqute/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> [] arr = <span class="keyword">new</span> <span class="keyword">long</span> [A.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            arr[i+<span class="number">1</span>] = arr[i]+A[i];</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;=K) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">//得到前缀和数组</span></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;=A.length-1;i++)&#123;  //暴力破解 N^2 超时</span></span><br><span class="line">        <span class="comment">//     for(int j = i+1;j&lt;=A.length;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(arr[j]-arr[i]&gt;=K)&#123;</span></span><br><span class="line">        <span class="comment">//             res = Math.min(j-i,res);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;arr[i]&lt;=arr[queue.getLast()])   queue.removeLast();</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;arr[i]-arr[queue.peek()]&gt;=K)    res = Math.min(res,i-queue.poll());</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==Integer.MAX_VALUE?-<span class="number">1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：ppppjcute</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/solution/java-qian-zhui-he-yu-shuang-duan-by-ppppjqute/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h1 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5. 动态规划"></a>5. 动态规划</h1><h2 id="5-1-状态压缩：以-TSP-问题为例"><a href="#5-1-状态压缩：以-TSP-问题为例" class="headerlink" title="5.1 状态压缩：以 TSP 问题为例"></a>5.1 状态压缩：以 TSP 问题为例</h2><p>例子：旅行商问题。从一个城市出发，选择要走的路径，要求每个城市只能到达一次，而且最后要回到原来出发的城市，目标是选择最短路径。 TSP 问题是 NPC 问题，状态压缩 dp 可以做到 $O(n^2*2^n)$ 的复杂度。</p>
<p><img src="./imgs/yasuodp1.png"></p>
<p>将状态用掩码的形式储存： <code>path = [1, 3, 4] =&gt; path = 0x00001101</code></p>
<p>用 $dp[i][S]$ 表示当前在 $i$ 节点，已访问的节点集合为 $S$， 所经过的路径的最小权值和。状态转移方程：</p>
<p>$dp[j][S | (1 &lt;&lt; j)] = \min (dp[i][S] + W[i][j])$</p>
<p>$S | (1 &lt;&lt; j)$ 将第 $j$ 个二进制位置为 1， 即在当前访问路径里加上 j 。起始点可以是任意节点，所以初始条件是 $dp[i][1 &lt;&lt; i] = 0$。</p>
<p>设置循环时，保证 $S | (1 &lt;&lt; j)$ 在 $S$ 之后出现即可。显然，往 $S$ 添加二进制 1 会让 S 增大。所以循环条件是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n);; ++S) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>所以完整的核心代码为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++s)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) <span class="keyword">if</span> (!(s &amp; (<span class="number">1</span> &lt;&lt; j)) &amp;&amp; INFTY != W[i][j])</span><br><span class="line">            dp[j][s | (<span class="number">1</span> &lt;&lt; i)] = <span class="built_in">min</span>(dp[j][s | (<span class="number">1</span> &lt;&lt; i)], dp[i][s] + W[i][j]);</span><br></pre></td></tr></table></figure>

<h2 id="LC5856-完成任务的最少工作时间段"><a href="#LC5856-完成任务的最少工作时间段" class="headerlink" title="LC5856 完成任务的最少工作时间段"></a>LC5856 完成任务的最少工作时间段</h2><p><img src="./imgs/lc5856q.png"></p>
<blockquote>
<p>  注意：这不是个贪心的题！贪心需要局部最优和全局情况无关，但是这个是有关的！</p>
</blockquote>
<p><img src="./imgs/lc5856a1.png"></p>
<p><img src="./imgs/lc5856a2.png"></p>
<p><img src="./imgs/lc5856a3.png"></p>
<p><img src="./imgs/lc5856a4.png"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和思路略有不同的状态压缩，有bug</span></span><br><span class="line"><span class="comment">// bug 应该出在 INF 的设置上，之前的 15 是题解思路的 INF，枚举时间很容易就超过了</span></span><br><span class="line"><span class="comment">// 改成 i32::MAX &gt;&gt; 1 就能过了</span></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">min_sessions</span></span>(tasks: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, session_time: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="comment">// 1 &lt;= n &lt;= 14</span></span><br><span class="line">        <span class="keyword">let</span> n = tasks.len();</span><br><span class="line">        <span class="comment">// const INF: i32 = 15;</span></span><br><span class="line">        <span class="keyword">const</span> INF: <span class="built_in">i32</span> = <span class="built_in">i32</span>::MAX &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> m = (<span class="number">1</span> &lt;&lt; n) <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = <span class="built_in">vec!</span>[INF; m]; <span class="comment">// 记录到达状态 status 时需要用的最少时间</span></span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举所有状态</span></span><br><span class="line">        <span class="keyword">for</span> status <span class="keyword">in</span> <span class="number">1</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> status &amp; (<span class="number">1</span> &lt;&lt; i) != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> t = dp[status ^ (<span class="number">1</span> &lt;&lt; i)]; <span class="comment">// 去除掉当前任务的用时</span></span><br><span class="line">                    <span class="keyword">let</span> cur = t % session_time;    <span class="comment">// 去掉已经成组的后，额外多出的时间</span></span><br><span class="line">                    <span class="keyword">if</span> cur + tasks[i] &lt;= session_time &#123; <span class="comment">// 不用额外再开一组</span></span><br><span class="line">                        dp[status] = dp[status].min(t + tasks[i]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 需要重开一组</span></span><br><span class="line">                        dp[status] = dp[status].min(t + tasks[i] + session_time - cur); <span class="comment">// 之前的对齐到 session_time，因为一个任务不能跨两个组完成</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (dp[m-<span class="number">1</span>] + session_time - <span class="number">1</span>) / session_time</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC1723-完成所有工作所需要的最小时间"><a href="#LC1723-完成所有工作所需要的最小时间" class="headerlink" title="LC1723 完成所有工作所需要的最小时间"></a>LC1723 完成所有工作所需要的最小时间</h2><p><img src="./imgs/lc1723q.png"></p>
<h3 id="1-状态压缩-二分"><a href="#1-状态压缩-二分" class="headerlink" title="1. 状态压缩 + 二分"></a>1. 状态压缩 + 二分</h3><p><img src="./imgs/lc1723a1.png"></p>
<blockquote>
<p>  此法较易理解，单调性和二分的左右界都是显然的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;jobs, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lb = *std::<span class="built_in">max_element</span>(jobs.<span class="built_in">begin</span>(), jobs.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> rb = std::<span class="built_in">accumulate</span>(jobs.<span class="built_in">begin</span>(), jobs.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = jobs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">tot</span><span class="params">(<span class="number">1</span> &lt;&lt; n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 状态 s 不含元素 i</span></span><br><span class="line">                <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tot[s] = tot[s ^ (<span class="number">1</span> &lt;&lt; i)] + jobs[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rb &gt; lb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> md = (rb + lb) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; n, INT_MAX &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// i = (i - 1) &amp; s 可以不重复遍历所有状态吗？肯定是可以遍历完的，但是没重复怎么证明？</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i; i = (i - <span class="number">1</span>) &amp; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tot[i] &lt;= md)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[s] = std::<span class="built_in">min</span>(dp[s], dp[s - i] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                rb = md;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                lb = md + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-状态压缩-DP"><a href="#2-状态压缩-DP" class="headerlink" title="2. 状态压缩 DP"></a>2. 状态压缩 DP</h3><p><img src="./imgs/lc1723a2.png"></p>
<blockquote>
<p>  要背的板： 遍历全子集状态 <code>for (int subs = s; subs; subs = (subs - 1) &amp; s)</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;jobs, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = jobs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ss = <span class="number">1</span> &lt;&lt; n; <span class="comment">// 全状态</span></span><br><span class="line">        std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(k, std::vector&lt;<span class="keyword">int</span>&gt;(ss, <span class="number">-1</span>));</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">tot</span><span class="params">(ss, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; ss; ++s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tot[s] = tot[s ^ (<span class="number">1</span> &lt;&lt; i)] + jobs[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; ss; ++s)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][s] = tot[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; ss; ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = s; j; j = (j<span class="number">-1</span>) &amp; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    mn = std::<span class="built_in">min</span>(mn, std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][s ^ j], tot[j]));</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][s] = mn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k<span class="number">-1</span>][ss<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC689-划分为-k-个相等的子集"><a href="#LC689-划分为-k-个相等的子集" class="headerlink" title="LC689 划分为 k 个相等的子集"></a>LC689 划分为 k 个相等的子集</h2><p><img src="./imgs/lc689q.png"></p>
<blockquote>
<p>  排序 dp，看添加之后是否能保证和小于等于 sum(num) / k ，不然肯定为 False</p>
</blockquote>
<p><img src="./imgs/lc689a1.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ss = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        <span class="keyword">int</span> sum = std::<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> t = sum / k;</span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">back</span>() &gt; t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">uint8_t</span>&gt; <span class="title">dp</span><span class="params">(ss, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">csum</span><span class="params">(ss, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; ss; ++s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[s]) <span class="comment">// 不可能往下走了，剪枝</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (((s | (<span class="number">1</span> &lt;&lt; i)) == s)) <span class="comment">// 考虑过了</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> nxts = s | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                <span class="keyword">if</span> (csum[s] % t + nums[i] &lt;= t)</span><br><span class="line">                &#123;</span><br><span class="line">                    csum[nxts] = csum[s] + nums[i];</span><br><span class="line">                    dp[nxts] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[ss<span class="number">-1</span>] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC526-优美排列"><a href="#LC526-优美排列" class="headerlink" title="LC526 优美排列"></a>LC526 优美排列</h2><p><img src="./imgs/lc526q.png"></p>
<p><img src="./imgs/lc526a1.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Matrix = std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">makeMatrix</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> init)</span> </span>&#123; <span class="keyword">return</span> std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;(m, std::vector&lt;<span class="keyword">int</span>&gt;(n, init)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ss = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        Matrix dp = <span class="built_in">makeMatrix</span>(n + <span class="number">1</span>, ss, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; ss; ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))) == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (k % i != <span class="number">0</span> &amp;&amp; i % k != <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    dp[i][s] += dp[i - <span class="number">1</span>][s ^ (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][ss<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="./imgs/lc526a2.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ss = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(ss, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; ss; ++s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="built_in">count1</span>(s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(s &amp; (<span class="number">1</span> &lt;&lt; i)))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % cnt != <span class="number">0</span> &amp;&amp; cnt % (i + <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dp[s] += dp[s ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[ss - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-树形-DP"><a href="#5-2-树形-DP" class="headerlink" title="5.2 树形 DP"></a>5.2 树形 DP</h2><p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。</p>
<p>问题：给你一棵树 要求用最少的代价（最大的收益）完成给定的操作</p>
<p>树形DP 一般来说都是从叶子从而推出根 当然 从根推叶子的情况也有 不过很少</p>
<p>一般实现方式: DFS(包括记忆化搜索)，递推等</p>
<h2 id="LC124-二叉树中的最大路径和"><a href="#LC124-二叉树中的最大路径和" class="headerlink" title="LC124 二叉树中的最大路径和"></a>LC124 二叉树中的最大路径和</h2><p><img src="./imgs/lc124q.png"></p>
<p><img src="./imgs/lc124a1.png"></p>
<p>计算得到每个节点的最大贡献值后，根节点选择左右孩子贡献最大的一个即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> _ = <span class="built_in">getGain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getGain</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">getGain</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">getGain</span>(root-&gt;right);</span><br><span class="line">        l = (l &gt; <span class="number">0</span>)? l: <span class="number">0</span>;</span><br><span class="line">        r = (r &gt; <span class="number">0</span>)? r: <span class="number">0</span>;</span><br><span class="line">        ans = (ans &lt; l + r + root-&gt;val)? l + r + root-&gt;val: ans;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + std::<span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC834-树中距离之和"><a href="#LC834-树中距离之和" class="headerlink" title="LC834 树中距离之和"></a>LC834 树中距离之和</h2><p><img src="./imgs/lc834q.png"></p>
<p><img src="./imgs/lc834a1.png"></p>
<p><img src="./imgs/lc834a2.png"></p>
<p><img src="./imgs/lc834a3.png"></p>
<p><img src="./imgs/lc834a4.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路是这个思路，但是爆栈了，埋个坑用 C++ lambda Y 组合子写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfDistancesInTree</span><span class="params">(n <span class="keyword">int</span>, edges [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 建邻接表</span></span><br><span class="line">	graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		graph[i] = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, edge := <span class="keyword">range</span> edges &#123;</span><br><span class="line">		s, e := edge[<span class="number">0</span>], edge[<span class="number">1</span>]</span><br><span class="line">		graph[s] = <span class="built_in">append</span>(graph[s], e)</span><br><span class="line">		graph[e] = <span class="built_in">append</span>(graph[e], s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 自底向上，计算所有以当前节点为根的子树节点的距离和</span></span><br><span class="line">	distSum := <span class="built_in">make</span>([]<span class="keyword">int</span>, n) 	<span class="comment">// 和</span></span><br><span class="line">	nodeNum := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)	<span class="comment">// 子树节点个数，含自己</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		nodeNum[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> postOrder <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">	postOrder = <span class="function"><span class="keyword">func</span><span class="params">(root, parent <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, conn := <span class="keyword">range</span> edges[root] &#123;</span><br><span class="line">			<span class="keyword">if</span> conn == parent &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			postOrder(conn, root)</span><br><span class="line">			nodeNum[root] += nodeNum[conn]</span><br><span class="line">			distSum[root] += distSum[conn] + nodeNum[conn]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 从顶向下，计算子树之外的部分</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 递推公式要好好理解，这里是不求甚解抄上去的</span></span><br><span class="line">	<span class="keyword">var</span> preOrder <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">	preOrder = <span class="function"><span class="keyword">func</span><span class="params">(root, parent <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, conn := <span class="keyword">range</span> edges[root] &#123;</span><br><span class="line">			<span class="keyword">if</span> conn == parent &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			distSum[conn] = distSum[root] + n - <span class="number">2</span> * nodeNum[conn]</span><br><span class="line">			preOrder(conn, root)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4. 求解</span></span><br><span class="line">	postOrder(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">	preOrder(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> distSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>Author：</strong>John Doe<br>
        <strong>Link：</strong><a href="http://example.com/Notes/LeetCodeQSet/Leetcode%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB%E9%9B%86.html" title="http:&#x2F;&#x2F;example.com&#x2F;Notes&#x2F;LeetCodeQSet&#x2F;Leetcode%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB%E9%9B%86.html" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;Notes&#x2F;LeetCodeQSet&#x2F;Leetcode%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB%E9%9B%86.html</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="Search" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1630854088417"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
