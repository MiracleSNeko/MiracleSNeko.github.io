{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"6aa9f49f3fa36399b3a780b77c9f8a8c8daf1f71","modified":1633612307865},{"_id":"source/CNAME","hash":"eb50f30edd16cc1b5d5c5155dde0c3a3b6975e33","modified":1633611947829},{"_id":"source/_posts/Ar-Blog-rre-MSNeko.md","hash":"bbd993321de5dacc6d002bc410d2c4759d919163","modified":1633611947829},{"_id":"source/_posts/biweekly-contest-61.md","hash":"9108aa3066f3d0b21d955e9ca49f285ab6618245","modified":1633611947830},{"_id":"source/_posts/biweekly-contest-62.md","hash":"335ac1e4acb68275638cbf340f32cab8654058c1","modified":1633611947830},{"_id":"source/_posts/weekly-contest-258.md","hash":"252de277770cd9d8b20ef0b9ab20a8b3b7d57520","modified":1633611947830},{"_id":"source/_posts/weekly-contest-259.md","hash":"0ec65b6f9f99fcfd793addd77924acc77718fcc3","modified":1633611947830},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1633612458646},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":1633612459491},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":1633612459486},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"63d1a594969b7b5b97e1babebc7b85ef07c02e4f","modified":1633612460926},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"58f9c520976198df8f0941d30ca400988ee4cc2b","modified":1633612459433},{"_id":"node_modules/hexo-theme-butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1633612460947},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1633612460931},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1633612460933},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1633612460948},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1633612460951},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1633612459678},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1633612459776},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1633612460203},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1633612460289},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1633612460344},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1633612460401},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1633612459474},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1633612459462},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1633612459481},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1633612460943},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1633612459550},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":1633612459518},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1633612459884},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":1633612459914},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1633612460220},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1633612460293},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1633612460381},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":1633612460386},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1633612459074},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":1633612459221},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1633612459427},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":1633612459328},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1633612459140},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1633612459336},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1633612459144},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":1633612459226},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1633612459310},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"54b9324e3506dcc9c9991ef5e11e37e66e21594f","modified":1633612459344},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":1633612459187},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1633612459198},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1633612459211},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1633612459231},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1633612459238},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1633612459299},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1633612459305},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1633612459372},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1633612460837},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":1633612460914},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1633612459295},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1633612459408},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1633612459419},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1633612459017},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1633612459499},{"_id":"node_modules/hexo-theme-butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1633612460916},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1633612458988},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1633612460285},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1633612459639},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1633612459802},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":1633612459794},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1633612459906},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1633612460271},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1633612460353},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1633612460371},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1633612460388},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1633612459997},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1633612460255},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1633612460261},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1633612460332},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1633612460389},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1633612460236},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1633612460240},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1633612459686},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":1633612460337},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1633612459773},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1633612459816},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":1633612459882},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1633612460405},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1633612460329},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":1633612460377},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1633612459660},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1633612459868},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":1633612460304},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1633612460297},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1633612460363},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1633612460394},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1633612459709},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1633612459700},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1633612459714},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":1633612459725},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1633612459738},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1633612459735},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":1633612459742},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1633612459745},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1633612459750},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1633612459760},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1633612459765},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1633612459767},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":1633612460199},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1633612460760},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"e211efbd1952d4b1b881287aa43423133c1d166e","modified":1633612460817},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":1633612460800},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1633612460909},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1633612460537},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":1633612460519},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1633612460538},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1633612460735},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"98235fcda3b87ad6f7e91eafbed94d0d6ae847ca","modified":1633612460768},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1633612460855},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1633612460866},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1633612460888},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":1633612460870},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1633612460891},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1633612460897},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":1633612460900},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":1633612460913},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":1633612460561},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":1633612460881},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":1633612460479},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1633612460535},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1633612460504},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"97fec1e814f88237862f4d800a35362b802f6625","modified":1633612460540},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":1633612460731},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1633612460806},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1633612460906},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":1633612460502},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":1633612460826},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":1633612460859},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1633612460762},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":1633612460529},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1633612460782},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1633612460784},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1633612460840},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":1633612460849},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1633612460864},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1633612460905},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1633612458792},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1633612459118},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1633612459253},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1633612459845},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1633612459878},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1633612460001},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1633612460414},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1633612460428},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1633612460437},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1633612459785},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1633612459808},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1633612459811},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1633612459902},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1633612460407},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1633612460009},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1633612459856},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"2e52c64e89f16267596a8465841dd46f51820982","modified":1633612459864},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":1633612459875},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":1633612459890},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1633612460021},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1633612460206},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1633612460226},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1633612460419},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1633612460424},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":1633612460430},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"36f3c603d2a2ecddaa6d2675a89d76ad94968f72","modified":1633612460448},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1633612460045},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1633612460214},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1633612460252},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1633612460257},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":1633612459835},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":1633612459896},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1633612460048},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1633612460412},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1633612460433},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":1633612460453},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1633612459616},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1633612460192},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1633612460246},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1633612459547},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1633612459559},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1633612460194},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1633612460385},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1633612460597},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1633612460819},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1633612460722},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1633612460823},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1633612460851},{"_id":"public/2021/09/05/Ar-Blog-rre-MSNeko/index.html","hash":"b2c46cbbe6cd1b54c0becd959ffa232ef4d6d264","modified":1633796209480},{"_id":"public/archives/2021/10/index.html","hash":"6e25ebf15c26138980599ada02a94c4446d56d33","modified":1633796209480},{"_id":"public/2021/10/06/biweekly-contest-62/index.html","hash":"5efbb53c1fc4176a5fb4d7a063300df9b82713d7","modified":1633796209480},{"_id":"public/2021/09/19/biweekly-contest-61/index.html","hash":"b17d0e46408529d66c13b8954cd150fbe29e0edb","modified":1633796209480},{"_id":"public/2021/09/19/weekly-contest-259/index.html","hash":"6d3823c4acbc4e21c12d85037616dd0fa10b7cbc","modified":1633796209480},{"_id":"public/2021/09/12/weekly-contest-258/index.html","hash":"1d8aef7a6907e127f843b3ffb7a4c69948dcf7bd","modified":1633796209480},{"_id":"public/archives/index.html","hash":"075d199f63c835ac799bcf1dbb602d14fd7727d2","modified":1633796209480},{"_id":"public/archives/2021/index.html","hash":"cfcd30cb824f602ab7906762c5ce931047fb3ecf","modified":1633796209480},{"_id":"public/archives/2021/09/index.html","hash":"631de35c6976fbe502542ece7ee2cf20647865cc","modified":1633796209480},{"_id":"public/index.html","hash":"519275d5280ffaf8b6002b5f515d86fe14561e49","modified":1633796209480},{"_id":"public/tags/LeetCode-周赛总结/index.html","hash":"bb7e0d17ecc587cbfc3cc9e65c1d2d98e1e60eda","modified":1633796209480},{"_id":"public/CNAME","hash":"eb50f30edd16cc1b5d5c5155dde0c3a3b6975e33","modified":1633612477148},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1633612477148},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1633612477148},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1633612477148},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1633612477148},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1633612477148},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1633612477148},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1633612477148},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1633612477148},{"_id":"public/css/index.css","hash":"4e5d9ead0952d31f549bbc22765a615a4540f58b","modified":1633612477148},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1633612477148},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1633612477148},{"_id":"source/_posts/Luogu-Template.md","hash":"e82ec7b39c1e2a48ed3187ab7dbc7b7fbbbf1e71","modified":1633796095371},{"_id":"public/2021/10/10/Luogu-Template/index.html","hash":"2238d38b5bc5ad8ccf696118080de6e4c93739da","modified":1633796209480},{"_id":"public/tags/模板/index.html","hash":"51f5869b953bd2c0853eb40dee1a156842d1142d","modified":1633796209480}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Ar Blog rre MSNeko","date":"2021-09-05T14:04:30.000Z","_content":"\n# 你以为会有介绍，其实并不会有\n\n有空再做 blog 的美化\n","source":"_posts/Ar-Blog-rre-MSNeko.md","raw":"---\ntitle: Ar Blog rre MSNeko\ndate: 2021-09-05 22:04:30\ntags: #主页介绍 \n---\n\n# 你以为会有介绍，其实并不会有\n\n有空再做 blog 的美化\n","slug":"Ar-Blog-rre-MSNeko","published":1,"updated":"2021-10-07T13:05:47.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckugyov230000kbgd7jp7d4s8","content":"<h1 id=\"你以为会有介绍，其实并不会有\"><a href=\"#你以为会有介绍，其实并不会有\" class=\"headerlink\" title=\"你以为会有介绍，其实并不会有\"></a>你以为会有介绍，其实并不会有</h1><p>有空再做 blog 的美化</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"你以为会有介绍，其实并不会有\"><a href=\"#你以为会有介绍，其实并不会有\" class=\"headerlink\" title=\"你以为会有介绍，其实并不会有\"></a>你以为会有介绍，其实并不会有</h1><p>有空再做 blog 的美化</p>\n"},{"title":"LeetCode 双周赛 61","date":"2021-09-19T06:56:09.000Z","_content":"\n---\n\n# LeetCode 双周赛 61\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/maximum-earnings-from-taxi/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1103 / 2534 | MiracleSNeko | 7    | 1:33:40  | 0:02:08                                                      | 0:48:40 9                                                    |                                                              |                                                              |\n\n## T1 2006. 差的绝对值为 K 的数对数目\n\n-   **通过的用户数**1773\n-   **尝试过的用户数**1793\n-   **用户总通过次数**1806\n-   **用户总提交次数**1985\n-   **题目难度** **Easy**\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你返回数对 `(i, j)` 的数目，满足 `i < j` 且 `|nums[i] - nums[j]| == k` 。\n\n`|x|` 的值定义为：\n\n-   如果 `x >= 0` ，那么值为 `x` 。\n-   如果 `x < 0` ，那么值为 `-x` 。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,2,1], k = 1\n输出：4\n解释：差的绝对值为 1 的数对为：\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,3], k = 3\n输出：0\n解释：没有任何数对差的绝对值为 3 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1,5,4], k = 2\n输出：3\n解释：差的绝对值为 2 的数对为：\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 200`\n-   `1 <= nums[i] <= 100`\n-   `1 <= k <= 99`\n\n>   T1 的数据量暴力就完事了\n\n**我的提交：**\n\n```c++\nclass Solution\n{\npublic:\n    int countKDifference(std::vector<int> &nums, int k)\n    {\n        auto len = nums.size();\n        auto ans = 0;\n        for (auto i = 0; i < len; ++i)\n        {\n            auto vi = nums[i];\n            for (auto j = i; j < len; ++j)\n            {\n                auto vj = nums[j];\n                if (abs(vi - vj) == k) ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T2 2007. 从双倍数组中还原原数组\n\n-   **通过的用户数**1149\n-   **尝试过的用户数**1598\n-   **用户总通过次数**1187\n-   **用户总提交次数**5278\n-   **题目难度** **Medium**\n\n一个整数数组 `original` 可以转变成一个 **双倍** 数组 `changed` ，转变方式为将 `original` 中每个元素 **值乘以 2** 加入数组中，然后将所有元素 **随机打乱** 。\n\n给你一个数组 `changed` ，如果 `change` 是 **双倍** 数组，那么请你返回 `original`数组，否则请返回空数组。`original` 的元素可以以 **任意** 顺序返回。\n\n**示例 1：**\n\n```\n输入：changed = [1,3,4,2,6,8]\n输出：[1,3,4]\n解释：一个可能的 original 数组为 [1,3,4] :\n- 将 1 乘以 2 ，得到 1 * 2 = 2 。\n- 将 3 乘以 2 ，得到 3 * 2 = 6 。\n- 将 4 乘以 2 ，得到 4 * 2 = 8 。\n其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。\n```\n\n**示例 2：**\n\n```\n输入：changed = [6,3,0,1]\n输出：[]\n解释：changed 不是一个双倍数组。\n```\n\n**示例 3：**\n\n```\n输入：changed = [1]\n输出：[]\n解释：changed 不是一个双倍数组。\n```\n\n**提示：**\n\n-   `1 <= changed.length <= 105`\n-   `0 <= changed[i] <= 105`\n\n**我的提交：**\n\n>   写的时候用数组折腾来折腾去 WA 的死去活来 （9次啊9次），后来发现不如 `std::map` 减减乐\n\n```c++\n// 这个破代码还可以改很多地方\n// 但是如果是用 Rust 写怕不是就炸了，一个 map 在做迭代器的时候还要被改\nclass Solution\n{\npublic:\n    Veci findOriginalArray(Veci &changed)\n    {\n        Veci ans;\n        std::sort(ALL(changed));\n        auto st = UpperBS(changed, 0);\n        if ((st & 1) != 0)\n            return Veci();\n        for (auto i = 0; i < st; i += 2)\n        {\n            ans.push_back(0);\n        }\n        changed = Veci(changed.begin() + st, changed.end());\n        auto len = changed.size();\n        if ((len & 1) != 0)\n            return Veci();\n        Veci odd;\n        std::map<i32, i32> even;\n        for (auto &val : changed)\n        {\n            if ((val & 1) == 0)\n            {\n                if (even.count(val) == 0)\n                {\n                    even[val] = 1;\n                }\n                else\n                {\n                    even[val] += 1;\n                }\n            }\n            else\n            {\n                odd.push_back(val);\n            }\n        }\n        for (auto ii : odd)\n        {\n            if (even.count(2 * ii) == 0 || even[2 * ii] == 0)\n                return Veci();\n            ans.push_back(ii);\n            even[2 * ii] -= 1;\n        }\n        for(auto [k, v]: even)\n        {\n            if (v == 0) continue;\n            if (even.count(2 * k) == 0) return Veci();\n            while(v--)\n            {\n                ans.push_back(k);\n                even[2 * k] -= 1;\n                if (even[2 * k] < 0) return Veci();\n            }\n        }\n        return ans;\n    }\n};\n```\n\n**题解：**\n\n小的值优先匹配小的，所以先用sort进行排序\n然后可以将暂时没匹配到的数字存放至队列中，使用队列也是为了优先匹配小的，小的先进，小的先出。\n每次等到匹配到的时候，就将队列中的数取出。最后判断队列是否为空。\n\n```c++\nclass Solution {\npublic:\n    vector<int> findOriginalArray(vector<int>& changed) {\n        sort(changed.begin(),changed.end());\n        queue<int> q;\n        vector<int> res,empty;\n        int n = changed.size();\n        if(n%2)return empty;\n        for(int i=0;i<n;i++){\n            if(q.empty())\n                q.push(changed[i]);\n            else{\n                if(q.front()*2 == changed[i]){\n                    res.push_back(q.front());\n                    q.pop();\n                }\n                else\n                    q.push(changed[i]);\n            }\n        }\n        if(!q.empty())\n            return empty;\n        return res;\n    }\n};\n\n作者：zhu-146\n链接：https://leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/pai-xu-dui-lie-by-zhu-146-a5bo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T3 2008. 出租车的最大盈利\n\n-   **通过的用户数**519\n-   **尝试过的用户数**832\n-   **用户总通过次数**543\n-   **用户总提交次数**1850\n-   **题目难度** **Medium**\n\n你驾驶出租车行驶在一条有 `n` 个地点的路上。这 `n` 个地点从近到远编号为 `1` 到 `n` ，你想要从 `1` 开到 `n` ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。\n\n乘客信息用一个下标从 **0** 开始的二维数组 `rides` 表示，其中 `rides[i] = [starti, endi, tipi]` 表示第 `i` 位乘客需要从地点 `starti` 前往 `endi` ，愿意支付 `tipi` 元的小费。\n\n**每一位** 你选择接单的乘客 `i` ，你可以 **盈利** `endi - starti + tipi` 元。你同时 **最多** 只能接一个订单。\n\n给你 `n` 和 `rides` ，请你返回在最优接单方案下，你能盈利 **最多** 多少元。\n\n**注意：**你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。\n\n**示例 1：**\n\n```\n输入：n = 5, rides = [[2,5,4],[1,5,1]]\n输出：7\n解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。\n```\n\n**示例 2：**\n\n```\n输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]\n输出：20\n解释：我们可以接以下乘客的订单：\n- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。\n- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。\n- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。\n我们总共获得 9 + 5 + 6 = 20 元。\n```\n\n**提示：**\n\n-   `1 <= n <= 105`\n-   `1 <= rides.length <= 3 * 104`\n-   `rides[i].length == 3`\n-   `1 <= start_i < end_i <= n`\n-   `1 <= tip_i <= 105`\n\n>   我也不知道我是怎么把这么明显的 DP 看成图的，可能是 T2 WA 麻了\n\n**题解：**\n\n定义 f[i] 表示行驶到 i 时的最大盈利。考虑状态转移，一方面，我们可以不接终点为 i 的乘客，这样有 f[i]=f[i-1]；另一方面，我们可以接所有终点为 i 的乘客中收益最大的，这样有 f[i] = \\max (f[start]+end-start+tip)  ，二者取最大值。\n\n最终答案为 f[n]。\n\n```c++\nclass Solution\n{\npublic:\n    i64 maxTaxiEarnings(i32 n, VecVec<i32> &rides)\n    {\n        auto dp = Vecl(n+1, 0);\n        auto prof = VecVec<std::tuple<i64, i64>>(n+1);\n        // 记录每个 end 对应的 start 和 tip\n        for(auto&& r: rides)\n        {\n            auto start = r[0], end = r[1], tip = r[2];\n            prof[end].push_back(TUPLE(start, tip));\n        }\n        FORINC(ed, 1, n+1)\n        {\n            dp[ed] = dp[ed - 1];\n            for(auto&& [st, tip]: prof[ed])\n            {\n                dp[ed] = std::max(dp[ed], dp[st] + ed - st + tip);\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n## T4 2009. 使数组连续的最少操作数\n\n-   **通过的用户数**353\n-   **尝试过的用户数**545\n-   **用户总通过次数**386\n-   **用户总提交次数**1243\n-   **题目难度** **Hard**\n\n给你一个整数数组 `nums` 。每一次操作中，你可以将 `nums` 中 **任意** 一个元素替换成 **任意** 整数。\n\n如果 `nums` 满足以下条件，那么它是 **连续的** ：\n\n-   `nums` 中所有元素都是 **互不相同** 的。\n-   `nums` 中 **最大** 元素与 **最小** 元素的差等于 `nums.length - 1` 。\n\n比方说，`nums = [4, 2, 5, 3]` 是 **连续的** ，但是 `nums = [1, 2, 3, 5, 6]` **不是连续的** 。\n\n请你返回使 `nums` **连续** 的 **最少** 操作次数。\n\n**示例 1：**\n\n```\n输入：nums = [4,2,5,3]\n输出：0\n解释：nums 已经是连续的了。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,5,6]\n输出：1\n解释：一个可能的解是将最后一个元素变为 4 。\n结果数组为 [1,2,3,5,4] ，是连续数组。\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,10,100,1000]\n输出：3\n解释：一个可能的解是：\n- 将第二个元素变为 2 。\n- 将第三个元素变为 3 。\n- 将第四个元素变为 4 。\n结果数组为 [1,2,3,4] ，是连续数组。\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 105`\n-   `1 <= nums[i] <= 109`\n\n","source":"_posts/biweekly-contest-61.md","raw":"---\ntitle: LeetCode 双周赛 61\ndate: 2021-09-19 14:56:09\ntags: LeetCode 周赛总结\n---\n\n---\n\n# LeetCode 双周赛 61\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/maximum-earnings-from-taxi/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1103 / 2534 | MiracleSNeko | 7    | 1:33:40  | 0:02:08                                                      | 0:48:40 9                                                    |                                                              |                                                              |\n\n## T1 2006. 差的绝对值为 K 的数对数目\n\n-   **通过的用户数**1773\n-   **尝试过的用户数**1793\n-   **用户总通过次数**1806\n-   **用户总提交次数**1985\n-   **题目难度** **Easy**\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你返回数对 `(i, j)` 的数目，满足 `i < j` 且 `|nums[i] - nums[j]| == k` 。\n\n`|x|` 的值定义为：\n\n-   如果 `x >= 0` ，那么值为 `x` 。\n-   如果 `x < 0` ，那么值为 `-x` 。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,2,1], k = 1\n输出：4\n解释：差的绝对值为 1 的数对为：\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,3], k = 3\n输出：0\n解释：没有任何数对差的绝对值为 3 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1,5,4], k = 2\n输出：3\n解释：差的绝对值为 2 的数对为：\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 200`\n-   `1 <= nums[i] <= 100`\n-   `1 <= k <= 99`\n\n>   T1 的数据量暴力就完事了\n\n**我的提交：**\n\n```c++\nclass Solution\n{\npublic:\n    int countKDifference(std::vector<int> &nums, int k)\n    {\n        auto len = nums.size();\n        auto ans = 0;\n        for (auto i = 0; i < len; ++i)\n        {\n            auto vi = nums[i];\n            for (auto j = i; j < len; ++j)\n            {\n                auto vj = nums[j];\n                if (abs(vi - vj) == k) ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T2 2007. 从双倍数组中还原原数组\n\n-   **通过的用户数**1149\n-   **尝试过的用户数**1598\n-   **用户总通过次数**1187\n-   **用户总提交次数**5278\n-   **题目难度** **Medium**\n\n一个整数数组 `original` 可以转变成一个 **双倍** 数组 `changed` ，转变方式为将 `original` 中每个元素 **值乘以 2** 加入数组中，然后将所有元素 **随机打乱** 。\n\n给你一个数组 `changed` ，如果 `change` 是 **双倍** 数组，那么请你返回 `original`数组，否则请返回空数组。`original` 的元素可以以 **任意** 顺序返回。\n\n**示例 1：**\n\n```\n输入：changed = [1,3,4,2,6,8]\n输出：[1,3,4]\n解释：一个可能的 original 数组为 [1,3,4] :\n- 将 1 乘以 2 ，得到 1 * 2 = 2 。\n- 将 3 乘以 2 ，得到 3 * 2 = 6 。\n- 将 4 乘以 2 ，得到 4 * 2 = 8 。\n其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。\n```\n\n**示例 2：**\n\n```\n输入：changed = [6,3,0,1]\n输出：[]\n解释：changed 不是一个双倍数组。\n```\n\n**示例 3：**\n\n```\n输入：changed = [1]\n输出：[]\n解释：changed 不是一个双倍数组。\n```\n\n**提示：**\n\n-   `1 <= changed.length <= 105`\n-   `0 <= changed[i] <= 105`\n\n**我的提交：**\n\n>   写的时候用数组折腾来折腾去 WA 的死去活来 （9次啊9次），后来发现不如 `std::map` 减减乐\n\n```c++\n// 这个破代码还可以改很多地方\n// 但是如果是用 Rust 写怕不是就炸了，一个 map 在做迭代器的时候还要被改\nclass Solution\n{\npublic:\n    Veci findOriginalArray(Veci &changed)\n    {\n        Veci ans;\n        std::sort(ALL(changed));\n        auto st = UpperBS(changed, 0);\n        if ((st & 1) != 0)\n            return Veci();\n        for (auto i = 0; i < st; i += 2)\n        {\n            ans.push_back(0);\n        }\n        changed = Veci(changed.begin() + st, changed.end());\n        auto len = changed.size();\n        if ((len & 1) != 0)\n            return Veci();\n        Veci odd;\n        std::map<i32, i32> even;\n        for (auto &val : changed)\n        {\n            if ((val & 1) == 0)\n            {\n                if (even.count(val) == 0)\n                {\n                    even[val] = 1;\n                }\n                else\n                {\n                    even[val] += 1;\n                }\n            }\n            else\n            {\n                odd.push_back(val);\n            }\n        }\n        for (auto ii : odd)\n        {\n            if (even.count(2 * ii) == 0 || even[2 * ii] == 0)\n                return Veci();\n            ans.push_back(ii);\n            even[2 * ii] -= 1;\n        }\n        for(auto [k, v]: even)\n        {\n            if (v == 0) continue;\n            if (even.count(2 * k) == 0) return Veci();\n            while(v--)\n            {\n                ans.push_back(k);\n                even[2 * k] -= 1;\n                if (even[2 * k] < 0) return Veci();\n            }\n        }\n        return ans;\n    }\n};\n```\n\n**题解：**\n\n小的值优先匹配小的，所以先用sort进行排序\n然后可以将暂时没匹配到的数字存放至队列中，使用队列也是为了优先匹配小的，小的先进，小的先出。\n每次等到匹配到的时候，就将队列中的数取出。最后判断队列是否为空。\n\n```c++\nclass Solution {\npublic:\n    vector<int> findOriginalArray(vector<int>& changed) {\n        sort(changed.begin(),changed.end());\n        queue<int> q;\n        vector<int> res,empty;\n        int n = changed.size();\n        if(n%2)return empty;\n        for(int i=0;i<n;i++){\n            if(q.empty())\n                q.push(changed[i]);\n            else{\n                if(q.front()*2 == changed[i]){\n                    res.push_back(q.front());\n                    q.pop();\n                }\n                else\n                    q.push(changed[i]);\n            }\n        }\n        if(!q.empty())\n            return empty;\n        return res;\n    }\n};\n\n作者：zhu-146\n链接：https://leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/pai-xu-dui-lie-by-zhu-146-a5bo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T3 2008. 出租车的最大盈利\n\n-   **通过的用户数**519\n-   **尝试过的用户数**832\n-   **用户总通过次数**543\n-   **用户总提交次数**1850\n-   **题目难度** **Medium**\n\n你驾驶出租车行驶在一条有 `n` 个地点的路上。这 `n` 个地点从近到远编号为 `1` 到 `n` ，你想要从 `1` 开到 `n` ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。\n\n乘客信息用一个下标从 **0** 开始的二维数组 `rides` 表示，其中 `rides[i] = [starti, endi, tipi]` 表示第 `i` 位乘客需要从地点 `starti` 前往 `endi` ，愿意支付 `tipi` 元的小费。\n\n**每一位** 你选择接单的乘客 `i` ，你可以 **盈利** `endi - starti + tipi` 元。你同时 **最多** 只能接一个订单。\n\n给你 `n` 和 `rides` ，请你返回在最优接单方案下，你能盈利 **最多** 多少元。\n\n**注意：**你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。\n\n**示例 1：**\n\n```\n输入：n = 5, rides = [[2,5,4],[1,5,1]]\n输出：7\n解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。\n```\n\n**示例 2：**\n\n```\n输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]\n输出：20\n解释：我们可以接以下乘客的订单：\n- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。\n- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。\n- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。\n我们总共获得 9 + 5 + 6 = 20 元。\n```\n\n**提示：**\n\n-   `1 <= n <= 105`\n-   `1 <= rides.length <= 3 * 104`\n-   `rides[i].length == 3`\n-   `1 <= start_i < end_i <= n`\n-   `1 <= tip_i <= 105`\n\n>   我也不知道我是怎么把这么明显的 DP 看成图的，可能是 T2 WA 麻了\n\n**题解：**\n\n定义 f[i] 表示行驶到 i 时的最大盈利。考虑状态转移，一方面，我们可以不接终点为 i 的乘客，这样有 f[i]=f[i-1]；另一方面，我们可以接所有终点为 i 的乘客中收益最大的，这样有 f[i] = \\max (f[start]+end-start+tip)  ，二者取最大值。\n\n最终答案为 f[n]。\n\n```c++\nclass Solution\n{\npublic:\n    i64 maxTaxiEarnings(i32 n, VecVec<i32> &rides)\n    {\n        auto dp = Vecl(n+1, 0);\n        auto prof = VecVec<std::tuple<i64, i64>>(n+1);\n        // 记录每个 end 对应的 start 和 tip\n        for(auto&& r: rides)\n        {\n            auto start = r[0], end = r[1], tip = r[2];\n            prof[end].push_back(TUPLE(start, tip));\n        }\n        FORINC(ed, 1, n+1)\n        {\n            dp[ed] = dp[ed - 1];\n            for(auto&& [st, tip]: prof[ed])\n            {\n                dp[ed] = std::max(dp[ed], dp[st] + ed - st + tip);\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n## T4 2009. 使数组连续的最少操作数\n\n-   **通过的用户数**353\n-   **尝试过的用户数**545\n-   **用户总通过次数**386\n-   **用户总提交次数**1243\n-   **题目难度** **Hard**\n\n给你一个整数数组 `nums` 。每一次操作中，你可以将 `nums` 中 **任意** 一个元素替换成 **任意** 整数。\n\n如果 `nums` 满足以下条件，那么它是 **连续的** ：\n\n-   `nums` 中所有元素都是 **互不相同** 的。\n-   `nums` 中 **最大** 元素与 **最小** 元素的差等于 `nums.length - 1` 。\n\n比方说，`nums = [4, 2, 5, 3]` 是 **连续的** ，但是 `nums = [1, 2, 3, 5, 6]` **不是连续的** 。\n\n请你返回使 `nums` **连续** 的 **最少** 操作次数。\n\n**示例 1：**\n\n```\n输入：nums = [4,2,5,3]\n输出：0\n解释：nums 已经是连续的了。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,5,6]\n输出：1\n解释：一个可能的解是将最后一个元素变为 4 。\n结果数组为 [1,2,3,5,4] ，是连续数组。\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,10,100,1000]\n输出：3\n解释：一个可能的解是：\n- 将第二个元素变为 2 。\n- 将第三个元素变为 3 。\n- 将第四个元素变为 4 。\n结果数组为 [1,2,3,4] ，是连续数组。\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 105`\n-   `1 <= nums[i] <= 109`\n\n","slug":"biweekly-contest-61","published":1,"updated":"2021-10-07T13:05:47.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckugyov2a0001kbgd9fsa3mok","content":"<hr>\n<h1 id=\"LeetCode-双周赛-61\"><a href=\"#LeetCode-双周赛-61\" class=\"headerlink\" title=\"LeetCode 双周赛 61\"></a>LeetCode 双周赛 61</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/maximum-earnings-from-taxi/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1103 / 2534</td>\n<td>MiracleSNeko</td>\n<td>7</td>\n<td>1:33:40</td>\n<td>0:02:08</td>\n<td>0:48:40 9</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-2006-差的绝对值为-K-的数对数目\"><a href=\"#T1-2006-差的绝对值为-K-的数对数目\" class=\"headerlink\" title=\"T1 2006. 差的绝对值为 K 的数对数目\"></a>T1 2006. 差的绝对值为 K 的数对数目</h2><ul>\n<li>  <strong>通过的用户数</strong>1773</li>\n<li>  <strong>尝试过的用户数</strong>1793</li>\n<li>  <strong>用户总通过次数</strong>1806</li>\n<li>  <strong>用户总提交次数</strong>1985</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回数对 <code>(i, j)</code> 的数目，满足 <code>i &lt; j</code> 且 <code>|nums[i] - nums[j]| == k</code> 。</p>\n<p><code>|x|</code> 的值定义为：</p>\n<ul>\n<li>  如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li>\n<li>  如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,2,1], k = 1</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：差的绝对值为 1 的数对为：</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3], k = 3</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：没有任何数对差的绝对值为 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1,5,4], k = 2</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：差的绝对值为 2 的数对为：</span><br><span class=\"line\">- [3,2,1,5,4]</span><br><span class=\"line\">- [3,2,1,5,4]</span><br><span class=\"line\">- [3,2,1,5,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 100</code></li>\n<li>  <code>1 &lt;= k &lt;= 99</code></li>\n</ul>\n<blockquote>\n<p>  T1 的数据量暴力就完事了</p>\n</blockquote>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countKDifference</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; len; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> vi = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> j = i; j &lt; len; ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> vj = nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(vi - vj) == k) ans++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-2007-从双倍数组中还原原数组\"><a href=\"#T2-2007-从双倍数组中还原原数组\" class=\"headerlink\" title=\"T2 2007. 从双倍数组中还原原数组\"></a>T2 2007. 从双倍数组中还原原数组</h2><ul>\n<li>  <strong>通过的用户数</strong>1149</li>\n<li>  <strong>尝试过的用户数</strong>1598</li>\n<li>  <strong>用户总通过次数</strong>1187</li>\n<li>  <strong>用户总提交次数</strong>5278</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>一个整数数组 <code>original</code> 可以转变成一个 <strong>双倍</strong> 数组 <code>changed</code> ，转变方式为将 <code>original</code> 中每个元素 <strong>值乘以 2</strong> 加入数组中，然后将所有元素 <strong>随机打乱</strong> 。</p>\n<p>给你一个数组 <code>changed</code> ，如果 <code>change</code> 是 <strong>双倍</strong> 数组，那么请你返回 <code>original</code>数组，否则请返回空数组。<code>original</code> 的元素可以以 <strong>任意</strong> 顺序返回。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [1,3,4,2,6,8]</span><br><span class=\"line\">输出：[1,3,4]</span><br><span class=\"line\">解释：一个可能的 original 数组为 [1,3,4] :</span><br><span class=\"line\">- 将 1 乘以 2 ，得到 1 * 2 = 2 。</span><br><span class=\"line\">- 将 3 乘以 2 ，得到 3 * 2 = 6 。</span><br><span class=\"line\">- 将 4 乘以 2 ，得到 4 * 2 = 8 。</span><br><span class=\"line\">其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [6,3,0,1]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [1]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= changed.length &lt;= 105</code></li>\n<li>  <code>0 &lt;= changed[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  写的时候用数组折腾来折腾去 WA 的死去活来 （9次啊9次），后来发现不如 <code>std::map</code> 减减乐</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个破代码还可以改很多地方</span></span><br><span class=\"line\"><span class=\"comment\">// 但是如果是用 Rust 写怕不是就炸了，一个 map 在做迭代器的时候还要被改</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Veci <span class=\"title\">findOriginalArray</span><span class=\"params\">(Veci &amp;changed)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Veci ans;</span><br><span class=\"line\">        std::<span class=\"built_in\">sort</span>(<span class=\"built_in\">ALL</span>(changed));</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> st = <span class=\"built_in\">UpperBS</span>(changed, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((st &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; st; i += <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        changed = <span class=\"built_in\">Veci</span>(changed.<span class=\"built_in\">begin</span>() + st, changed.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = changed.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((len &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">        Veci odd;</span><br><span class=\"line\">        std::map&lt;i32, i32&gt; even;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;val : changed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((val &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(val) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    even[val] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    even[val] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                odd.<span class=\"built_in\">push_back</span>(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> ii : odd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(<span class=\"number\">2</span> * ii) == <span class=\"number\">0</span> || even[<span class=\"number\">2</span> * ii] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(ii);</span><br><span class=\"line\">            even[<span class=\"number\">2</span> * ii] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> [k, v]: even)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(<span class=\"number\">2</span> * k) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(v--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(k);</span><br><span class=\"line\">                even[<span class=\"number\">2</span> * k] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (even[<span class=\"number\">2</span> * k] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<p>小的值优先匹配小的，所以先用sort进行排序<br>然后可以将暂时没匹配到的数字存放至队列中，使用队列也是为了优先匹配小的，小的先进，小的先出。<br>每次等到匹配到的时候，就将队列中的数取出。最后判断队列是否为空。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findOriginalArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; changed)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(changed.<span class=\"built_in\">begin</span>(),changed.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; res,empty;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = changed.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>)<span class=\"keyword\">return</span> empty;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(changed[i]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(q.<span class=\"built_in\">front</span>()*<span class=\"number\">2</span> == changed[i])&#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(q.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">                    q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(changed[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> empty;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：zhu<span class=\"number\">-146</span></span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/pai-xu-dui-lie-by-zhu-146-a5bo/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-2008-出租车的最大盈利\"><a href=\"#T3-2008-出租车的最大盈利\" class=\"headerlink\" title=\"T3 2008. 出租车的最大盈利\"></a>T3 2008. 出租车的最大盈利</h2><ul>\n<li>  <strong>通过的用户数</strong>519</li>\n<li>  <strong>尝试过的用户数</strong>832</li>\n<li>  <strong>用户总通过次数</strong>543</li>\n<li>  <strong>用户总提交次数</strong>1850</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>你驾驶出租车行驶在一条有 <code>n</code> 个地点的路上。这 <code>n</code> 个地点从近到远编号为 <code>1</code> 到 <code>n</code> ，你想要从 <code>1</code> 开到 <code>n</code> ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。</p>\n<p>乘客信息用一个下标从 <strong>0</strong> 开始的二维数组 <code>rides</code> 表示，其中 <code>rides[i] = [starti, endi, tipi]</code> 表示第 <code>i</code> 位乘客需要从地点 <code>starti</code> 前往 <code>endi</code> ，愿意支付 <code>tipi</code> 元的小费。</p>\n<p><strong>每一位</strong> 你选择接单的乘客 <code>i</code> ，你可以 <strong>盈利</strong> <code>endi - starti + tipi</code> 元。你同时 <strong>最多</strong> 只能接一个订单。</p>\n<p>给你 <code>n</code> 和 <code>rides</code> ，请你返回在最优接单方案下，你能盈利 <strong>最多</strong> 多少元。</p>\n<p><strong>注意：</strong>你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, rides = [[2,5,4],[1,5,1]]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]</span><br><span class=\"line\">输出：20</span><br><span class=\"line\">解释：我们可以接以下乘客的订单：</span><br><span class=\"line\">- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。</span><br><span class=\"line\">- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。</span><br><span class=\"line\">- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。</span><br><span class=\"line\">我们总共获得 9 + 5 + 6 = 20 元。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>1 &lt;= rides.length &lt;= 3 * 104</code></li>\n<li>  <code>rides[i].length == 3</code></li>\n<li>  <code>1 &lt;= start_i &lt; end_i &lt;= n</code></li>\n<li>  <code>1 &lt;= tip_i &lt;= 105</code></li>\n</ul>\n<blockquote>\n<p>  我也不知道我是怎么把这么明显的 DP 看成图的，可能是 T2 WA 麻了</p>\n</blockquote>\n<p><strong>题解：</strong></p>\n<p>定义 f[i] 表示行驶到 i 时的最大盈利。考虑状态转移，一方面，我们可以不接终点为 i 的乘客，这样有 f[i]=f[i-1]；另一方面，我们可以接所有终点为 i 的乘客中收益最大的，这样有 f[i] = \\max (f[start]+end-start+tip)  ，二者取最大值。</p>\n<p>最终答案为 f[n]。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">i64 <span class=\"title\">maxTaxiEarnings</span><span class=\"params\">(i32 n, VecVec&lt;i32&gt; &amp;rides)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> dp = <span class=\"built_in\">Vecl</span>(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> prof = VecVec&lt;std::tuple&lt;i64, i64&gt;&gt;(n+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 记录每个 end 对应的 start 和 tip</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp;&amp; r: rides)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> start = r[<span class=\"number\">0</span>], end = r[<span class=\"number\">1</span>], tip = r[<span class=\"number\">2</span>];</span><br><span class=\"line\">            prof[end].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">TUPLE</span>(start, tip));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(ed, <span class=\"number\">1</span>, n+<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[ed] = dp[ed - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp;&amp; [st, tip]: prof[ed])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dp[ed] = std::<span class=\"built_in\">max</span>(dp[ed], dp[st] + ed - st + tip);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-2009-使数组连续的最少操作数\"><a href=\"#T4-2009-使数组连续的最少操作数\" class=\"headerlink\" title=\"T4 2009. 使数组连续的最少操作数\"></a>T4 2009. 使数组连续的最少操作数</h2><ul>\n<li>  <strong>通过的用户数</strong>353</li>\n<li>  <strong>尝试过的用户数</strong>545</li>\n<li>  <strong>用户总通过次数</strong>386</li>\n<li>  <strong>用户总提交次数</strong>1243</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 <strong>任意</strong> 一个元素替换成 <strong>任意</strong> 整数。</p>\n<p>如果 <code>nums</code> 满足以下条件，那么它是 <strong>连续的</strong> ：</p>\n<ul>\n<li>  <code>nums</code> 中所有元素都是 <strong>互不相同</strong> 的。</li>\n<li>  <code>nums</code> 中 <strong>最大</strong> 元素与 <strong>最小</strong> 元素的差等于 <code>nums.length - 1</code> 。</li>\n</ul>\n<p>比方说，<code>nums = [4, 2, 5, 3]</code> 是 <strong>连续的</strong> ，但是 <code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong> 。</p>\n<p>请你返回使 <code>nums</code> <strong>连续</strong> 的 <strong>最少</strong> 操作次数。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [4,2,5,3]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：nums 已经是连续的了。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3,5,6]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：一个可能的解是将最后一个元素变为 4 。</span><br><span class=\"line\">结果数组为 [1,2,3,5,4] ，是连续数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,10,100,1000]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：一个可能的解是：</span><br><span class=\"line\">- 将第二个元素变为 2 。</span><br><span class=\"line\">- 将第三个元素变为 3 。</span><br><span class=\"line\">- 将第四个元素变为 4 。</span><br><span class=\"line\">结果数组为 [1,2,3,4] ，是连续数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-双周赛-61\"><a href=\"#LeetCode-双周赛-61\" class=\"headerlink\" title=\"LeetCode 双周赛 61\"></a>LeetCode 双周赛 61</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/maximum-earnings-from-taxi/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1103 / 2534</td>\n<td>MiracleSNeko</td>\n<td>7</td>\n<td>1:33:40</td>\n<td>0:02:08</td>\n<td>0:48:40 9</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-2006-差的绝对值为-K-的数对数目\"><a href=\"#T1-2006-差的绝对值为-K-的数对数目\" class=\"headerlink\" title=\"T1 2006. 差的绝对值为 K 的数对数目\"></a>T1 2006. 差的绝对值为 K 的数对数目</h2><ul>\n<li>  <strong>通过的用户数</strong>1773</li>\n<li>  <strong>尝试过的用户数</strong>1793</li>\n<li>  <strong>用户总通过次数</strong>1806</li>\n<li>  <strong>用户总提交次数</strong>1985</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回数对 <code>(i, j)</code> 的数目，满足 <code>i &lt; j</code> 且 <code>|nums[i] - nums[j]| == k</code> 。</p>\n<p><code>|x|</code> 的值定义为：</p>\n<ul>\n<li>  如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li>\n<li>  如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,2,1], k = 1</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：差的绝对值为 1 的数对为：</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3], k = 3</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：没有任何数对差的绝对值为 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1,5,4], k = 2</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：差的绝对值为 2 的数对为：</span><br><span class=\"line\">- [3,2,1,5,4]</span><br><span class=\"line\">- [3,2,1,5,4]</span><br><span class=\"line\">- [3,2,1,5,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 100</code></li>\n<li>  <code>1 &lt;= k &lt;= 99</code></li>\n</ul>\n<blockquote>\n<p>  T1 的数据量暴力就完事了</p>\n</blockquote>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countKDifference</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; len; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> vi = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> j = i; j &lt; len; ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> vj = nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(vi - vj) == k) ans++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-2007-从双倍数组中还原原数组\"><a href=\"#T2-2007-从双倍数组中还原原数组\" class=\"headerlink\" title=\"T2 2007. 从双倍数组中还原原数组\"></a>T2 2007. 从双倍数组中还原原数组</h2><ul>\n<li>  <strong>通过的用户数</strong>1149</li>\n<li>  <strong>尝试过的用户数</strong>1598</li>\n<li>  <strong>用户总通过次数</strong>1187</li>\n<li>  <strong>用户总提交次数</strong>5278</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>一个整数数组 <code>original</code> 可以转变成一个 <strong>双倍</strong> 数组 <code>changed</code> ，转变方式为将 <code>original</code> 中每个元素 <strong>值乘以 2</strong> 加入数组中，然后将所有元素 <strong>随机打乱</strong> 。</p>\n<p>给你一个数组 <code>changed</code> ，如果 <code>change</code> 是 <strong>双倍</strong> 数组，那么请你返回 <code>original</code>数组，否则请返回空数组。<code>original</code> 的元素可以以 <strong>任意</strong> 顺序返回。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [1,3,4,2,6,8]</span><br><span class=\"line\">输出：[1,3,4]</span><br><span class=\"line\">解释：一个可能的 original 数组为 [1,3,4] :</span><br><span class=\"line\">- 将 1 乘以 2 ，得到 1 * 2 = 2 。</span><br><span class=\"line\">- 将 3 乘以 2 ，得到 3 * 2 = 6 。</span><br><span class=\"line\">- 将 4 乘以 2 ，得到 4 * 2 = 8 。</span><br><span class=\"line\">其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [6,3,0,1]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [1]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= changed.length &lt;= 105</code></li>\n<li>  <code>0 &lt;= changed[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  写的时候用数组折腾来折腾去 WA 的死去活来 （9次啊9次），后来发现不如 <code>std::map</code> 减减乐</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个破代码还可以改很多地方</span></span><br><span class=\"line\"><span class=\"comment\">// 但是如果是用 Rust 写怕不是就炸了，一个 map 在做迭代器的时候还要被改</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Veci <span class=\"title\">findOriginalArray</span><span class=\"params\">(Veci &amp;changed)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Veci ans;</span><br><span class=\"line\">        std::<span class=\"built_in\">sort</span>(<span class=\"built_in\">ALL</span>(changed));</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> st = <span class=\"built_in\">UpperBS</span>(changed, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((st &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; st; i += <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        changed = <span class=\"built_in\">Veci</span>(changed.<span class=\"built_in\">begin</span>() + st, changed.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = changed.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((len &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">        Veci odd;</span><br><span class=\"line\">        std::map&lt;i32, i32&gt; even;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;val : changed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((val &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(val) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    even[val] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    even[val] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                odd.<span class=\"built_in\">push_back</span>(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> ii : odd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(<span class=\"number\">2</span> * ii) == <span class=\"number\">0</span> || even[<span class=\"number\">2</span> * ii] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(ii);</span><br><span class=\"line\">            even[<span class=\"number\">2</span> * ii] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> [k, v]: even)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(<span class=\"number\">2</span> * k) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(v--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(k);</span><br><span class=\"line\">                even[<span class=\"number\">2</span> * k] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (even[<span class=\"number\">2</span> * k] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<p>小的值优先匹配小的，所以先用sort进行排序<br>然后可以将暂时没匹配到的数字存放至队列中，使用队列也是为了优先匹配小的，小的先进，小的先出。<br>每次等到匹配到的时候，就将队列中的数取出。最后判断队列是否为空。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findOriginalArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; changed)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(changed.<span class=\"built_in\">begin</span>(),changed.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; res,empty;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = changed.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>)<span class=\"keyword\">return</span> empty;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(changed[i]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(q.<span class=\"built_in\">front</span>()*<span class=\"number\">2</span> == changed[i])&#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(q.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">                    q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(changed[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> empty;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：zhu<span class=\"number\">-146</span></span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/pai-xu-dui-lie-by-zhu-146-a5bo/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-2008-出租车的最大盈利\"><a href=\"#T3-2008-出租车的最大盈利\" class=\"headerlink\" title=\"T3 2008. 出租车的最大盈利\"></a>T3 2008. 出租车的最大盈利</h2><ul>\n<li>  <strong>通过的用户数</strong>519</li>\n<li>  <strong>尝试过的用户数</strong>832</li>\n<li>  <strong>用户总通过次数</strong>543</li>\n<li>  <strong>用户总提交次数</strong>1850</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>你驾驶出租车行驶在一条有 <code>n</code> 个地点的路上。这 <code>n</code> 个地点从近到远编号为 <code>1</code> 到 <code>n</code> ，你想要从 <code>1</code> 开到 <code>n</code> ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。</p>\n<p>乘客信息用一个下标从 <strong>0</strong> 开始的二维数组 <code>rides</code> 表示，其中 <code>rides[i] = [starti, endi, tipi]</code> 表示第 <code>i</code> 位乘客需要从地点 <code>starti</code> 前往 <code>endi</code> ，愿意支付 <code>tipi</code> 元的小费。</p>\n<p><strong>每一位</strong> 你选择接单的乘客 <code>i</code> ，你可以 <strong>盈利</strong> <code>endi - starti + tipi</code> 元。你同时 <strong>最多</strong> 只能接一个订单。</p>\n<p>给你 <code>n</code> 和 <code>rides</code> ，请你返回在最优接单方案下，你能盈利 <strong>最多</strong> 多少元。</p>\n<p><strong>注意：</strong>你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, rides = [[2,5,4],[1,5,1]]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]</span><br><span class=\"line\">输出：20</span><br><span class=\"line\">解释：我们可以接以下乘客的订单：</span><br><span class=\"line\">- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。</span><br><span class=\"line\">- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。</span><br><span class=\"line\">- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。</span><br><span class=\"line\">我们总共获得 9 + 5 + 6 = 20 元。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>1 &lt;= rides.length &lt;= 3 * 104</code></li>\n<li>  <code>rides[i].length == 3</code></li>\n<li>  <code>1 &lt;= start_i &lt; end_i &lt;= n</code></li>\n<li>  <code>1 &lt;= tip_i &lt;= 105</code></li>\n</ul>\n<blockquote>\n<p>  我也不知道我是怎么把这么明显的 DP 看成图的，可能是 T2 WA 麻了</p>\n</blockquote>\n<p><strong>题解：</strong></p>\n<p>定义 f[i] 表示行驶到 i 时的最大盈利。考虑状态转移，一方面，我们可以不接终点为 i 的乘客，这样有 f[i]=f[i-1]；另一方面，我们可以接所有终点为 i 的乘客中收益最大的，这样有 f[i] = \\max (f[start]+end-start+tip)  ，二者取最大值。</p>\n<p>最终答案为 f[n]。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">i64 <span class=\"title\">maxTaxiEarnings</span><span class=\"params\">(i32 n, VecVec&lt;i32&gt; &amp;rides)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> dp = <span class=\"built_in\">Vecl</span>(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> prof = VecVec&lt;std::tuple&lt;i64, i64&gt;&gt;(n+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 记录每个 end 对应的 start 和 tip</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp;&amp; r: rides)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> start = r[<span class=\"number\">0</span>], end = r[<span class=\"number\">1</span>], tip = r[<span class=\"number\">2</span>];</span><br><span class=\"line\">            prof[end].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">TUPLE</span>(start, tip));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(ed, <span class=\"number\">1</span>, n+<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[ed] = dp[ed - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp;&amp; [st, tip]: prof[ed])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dp[ed] = std::<span class=\"built_in\">max</span>(dp[ed], dp[st] + ed - st + tip);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-2009-使数组连续的最少操作数\"><a href=\"#T4-2009-使数组连续的最少操作数\" class=\"headerlink\" title=\"T4 2009. 使数组连续的最少操作数\"></a>T4 2009. 使数组连续的最少操作数</h2><ul>\n<li>  <strong>通过的用户数</strong>353</li>\n<li>  <strong>尝试过的用户数</strong>545</li>\n<li>  <strong>用户总通过次数</strong>386</li>\n<li>  <strong>用户总提交次数</strong>1243</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 <strong>任意</strong> 一个元素替换成 <strong>任意</strong> 整数。</p>\n<p>如果 <code>nums</code> 满足以下条件，那么它是 <strong>连续的</strong> ：</p>\n<ul>\n<li>  <code>nums</code> 中所有元素都是 <strong>互不相同</strong> 的。</li>\n<li>  <code>nums</code> 中 <strong>最大</strong> 元素与 <strong>最小</strong> 元素的差等于 <code>nums.length - 1</code> 。</li>\n</ul>\n<p>比方说，<code>nums = [4, 2, 5, 3]</code> 是 <strong>连续的</strong> ，但是 <code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong> 。</p>\n<p>请你返回使 <code>nums</code> <strong>连续</strong> 的 <strong>最少</strong> 操作次数。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [4,2,5,3]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：nums 已经是连续的了。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3,5,6]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：一个可能的解是将最后一个元素变为 4 。</span><br><span class=\"line\">结果数组为 [1,2,3,5,4] ，是连续数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,10,100,1000]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：一个可能的解是：</span><br><span class=\"line\">- 将第二个元素变为 2 。</span><br><span class=\"line\">- 将第三个元素变为 3 。</span><br><span class=\"line\">- 将第四个元素变为 4 。</span><br><span class=\"line\">结果数组为 [1,2,3,4] ，是连续数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n"},{"title":"LeetCode 双周赛 62","date":"2021-10-06T03:51:36.000Z","_content":"\n# LeetCode 双周赛 62\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 715 / 2619 | MiracleSNeko | 12   | 1:07:20  | 0:03:20                                                      | 0:08:27 1                                                    | 0:52:20 2                                                    |                                                              |\n\n## T1 2022. 将一维数组转变成二维数组\n\n-   **通过的用户数**1673\n-   **尝试过的用户数**1718\n-   **用户总通过次数**1706\n-   **用户总提交次数**2629\n-   **题目难度** **Easy**\n\n给你一个下标从 **0** 开始的一维整数数组 `original` 和两个整数 `m` 和 `n` 。你需要使用 `original` 中 **所有** 元素创建一个 `m` 行 `n` 列的二维数组。\n\n`original` 中下标从 `0` 到 `n - 1` （都 **包含** ）的元素构成二维数组的第一行，下标从 `n` 到 `2 * n - 1` （都 **包含** ）的元素构成二维数组的第二行，依此类推。\n\n请你根据上述过程返回一个 `m x n` 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png)\n\n```\n输入：original = [1,2,3,4], m = 2, n = 2\n输出：[[1,2],[3,4]]\n解释：\n构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n```\n\n**示例 2：**\n\n```\n输入：original = [1,2,3], m = 1, n = 3\n输出：[[1,2,3]]\n解释：\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n```\n\n**示例 3：**\n\n```\n输入：original = [1,2], m = 1, n = 1\n输出：[]\n解释：\noriginal 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n```\n\n**示例 4：**\n\n```\n输入：original = [3], m = 1, n = 2\n输出：[]\n解释：\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n```\n\n**提示：**\n\n-   `1 <= original.length <= 5 * 104`\n-   `1 <= original[i] <= 105`\n-   `1 <= m, n <= 4 * 104`\n\n**我的提交：**\n\n>   应该有 api 可以直接用，但是比赛懒得查了\n\n```rust\nimpl Solution {\n    pub fn construct2_d_array(original: Vec<i32>, m: i32, n: i32) -> Vec<Vec<i32>> {\n        if m * n != original.len() as i32 {\n            vec![]\n        } else {\n            let mut ret = Vec::with_capacity(m as usize);\n            let mut tmp = Vec::with_capacity(n as usize);\n            for i in 0..original.len() {\n                if tmp.len() == n as usize {\n                    ret.push(tmp.clone());\n                    tmp.clear();\n                }\n                tmp.push(original[i]);\n            }\n            ret.push(tmp);\n            ret\n        }\n    }\n}\n```\n\n\n\n## T2 2023. 连接后等于目标字符串的字符串对\n\n-   **通过的用户数**1623\n-   **尝试过的用户数**1654\n-   **用户总通过次数**1647\n-   **用户总提交次数**2202\n-   **题目难度** **Medium**\n\n给你一个 **数字** 字符串数组 `nums` 和一个 **数字** 字符串 `target` ，请你返回 `nums[i] + nums[j]` （两个字符串连接）结果等于 `target` 的下标 `(i, j)` （需满足 `i != j`）的数目。\n\n\n\n**示例 1：**\n\n```\n输入：nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\n输出：4\n解释：符合要求的下标对包括：\n- (0, 1)：\"777\" + \"7\"\n- (1, 0)：\"7\" + \"777\"\n- (2, 3)：\"77\" + \"77\"\n- (3, 2)：\"77\" + \"77\"\n```\n\n**示例 2：**\n\n```\n输入：nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\n输出：2\n解释：符合要求的下标对包括\n- (0, 1)：\"123\" + \"4\"\n- (2, 3)：\"12\" + \"34\"\n```\n\n**示例 3：**\n\n```\n输入：nums = [\"1\",\"1\",\"1\"], target = \"11\"\n输出：6\n解释：符合要求的下标对包括\n- (0, 1)：\"1\" + \"1\"\n- (1, 0)：\"1\" + \"1\"\n- (0, 2)：\"1\" + \"1\"\n- (2, 0)：\"1\" + \"1\"\n- (1, 2)：\"1\" + \"1\"\n- (2, 1)：\"1\" + \"1\"\n```\n\n\n\n**提示：**\n\n-   `2 <= nums.length <= 100`\n-   `1 <= nums[i].length <= 100`\n-   `2 <= target.length <= 100`\n-   `nums[i]` 和 `target` 只包含数字。\n-   `nums[i]` 和 `target` 不含有任何前导 0 。\n\n**我的提交：**\n\n>   一开始想写 dfs，看了眼数据量果断模拟。同一场周赛出现两道模拟送分题还真是少见。\n\n```rust\nimpl Solution {\n    pub fn num_of_pairs(nums: Vec<String>, target: String) -> i32 {\n        let mut cnt = 0;\n        for i in 0..nums.len() {\n            for j in 0..nums.len() {\n                if i == j  {\n                    continue;\n                }\n                let cat = nums[i].clone() + &nums[j];\n                if cat == target {\n                    cnt += 1;\n                }\n            }\n        }\n        cnt\n    }\n}\n```\n\n\n\n## T3 2024. 考试的最大困扰度\n\n-   **通过的用户数**861\n-   **尝试过的用户数**1139\n-   **用户总通过次数**889\n-   **用户总提交次数**2307\n-   **题目难度** **Medium**\n\n一位老师正在出一场由 `n` 道判断题构成的考试，每道题的答案为 true （用 `'T'` 表示）或者 false （用 `'F'` 表示）。老师想增加学生对自己做出答案的不确定性，方法是 **最大化** 有 **连续相同** 结果的题数。（也就是连续出现 true 或者连续出现 false）。\n\n给你一个字符串 `answerKey` ，其中 `answerKey[i]` 是第 `i` 个问题的正确结果。除此以外，还给你一个整数 `k` ，表示你能进行以下操作的最多次数：\n\n-   每次操作中，将问题的正确答案改为 `'T'` 或者 `'F'` （也就是将 `answerKey[i]` 改为 `'T'` 或者 `'F'` ）。\n\n请你返回在不超过 `k` 次操作的情况下，**最大** 连续 `'T'` 或者 `'F'` 的数目。\n\n \n\n**示例 1：**\n\n```\n输入：answerKey = \"TTFF\", k = 2\n输出：4\n解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = \"TTTT\" 。\n总共有四个连续的 'T' 。\n```\n\n**示例 2：**\n\n```\n输入：answerKey = \"TFFT\", k = 1\n输出：3\n解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = \"FFFT\" 。\n或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = \"TFFF\" 。\n两种情况下，都有三个连续的 'F' 。\n```\n\n**示例 3：**\n\n```\n输入：answerKey = \"TTFTTFTT\", k = 1\n输出：5\n解释：我们可以将第一个 'F' 换成 'T' ，得到 answerKey = \"TTTTTFTT\" 。\n或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = \"TTFTTTTT\" 。\n两种情况下，都有五个连续的 'T' 。\n```\n\n \n\n**提示：**\n\n-   `n == answerKey.length`\n-   `1 <= n <= 5 * 104`\n-   `answerKey[i]` 要么是 `'T'` ，要么是 `'F'`\n-   `1 <= k <= n`\n\n**我的提交：**\n\n>   参考 [LC487](https://leetcode-cn.com/problems/max-consecutive-ones-ii/) 和 [LC1004](https://leetcode-cn.com/problems/max-consecutive-ones-iii) 。该题的最佳解法为滑动窗口，周赛的时候写了一个次优的二分。\n\n```rust\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::rc::Rc;\nuse std::ops::Bound;\n\nimpl Solution {\n    pub fn max_consecutive_answers(answer_key: String, k: i32) -> i32 {\n        let mut ans = 0;\n        let len = answer_key.len();\n        let answer_key = answer_key.as_bytes();\n        let ts = answer_key\n            .iter()\n            .map(|&c| if c == b'T' { 1 } else { 0 })\n            .fold(vec![0], |mut vec, i| {\n                vec.push(vec.last().unwrap() + i);\n                vec\n            });\n        let fs = answer_key\n            .iter()\n            .map(|&c| if c == b'F' { 1 } else { 0 })\n            .fold(vec![0], |mut vec, i| {\n                vec.push(vec.last().unwrap() + i);\n                vec\n            });\n        // T 和 F 各算一遍算逑\n        fn lower_bound(val: &Vec<i32>, tar: i32) -> usize {\n            let (mut l, mut r) = (0, val.len());\n            while l < r {\n                let m = (l + r) >> 1;\n                if val[m] < tar {\n                    l = m + 1;\n                } else {\n                    r = m;\n                }\n            }\n            l\n        }\n        for r in 1..ts.len() {\n            let l = lower_bound(&ts, ts[r] - k);\n            ans = ans.max(r - l);\n        }\n        for r in 1..fs.len() {\n            let l = lower_bound(&fs, fs[r] - k);\n            ans = ans.max(r - l);\n        }\n        ans as i32\n    }\n}\n```\n\n\n\n## T4 2025. 分割数组的最多方案数\n\n-   **通过的用户数**267\n-   **尝试过的用户数**641\n-   **用户总通过次数**296\n-   **用户总提交次数**1955\n-   **题目难度** **Hard**\n\n给你一个下标从 **0** 开始且长度为 `n` 的整数数组 `nums` 。**分割** 数组 `nums` 的方案数定义为符合以下两个条件的 `pivot` 数目：\n\n-   `1 <= pivot < n`\n-   `nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]`\n\n同时给你一个整数 `k` 。你可以将 `nums` 中 **一个** 元素变为 `k` 或 **不改变** 数组。\n\n请你返回在 **至多** 改变一个元素的前提下，**最多** 有多少种方法 **分割** `nums` 使得上述两个条件都满足。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,-1,2], k = 3\n输出：1\n解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。\n有一种方法分割数组：\n- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,0], k = 1\n输出：2\n解释：一个最优的方案是不改动数组。\n有两种方法分割数组：\n- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。\n- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\n输出：4\n解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。\n有四种方法分割数组。\n```\n\n \n\n**提示：**\n\n-   `n == nums.length`\n-   `2 <= n <= 105`\n-   `-105 <= k, nums[i] <= 105`\n","source":"_posts/biweekly-contest-62.md","raw":"title: LeetCode 双周赛 62\ndate: 2021-10-06 11:51:36\ntags: LeetCode 周赛总结\n\n---\n\n# LeetCode 双周赛 62\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 715 / 2619 | MiracleSNeko | 12   | 1:07:20  | 0:03:20                                                      | 0:08:27 1                                                    | 0:52:20 2                                                    |                                                              |\n\n## T1 2022. 将一维数组转变成二维数组\n\n-   **通过的用户数**1673\n-   **尝试过的用户数**1718\n-   **用户总通过次数**1706\n-   **用户总提交次数**2629\n-   **题目难度** **Easy**\n\n给你一个下标从 **0** 开始的一维整数数组 `original` 和两个整数 `m` 和 `n` 。你需要使用 `original` 中 **所有** 元素创建一个 `m` 行 `n` 列的二维数组。\n\n`original` 中下标从 `0` 到 `n - 1` （都 **包含** ）的元素构成二维数组的第一行，下标从 `n` 到 `2 * n - 1` （都 **包含** ）的元素构成二维数组的第二行，依此类推。\n\n请你根据上述过程返回一个 `m x n` 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png)\n\n```\n输入：original = [1,2,3,4], m = 2, n = 2\n输出：[[1,2],[3,4]]\n解释：\n构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n```\n\n**示例 2：**\n\n```\n输入：original = [1,2,3], m = 1, n = 3\n输出：[[1,2,3]]\n解释：\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n```\n\n**示例 3：**\n\n```\n输入：original = [1,2], m = 1, n = 1\n输出：[]\n解释：\noriginal 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n```\n\n**示例 4：**\n\n```\n输入：original = [3], m = 1, n = 2\n输出：[]\n解释：\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n```\n\n**提示：**\n\n-   `1 <= original.length <= 5 * 104`\n-   `1 <= original[i] <= 105`\n-   `1 <= m, n <= 4 * 104`\n\n**我的提交：**\n\n>   应该有 api 可以直接用，但是比赛懒得查了\n\n```rust\nimpl Solution {\n    pub fn construct2_d_array(original: Vec<i32>, m: i32, n: i32) -> Vec<Vec<i32>> {\n        if m * n != original.len() as i32 {\n            vec![]\n        } else {\n            let mut ret = Vec::with_capacity(m as usize);\n            let mut tmp = Vec::with_capacity(n as usize);\n            for i in 0..original.len() {\n                if tmp.len() == n as usize {\n                    ret.push(tmp.clone());\n                    tmp.clear();\n                }\n                tmp.push(original[i]);\n            }\n            ret.push(tmp);\n            ret\n        }\n    }\n}\n```\n\n\n\n## T2 2023. 连接后等于目标字符串的字符串对\n\n-   **通过的用户数**1623\n-   **尝试过的用户数**1654\n-   **用户总通过次数**1647\n-   **用户总提交次数**2202\n-   **题目难度** **Medium**\n\n给你一个 **数字** 字符串数组 `nums` 和一个 **数字** 字符串 `target` ，请你返回 `nums[i] + nums[j]` （两个字符串连接）结果等于 `target` 的下标 `(i, j)` （需满足 `i != j`）的数目。\n\n\n\n**示例 1：**\n\n```\n输入：nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\n输出：4\n解释：符合要求的下标对包括：\n- (0, 1)：\"777\" + \"7\"\n- (1, 0)：\"7\" + \"777\"\n- (2, 3)：\"77\" + \"77\"\n- (3, 2)：\"77\" + \"77\"\n```\n\n**示例 2：**\n\n```\n输入：nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\n输出：2\n解释：符合要求的下标对包括\n- (0, 1)：\"123\" + \"4\"\n- (2, 3)：\"12\" + \"34\"\n```\n\n**示例 3：**\n\n```\n输入：nums = [\"1\",\"1\",\"1\"], target = \"11\"\n输出：6\n解释：符合要求的下标对包括\n- (0, 1)：\"1\" + \"1\"\n- (1, 0)：\"1\" + \"1\"\n- (0, 2)：\"1\" + \"1\"\n- (2, 0)：\"1\" + \"1\"\n- (1, 2)：\"1\" + \"1\"\n- (2, 1)：\"1\" + \"1\"\n```\n\n\n\n**提示：**\n\n-   `2 <= nums.length <= 100`\n-   `1 <= nums[i].length <= 100`\n-   `2 <= target.length <= 100`\n-   `nums[i]` 和 `target` 只包含数字。\n-   `nums[i]` 和 `target` 不含有任何前导 0 。\n\n**我的提交：**\n\n>   一开始想写 dfs，看了眼数据量果断模拟。同一场周赛出现两道模拟送分题还真是少见。\n\n```rust\nimpl Solution {\n    pub fn num_of_pairs(nums: Vec<String>, target: String) -> i32 {\n        let mut cnt = 0;\n        for i in 0..nums.len() {\n            for j in 0..nums.len() {\n                if i == j  {\n                    continue;\n                }\n                let cat = nums[i].clone() + &nums[j];\n                if cat == target {\n                    cnt += 1;\n                }\n            }\n        }\n        cnt\n    }\n}\n```\n\n\n\n## T3 2024. 考试的最大困扰度\n\n-   **通过的用户数**861\n-   **尝试过的用户数**1139\n-   **用户总通过次数**889\n-   **用户总提交次数**2307\n-   **题目难度** **Medium**\n\n一位老师正在出一场由 `n` 道判断题构成的考试，每道题的答案为 true （用 `'T'` 表示）或者 false （用 `'F'` 表示）。老师想增加学生对自己做出答案的不确定性，方法是 **最大化** 有 **连续相同** 结果的题数。（也就是连续出现 true 或者连续出现 false）。\n\n给你一个字符串 `answerKey` ，其中 `answerKey[i]` 是第 `i` 个问题的正确结果。除此以外，还给你一个整数 `k` ，表示你能进行以下操作的最多次数：\n\n-   每次操作中，将问题的正确答案改为 `'T'` 或者 `'F'` （也就是将 `answerKey[i]` 改为 `'T'` 或者 `'F'` ）。\n\n请你返回在不超过 `k` 次操作的情况下，**最大** 连续 `'T'` 或者 `'F'` 的数目。\n\n \n\n**示例 1：**\n\n```\n输入：answerKey = \"TTFF\", k = 2\n输出：4\n解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = \"TTTT\" 。\n总共有四个连续的 'T' 。\n```\n\n**示例 2：**\n\n```\n输入：answerKey = \"TFFT\", k = 1\n输出：3\n解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = \"FFFT\" 。\n或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = \"TFFF\" 。\n两种情况下，都有三个连续的 'F' 。\n```\n\n**示例 3：**\n\n```\n输入：answerKey = \"TTFTTFTT\", k = 1\n输出：5\n解释：我们可以将第一个 'F' 换成 'T' ，得到 answerKey = \"TTTTTFTT\" 。\n或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = \"TTFTTTTT\" 。\n两种情况下，都有五个连续的 'T' 。\n```\n\n \n\n**提示：**\n\n-   `n == answerKey.length`\n-   `1 <= n <= 5 * 104`\n-   `answerKey[i]` 要么是 `'T'` ，要么是 `'F'`\n-   `1 <= k <= n`\n\n**我的提交：**\n\n>   参考 [LC487](https://leetcode-cn.com/problems/max-consecutive-ones-ii/) 和 [LC1004](https://leetcode-cn.com/problems/max-consecutive-ones-iii) 。该题的最佳解法为滑动窗口，周赛的时候写了一个次优的二分。\n\n```rust\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::rc::Rc;\nuse std::ops::Bound;\n\nimpl Solution {\n    pub fn max_consecutive_answers(answer_key: String, k: i32) -> i32 {\n        let mut ans = 0;\n        let len = answer_key.len();\n        let answer_key = answer_key.as_bytes();\n        let ts = answer_key\n            .iter()\n            .map(|&c| if c == b'T' { 1 } else { 0 })\n            .fold(vec![0], |mut vec, i| {\n                vec.push(vec.last().unwrap() + i);\n                vec\n            });\n        let fs = answer_key\n            .iter()\n            .map(|&c| if c == b'F' { 1 } else { 0 })\n            .fold(vec![0], |mut vec, i| {\n                vec.push(vec.last().unwrap() + i);\n                vec\n            });\n        // T 和 F 各算一遍算逑\n        fn lower_bound(val: &Vec<i32>, tar: i32) -> usize {\n            let (mut l, mut r) = (0, val.len());\n            while l < r {\n                let m = (l + r) >> 1;\n                if val[m] < tar {\n                    l = m + 1;\n                } else {\n                    r = m;\n                }\n            }\n            l\n        }\n        for r in 1..ts.len() {\n            let l = lower_bound(&ts, ts[r] - k);\n            ans = ans.max(r - l);\n        }\n        for r in 1..fs.len() {\n            let l = lower_bound(&fs, fs[r] - k);\n            ans = ans.max(r - l);\n        }\n        ans as i32\n    }\n}\n```\n\n\n\n## T4 2025. 分割数组的最多方案数\n\n-   **通过的用户数**267\n-   **尝试过的用户数**641\n-   **用户总通过次数**296\n-   **用户总提交次数**1955\n-   **题目难度** **Hard**\n\n给你一个下标从 **0** 开始且长度为 `n` 的整数数组 `nums` 。**分割** 数组 `nums` 的方案数定义为符合以下两个条件的 `pivot` 数目：\n\n-   `1 <= pivot < n`\n-   `nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]`\n\n同时给你一个整数 `k` 。你可以将 `nums` 中 **一个** 元素变为 `k` 或 **不改变** 数组。\n\n请你返回在 **至多** 改变一个元素的前提下，**最多** 有多少种方法 **分割** `nums` 使得上述两个条件都满足。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,-1,2], k = 3\n输出：1\n解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。\n有一种方法分割数组：\n- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,0], k = 1\n输出：2\n解释：一个最优的方案是不改动数组。\n有两种方法分割数组：\n- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。\n- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\n输出：4\n解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。\n有四种方法分割数组。\n```\n\n \n\n**提示：**\n\n-   `n == nums.length`\n-   `2 <= n <= 105`\n-   `-105 <= k, nums[i] <= 105`\n","slug":"biweekly-contest-62","published":1,"updated":"2021-10-07T13:05:47.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckugyov2e0002kbgd7oq2hb4c","content":"<h1 id=\"LeetCode-双周赛-62\"><a href=\"#LeetCode-双周赛-62\" class=\"headerlink\" title=\"LeetCode 双周赛 62\"></a>LeetCode 双周赛 62</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>715 / 2619</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:07:20</td>\n<td>0:03:20</td>\n<td>0:08:27 1</td>\n<td>0:52:20 2</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-2022-将一维数组转变成二维数组\"><a href=\"#T1-2022-将一维数组转变成二维数组\" class=\"headerlink\" title=\"T1 2022. 将一维数组转变成二维数组\"></a>T1 2022. 将一维数组转变成二维数组</h2><ul>\n<li>  <strong>通过的用户数</strong>1673</li>\n<li>  <strong>尝试过的用户数</strong>1718</li>\n<li>  <strong>用户总通过次数</strong>1706</li>\n<li>  <strong>用户总提交次数</strong>2629</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的一维整数数组 <code>original</code> 和两个整数 <code>m</code> 和 <code>n</code> 。你需要使用 <code>original</code> 中 <strong>所有</strong> 元素创建一个 <code>m</code> 行 <code>n</code> 列的二维数组。</p>\n<p><code>original</code> 中下标从 <code>0</code> 到 <code>n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code> 到 <code>2 * n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第二行，依此类推。</p>\n<p>请你根据上述过程返回一个 <code>m x n</code> 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2,3,4], m = 2, n = 2</span><br><span class=\"line\">输出：[[1,2],[3,4]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">构造出的二维数组应该包含 2 行 2 列。</span><br><span class=\"line\">original 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。</span><br><span class=\"line\">original 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2,3], m = 1, n = 3</span><br><span class=\"line\">输出：[[1,2,3]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">构造出的二维数组应该包含 1 行 3 列。</span><br><span class=\"line\">将 original 中所有三个元素放入第一行中，构成要求的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2], m = 1, n = 1</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">original 中有 2 个元素。</span><br><span class=\"line\">无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [3], m = 1, n = 2</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">original 中只有 1 个元素。</span><br><span class=\"line\">无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= original.length &lt;= 5 * 104</code></li>\n<li>  <code>1 &lt;= original[i] &lt;= 105</code></li>\n<li>  <code>1 &lt;= m, n &lt;= 4 * 104</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  应该有 api 可以直接用，但是比赛懒得查了</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">construct2_d_array</span></span>(original: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, m: <span class=\"built_in\">i32</span>, n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m * n != original.len() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vec!</span>[]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ret = <span class=\"built_in\">Vec</span>::with_capacity(m <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> tmp = <span class=\"built_in\">Vec</span>::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..original.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> tmp.len() == n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">                    ret.push(tmp.clone());</span><br><span class=\"line\">                    tmp.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tmp.push(original[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret.push(tmp);</span><br><span class=\"line\">            ret</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-2023-连接后等于目标字符串的字符串对\"><a href=\"#T2-2023-连接后等于目标字符串的字符串对\" class=\"headerlink\" title=\"T2 2023. 连接后等于目标字符串的字符串对\"></a>T2 2023. 连接后等于目标字符串的字符串对</h2><ul>\n<li>  <strong>通过的用户数</strong>1623</li>\n<li>  <strong>尝试过的用户数</strong>1654</li>\n<li>  <strong>用户总通过次数</strong>1647</li>\n<li>  <strong>用户总提交次数</strong>2202</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个 <strong>数字</strong> 字符串数组 <code>nums</code> 和一个 <strong>数字</strong> 字符串 <code>target</code> ，请你返回 <code>nums[i] + nums[j]</code> （两个字符串连接）结果等于 <code>target</code> 的下标 <code>(i, j)</code> （需满足 <code>i != j</code>）的数目。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;777&quot;,&quot;7&quot;,&quot;77&quot;,&quot;77&quot;], target = &quot;7777&quot;</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：符合要求的下标对包括：</span><br><span class=\"line\">- (0, 1)：&quot;777&quot; + &quot;7&quot;</span><br><span class=\"line\">- (1, 0)：&quot;7&quot; + &quot;777&quot;</span><br><span class=\"line\">- (2, 3)：&quot;77&quot; + &quot;77&quot;</span><br><span class=\"line\">- (3, 2)：&quot;77&quot; + &quot;77&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;123&quot;,&quot;4&quot;,&quot;12&quot;,&quot;34&quot;], target = &quot;1234&quot;</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：符合要求的下标对包括</span><br><span class=\"line\">- (0, 1)：&quot;123&quot; + &quot;4&quot;</span><br><span class=\"line\">- (2, 3)：&quot;12&quot; + &quot;34&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], target = &quot;11&quot;</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：符合要求的下标对包括</span><br><span class=\"line\">- (0, 1)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (1, 0)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (0, 2)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (2, 0)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (1, 2)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (2, 1)：&quot;1&quot; + &quot;1&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= nums.length &lt;= 100</code></li>\n<li>  <code>1 &lt;= nums[i].length &lt;= 100</code></li>\n<li>  <code>2 &lt;= target.length &lt;= 100</code></li>\n<li>  <code>nums[i]</code> 和 <code>target</code> 只包含数字。</li>\n<li>  <code>nums[i]</code> 和 <code>target</code> 不含有任何前导 0 。</li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  一开始想写 dfs，看了眼数据量果断模拟。同一场周赛出现两道模拟送分题还真是少见。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">num_of_pairs</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">String</span>&gt;, target: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..nums.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..nums.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == j  &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> cat = nums[i].clone() + &amp;nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cat == target &#123;</span><br><span class=\"line\">                    cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-2024-考试的最大困扰度\"><a href=\"#T3-2024-考试的最大困扰度\" class=\"headerlink\" title=\"T3 2024. 考试的最大困扰度\"></a>T3 2024. 考试的最大困扰度</h2><ul>\n<li>  <strong>通过的用户数</strong>861</li>\n<li>  <strong>尝试过的用户数</strong>1139</li>\n<li>  <strong>用户总通过次数</strong>889</li>\n<li>  <strong>用户总提交次数</strong>2307</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>一位老师正在出一场由 <code>n</code> 道判断题构成的考试，每道题的答案为 true （用 <code>&#39;T&#39;</code> 表示）或者 false （用 <code>&#39;F&#39;</code> 表示）。老师想增加学生对自己做出答案的不确定性，方法是 <strong>最大化</strong> 有 <strong>连续相同</strong> 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p>\n<p>给你一个字符串 <code>answerKey</code> ，其中 <code>answerKey[i]</code> 是第 <code>i</code> 个问题的正确结果。除此以外，还给你一个整数 <code>k</code> ，表示你能进行以下操作的最多次数：</p>\n<ul>\n<li>  每次操作中，将问题的正确答案改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> （也就是将 <code>answerKey[i]</code> 改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> ）。</li>\n</ul>\n<p>请你返回在不超过 <code>k</code> 次操作的情况下，<strong>最大</strong> 连续 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> 的数目。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TTFF&quot;, k = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：我们可以将两个 &#x27;F&#x27; 都变为 &#x27;T&#x27; ，得到 answerKey = &quot;TTTT&quot; 。</span><br><span class=\"line\">总共有四个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TFFT&quot;, k = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：我们可以将最前面的 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey = &quot;FFFT&quot; 。</span><br><span class=\"line\">或者，我们可以将第二个 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey = &quot;TFFF&quot; 。</span><br><span class=\"line\">两种情况下，都有三个连续的 &#x27;F&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TTFTTFTT&quot;, k = 1</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：我们可以将第一个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey = &quot;TTTTTFTT&quot; 。</span><br><span class=\"line\">或者我们可以将第二个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey = &quot;TTFTTTTT&quot; 。</span><br><span class=\"line\">两种情况下，都有五个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == answerKey.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 5 * 104</code></li>\n<li>  <code>answerKey[i]</code> 要么是 <code>&#39;T&#39;</code> ，要么是 <code>&#39;F&#39;</code></li>\n<li>  <code>1 &lt;= k &lt;= n</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  参考 <a href=\"https://leetcode-cn.com/problems/max-consecutive-ones-ii/\">LC487</a> 和 <a href=\"https://leetcode-cn.com/problems/max-consecutive-ones-iii\">LC1004</a> 。该题的最佳解法为滑动窗口，周赛的时候写了一个次优的二分。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::ops::Bound;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">max_consecutive_answers</span></span>(answer_key: <span class=\"built_in\">String</span>, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = answer_key.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> answer_key = answer_key.as_bytes();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ts = answer_key</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .map(|&amp;c| <span class=\"keyword\">if</span> c == <span class=\"string\">b&#x27;T&#x27;</span> &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">            .fold(<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>], |<span class=\"keyword\">mut</span> vec, i| &#123;</span><br><span class=\"line\">                vec.push(vec.last().unwrap() + i);</span><br><span class=\"line\">                vec</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fs = answer_key</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .map(|&amp;c| <span class=\"keyword\">if</span> c == <span class=\"string\">b&#x27;F&#x27;</span> &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">            .fold(<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>], |<span class=\"keyword\">mut</span> vec, i| &#123;</span><br><span class=\"line\">                vec.push(vec.last().unwrap() + i);</span><br><span class=\"line\">                vec</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// T 和 F 各算一遍算逑</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">lower_bound</span></span>(val: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, tar: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> l, <span class=\"keyword\">mut</span> r) = (<span class=\"number\">0</span>, val.len());</span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val[m] &lt; tar &#123;</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    r = m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"number\">1</span>..ts.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = lower_bound(&amp;ts, ts[r] - k);</span><br><span class=\"line\">            ans = ans.max(r - l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"number\">1</span>..fs.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = lower_bound(&amp;fs, fs[r] - k);</span><br><span class=\"line\">            ans = ans.max(r - l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-2025-分割数组的最多方案数\"><a href=\"#T4-2025-分割数组的最多方案数\" class=\"headerlink\" title=\"T4 2025. 分割数组的最多方案数\"></a>T4 2025. 分割数组的最多方案数</h2><ul>\n<li>  <strong>通过的用户数</strong>267</li>\n<li>  <strong>尝试过的用户数</strong>641</li>\n<li>  <strong>用户总通过次数</strong>296</li>\n<li>  <strong>用户总提交次数</strong>1955</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums</code> 。<strong>分割</strong> 数组 <code>nums</code> 的方案数定义为符合以下两个条件的 <code>pivot</code> 数目：</p>\n<ul>\n<li>  <code>1 &lt;= pivot &lt; n</code></li>\n<li>  <code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>\n</ul>\n<p>同时给你一个整数 <code>k</code> 。你可以将 <code>nums</code> 中 <strong>一个</strong> 元素变为 <code>k</code> 或 <strong>不改变</strong> 数组。</p>\n<p>请你返回在 <strong>至多</strong> 改变一个元素的前提下，<strong>最多</strong> 有多少种方法 <strong>分割</strong> <code>nums</code> 使得上述两个条件都满足。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,2], k = 3</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。</span><br><span class=\"line\">有一种方法分割数组：</span><br><span class=\"line\">- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0,0], k = 1</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：一个最优的方案是不改动数组。</span><br><span class=\"line\">有两种方法分割数组：</span><br><span class=\"line\">- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。</span><br><span class=\"line\">- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。</span><br><span class=\"line\">有四种方法分割数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == nums.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  <code>-105 &lt;= k, nums[i] &lt;= 105</code></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"LeetCode-双周赛-62\"><a href=\"#LeetCode-双周赛-62\" class=\"headerlink\" title=\"LeetCode 双周赛 62\"></a>LeetCode 双周赛 62</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>715 / 2619</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:07:20</td>\n<td>0:03:20</td>\n<td>0:08:27 1</td>\n<td>0:52:20 2</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-2022-将一维数组转变成二维数组\"><a href=\"#T1-2022-将一维数组转变成二维数组\" class=\"headerlink\" title=\"T1 2022. 将一维数组转变成二维数组\"></a>T1 2022. 将一维数组转变成二维数组</h2><ul>\n<li>  <strong>通过的用户数</strong>1673</li>\n<li>  <strong>尝试过的用户数</strong>1718</li>\n<li>  <strong>用户总通过次数</strong>1706</li>\n<li>  <strong>用户总提交次数</strong>2629</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的一维整数数组 <code>original</code> 和两个整数 <code>m</code> 和 <code>n</code> 。你需要使用 <code>original</code> 中 <strong>所有</strong> 元素创建一个 <code>m</code> 行 <code>n</code> 列的二维数组。</p>\n<p><code>original</code> 中下标从 <code>0</code> 到 <code>n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code> 到 <code>2 * n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第二行，依此类推。</p>\n<p>请你根据上述过程返回一个 <code>m x n</code> 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2,3,4], m = 2, n = 2</span><br><span class=\"line\">输出：[[1,2],[3,4]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">构造出的二维数组应该包含 2 行 2 列。</span><br><span class=\"line\">original 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。</span><br><span class=\"line\">original 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2,3], m = 1, n = 3</span><br><span class=\"line\">输出：[[1,2,3]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">构造出的二维数组应该包含 1 行 3 列。</span><br><span class=\"line\">将 original 中所有三个元素放入第一行中，构成要求的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2], m = 1, n = 1</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">original 中有 2 个元素。</span><br><span class=\"line\">无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [3], m = 1, n = 2</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">original 中只有 1 个元素。</span><br><span class=\"line\">无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= original.length &lt;= 5 * 104</code></li>\n<li>  <code>1 &lt;= original[i] &lt;= 105</code></li>\n<li>  <code>1 &lt;= m, n &lt;= 4 * 104</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  应该有 api 可以直接用，但是比赛懒得查了</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">construct2_d_array</span></span>(original: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, m: <span class=\"built_in\">i32</span>, n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m * n != original.len() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vec!</span>[]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ret = <span class=\"built_in\">Vec</span>::with_capacity(m <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> tmp = <span class=\"built_in\">Vec</span>::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..original.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> tmp.len() == n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">                    ret.push(tmp.clone());</span><br><span class=\"line\">                    tmp.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tmp.push(original[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret.push(tmp);</span><br><span class=\"line\">            ret</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-2023-连接后等于目标字符串的字符串对\"><a href=\"#T2-2023-连接后等于目标字符串的字符串对\" class=\"headerlink\" title=\"T2 2023. 连接后等于目标字符串的字符串对\"></a>T2 2023. 连接后等于目标字符串的字符串对</h2><ul>\n<li>  <strong>通过的用户数</strong>1623</li>\n<li>  <strong>尝试过的用户数</strong>1654</li>\n<li>  <strong>用户总通过次数</strong>1647</li>\n<li>  <strong>用户总提交次数</strong>2202</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个 <strong>数字</strong> 字符串数组 <code>nums</code> 和一个 <strong>数字</strong> 字符串 <code>target</code> ，请你返回 <code>nums[i] + nums[j]</code> （两个字符串连接）结果等于 <code>target</code> 的下标 <code>(i, j)</code> （需满足 <code>i != j</code>）的数目。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;777&quot;,&quot;7&quot;,&quot;77&quot;,&quot;77&quot;], target = &quot;7777&quot;</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：符合要求的下标对包括：</span><br><span class=\"line\">- (0, 1)：&quot;777&quot; + &quot;7&quot;</span><br><span class=\"line\">- (1, 0)：&quot;7&quot; + &quot;777&quot;</span><br><span class=\"line\">- (2, 3)：&quot;77&quot; + &quot;77&quot;</span><br><span class=\"line\">- (3, 2)：&quot;77&quot; + &quot;77&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;123&quot;,&quot;4&quot;,&quot;12&quot;,&quot;34&quot;], target = &quot;1234&quot;</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：符合要求的下标对包括</span><br><span class=\"line\">- (0, 1)：&quot;123&quot; + &quot;4&quot;</span><br><span class=\"line\">- (2, 3)：&quot;12&quot; + &quot;34&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], target = &quot;11&quot;</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：符合要求的下标对包括</span><br><span class=\"line\">- (0, 1)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (1, 0)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (0, 2)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (2, 0)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (1, 2)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (2, 1)：&quot;1&quot; + &quot;1&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= nums.length &lt;= 100</code></li>\n<li>  <code>1 &lt;= nums[i].length &lt;= 100</code></li>\n<li>  <code>2 &lt;= target.length &lt;= 100</code></li>\n<li>  <code>nums[i]</code> 和 <code>target</code> 只包含数字。</li>\n<li>  <code>nums[i]</code> 和 <code>target</code> 不含有任何前导 0 。</li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  一开始想写 dfs，看了眼数据量果断模拟。同一场周赛出现两道模拟送分题还真是少见。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">num_of_pairs</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">String</span>&gt;, target: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..nums.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..nums.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == j  &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> cat = nums[i].clone() + &amp;nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cat == target &#123;</span><br><span class=\"line\">                    cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-2024-考试的最大困扰度\"><a href=\"#T3-2024-考试的最大困扰度\" class=\"headerlink\" title=\"T3 2024. 考试的最大困扰度\"></a>T3 2024. 考试的最大困扰度</h2><ul>\n<li>  <strong>通过的用户数</strong>861</li>\n<li>  <strong>尝试过的用户数</strong>1139</li>\n<li>  <strong>用户总通过次数</strong>889</li>\n<li>  <strong>用户总提交次数</strong>2307</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>一位老师正在出一场由 <code>n</code> 道判断题构成的考试，每道题的答案为 true （用 <code>&#39;T&#39;</code> 表示）或者 false （用 <code>&#39;F&#39;</code> 表示）。老师想增加学生对自己做出答案的不确定性，方法是 <strong>最大化</strong> 有 <strong>连续相同</strong> 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p>\n<p>给你一个字符串 <code>answerKey</code> ，其中 <code>answerKey[i]</code> 是第 <code>i</code> 个问题的正确结果。除此以外，还给你一个整数 <code>k</code> ，表示你能进行以下操作的最多次数：</p>\n<ul>\n<li>  每次操作中，将问题的正确答案改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> （也就是将 <code>answerKey[i]</code> 改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> ）。</li>\n</ul>\n<p>请你返回在不超过 <code>k</code> 次操作的情况下，<strong>最大</strong> 连续 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> 的数目。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TTFF&quot;, k = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：我们可以将两个 &#x27;F&#x27; 都变为 &#x27;T&#x27; ，得到 answerKey = &quot;TTTT&quot; 。</span><br><span class=\"line\">总共有四个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TFFT&quot;, k = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：我们可以将最前面的 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey = &quot;FFFT&quot; 。</span><br><span class=\"line\">或者，我们可以将第二个 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey = &quot;TFFF&quot; 。</span><br><span class=\"line\">两种情况下，都有三个连续的 &#x27;F&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TTFTTFTT&quot;, k = 1</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：我们可以将第一个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey = &quot;TTTTTFTT&quot; 。</span><br><span class=\"line\">或者我们可以将第二个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey = &quot;TTFTTTTT&quot; 。</span><br><span class=\"line\">两种情况下，都有五个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == answerKey.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 5 * 104</code></li>\n<li>  <code>answerKey[i]</code> 要么是 <code>&#39;T&#39;</code> ，要么是 <code>&#39;F&#39;</code></li>\n<li>  <code>1 &lt;= k &lt;= n</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  参考 <a href=\"https://leetcode-cn.com/problems/max-consecutive-ones-ii/\">LC487</a> 和 <a href=\"https://leetcode-cn.com/problems/max-consecutive-ones-iii\">LC1004</a> 。该题的最佳解法为滑动窗口，周赛的时候写了一个次优的二分。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::ops::Bound;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">max_consecutive_answers</span></span>(answer_key: <span class=\"built_in\">String</span>, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = answer_key.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> answer_key = answer_key.as_bytes();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ts = answer_key</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .map(|&amp;c| <span class=\"keyword\">if</span> c == <span class=\"string\">b&#x27;T&#x27;</span> &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">            .fold(<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>], |<span class=\"keyword\">mut</span> vec, i| &#123;</span><br><span class=\"line\">                vec.push(vec.last().unwrap() + i);</span><br><span class=\"line\">                vec</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fs = answer_key</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .map(|&amp;c| <span class=\"keyword\">if</span> c == <span class=\"string\">b&#x27;F&#x27;</span> &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">            .fold(<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>], |<span class=\"keyword\">mut</span> vec, i| &#123;</span><br><span class=\"line\">                vec.push(vec.last().unwrap() + i);</span><br><span class=\"line\">                vec</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// T 和 F 各算一遍算逑</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">lower_bound</span></span>(val: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, tar: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> l, <span class=\"keyword\">mut</span> r) = (<span class=\"number\">0</span>, val.len());</span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val[m] &lt; tar &#123;</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    r = m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"number\">1</span>..ts.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = lower_bound(&amp;ts, ts[r] - k);</span><br><span class=\"line\">            ans = ans.max(r - l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"number\">1</span>..fs.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = lower_bound(&amp;fs, fs[r] - k);</span><br><span class=\"line\">            ans = ans.max(r - l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-2025-分割数组的最多方案数\"><a href=\"#T4-2025-分割数组的最多方案数\" class=\"headerlink\" title=\"T4 2025. 分割数组的最多方案数\"></a>T4 2025. 分割数组的最多方案数</h2><ul>\n<li>  <strong>通过的用户数</strong>267</li>\n<li>  <strong>尝试过的用户数</strong>641</li>\n<li>  <strong>用户总通过次数</strong>296</li>\n<li>  <strong>用户总提交次数</strong>1955</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums</code> 。<strong>分割</strong> 数组 <code>nums</code> 的方案数定义为符合以下两个条件的 <code>pivot</code> 数目：</p>\n<ul>\n<li>  <code>1 &lt;= pivot &lt; n</code></li>\n<li>  <code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>\n</ul>\n<p>同时给你一个整数 <code>k</code> 。你可以将 <code>nums</code> 中 <strong>一个</strong> 元素变为 <code>k</code> 或 <strong>不改变</strong> 数组。</p>\n<p>请你返回在 <strong>至多</strong> 改变一个元素的前提下，<strong>最多</strong> 有多少种方法 <strong>分割</strong> <code>nums</code> 使得上述两个条件都满足。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,2], k = 3</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。</span><br><span class=\"line\">有一种方法分割数组：</span><br><span class=\"line\">- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0,0], k = 1</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：一个最优的方案是不改动数组。</span><br><span class=\"line\">有两种方法分割数组：</span><br><span class=\"line\">- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。</span><br><span class=\"line\">- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。</span><br><span class=\"line\">有四种方法分割数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == nums.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  <code>-105 &lt;= k, nums[i] &lt;= 105</code></li>\n</ul>\n"},{"title":"LeetCode 周赛 258","date":"2021-09-12T08:51:09.000Z","_content":"\n---\n\n# LeetCode 周赛 258\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-258/problems/reverse-prefix-of-word/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-258/problems/number-of-pairs-of-interchangeable-rectangles/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-258/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-258/problems/smallest-missing-genetic-value-in-each-subtree/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 738 / 4518 | MiracleSNeko | 12   | 1:09:58  | 0:20:57                                                      | 0:33:48 1                                                    | 0:59:58 1                                                    |                                                              |\n\n## T1 5867. 反转单词前缀\n\n-   **通过的用户数**3464\n-   **尝试过的用户数**3498\n-   **用户总通过次数**3507\n-   **用户总提交次数**4264\n-   **题目难度** **Easy**\n\n给你一个下标从 **0** 开始的字符串 `word` 和一个字符 `ch` 。找出 `ch` 第一次出现的下标 `i` ，**反转** `word` 中从下标 `0` 开始、直到下标 `i` 结束（含下标 `i` ）的那段字符。如果 `word` 中不存在字符 `ch` ，则无需进行任何操作。\n\n-   例如，如果 `word = \"abcdefd\"` 且 `ch = \"d\"` ，那么你应该 **反转** 从下标 0 开始、直到下标 `3` 结束（含下标 `3` ）。结果字符串将会是 `\"***dcba***efd\"` 。\n\n返回 **结果字符串** 。\n\n**示例 1：**\n\n```\n输入：word = \"abcdefd\", ch = \"d\"\n输出：\"dcbaefd\"\n解释：\"d\" 第一次出现在下标 3 。 \n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"dcbaefd\" 。\n```\n\n**示例 2：**\n\n```\n输入：word = \"xyxzxe\", ch = \"z\"\n输出：\"zxyxxe\"\n解释：\"z\" 第一次也是唯一一次出现是在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"zxyxxe\" 。\n```\n\n**示例 3：**\n\n```\n输入：word = \"abcd\", ch = \"z\"\n输出：\"abcd\"\n解释：\"z\" 不存在于 word 中。\n无需执行反转操作，结果字符串是 \"abcd\" 。\n```\n\n**提示：**\n\n-   `1 <= word.length <= 250`\n-   `word` 由小写英文字母组成\n-   `ch` 是一个小写英文字母\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n    std::string reversePrefix(std::string word, char ch)\n    {\n        CHEATING_HEAD;\n        auto pos = word.find(ch);\n        if (pos != str::npos)\n        {\n            str prv = str(word.begin(), word.begin() + pos + 1);\n            str pst = str(word.begin() + pos + 1, word.end());\n            prv = str(prv.rbegin(), prv.rend());\n            return prv + pst;\n        }\n        return word;\n    }\n};\n```\n\n\n\n## T2 5868. 可互换矩形的组数\n\n-   **通过的用户数**2656\n-   **尝试过的用户数**3291\n-   **用户总通过次数**2705\n-   **用户总提交次数**9238\n-   **题目难度** **Medium**\n\n用一个下标从 **0** 开始的二维整数数组 `rectangles` 来表示 `n` 个矩形，其中 `rectangles[i] = [widthi, heighti]` 表示第 `i` 个矩形的宽度和高度。\n\n如果两个矩形 `i` 和 `j`（`i < j`）的宽高比相同，则认为这两个矩形 **可互换** 。更规范的说法是，两个矩形满足 `widthi/heighti == widthj/heightj`（使用实数除法而非整数除法），则认为这两个矩形 **可互换** 。\n\n计算并返回 `rectangles` 中有多少对 **可互换** 矩形。\n\n**示例 1：**\n\n```\n输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]\n输出：6\n解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：\n- 矩形 0 和矩形 1 ：4/8 == 3/6\n- 矩形 0 和矩形 2 ：4/8 == 10/20\n- 矩形 0 和矩形 3 ：4/8 == 15/30\n- 矩形 1 和矩形 2 ：3/6 == 10/20\n- 矩形 1 和矩形 3 ：3/6 == 15/30\n- 矩形 2 和矩形 3 ：10/20 == 15/30\n```\n\n**示例 2：**\n\n```\n输入：rectangles = [[4,5],[7,8]]\n输出：0\n解释：不存在成对的可互换矩形。\n```\n\n**提示：**\n\n-   `n == rectangles.length`\n-   `1 <= n <= 105`\n-   `rectangles[i].length == 2`\n-   `1 <= widthi, heighti <= 105`\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n/*     static constexpr auto Fracs = []()\n    {\n        std::array<i64, 21> fracs({1});\n        for (i64 i = 1; i <= 20; ++i)\n        {\n            fracs[i] = fracs[i - 1] * i;\n        }\n        return fracs;\n    }(); */\n\n    i64 interchangeableRectangles(std::vector<std::vector<int>> &rectangles)\n    {\n        // 找比例相等个数，求组合数 nC2\n        Vecd fracs;\n        for (auto &rect : rectangles)\n        {\n            fracs.emplace_back(static_cast<f64>(rect[0]) / static_cast<f64>(rect[1]));\n        }\n        HashMap<f64, i32> mp;\n        for (auto &f : fracs)\n        {\n            if (mp.count(f) == 0)\n            {\n                mp[f] = 1;\n            }\n            else\n            {\n                mp[f] += 1;\n            }\n        }\n        i64 ans = 0;\n        for (auto &kv : mp)\n        {\n            i64 cnt = kv.second;\n            if (cnt > 1)\n            {\n                ans += cnt * (cnt - 1) / 2;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n>   注：此处用 `double` 类型不涉及加减运算，只涉及判等，所以 `double` 作为 `key` 不会导致精度问题。\n\n-   WA 的原因： 把 $C(n, 2) = n(n - 1) / 2$ 写成了 $n!(n-1)!/2$\n\n\n\n## L3 5869. 两个回文子序列长度的最大乘积\n\n-   **通过的用户数**971\n-   **尝试过的用户数**1189\n-   **用户总通过次数**1017\n-   **用户总提交次数**2093\n-   **题目难度** **Medium**\n\n给你一个字符串 `s` ，请你找到 `s` 中两个 **不相交回文子序列** ，使得它们长度的 **乘积最大** 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 **不相交** 的。\n\n请你返回两个回文子序列长度可以达到的 **最大乘积** 。\n\n**子序列** 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 **回文字符串** 。\n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png)\n\n```\n输入：s = \"leetcodecom\"\n输出：9\n解释：最优方案是选择 \"ete\" 作为第一个子序列，\"cdc\" 作为第二个子序列。\n它们的乘积为 3 * 3 = 9 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"bb\"\n输出：1\n解释：最优方案为选择 \"b\" （第一个字符）作为第一个子序列，\"b\" （第二个字符）作为第二个子序列。\n它们的乘积为 1 * 1 = 1 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"accbcaxxcxx\"\n输出：25\n解释：最优方案为选择 \"accca\" 作为第一个子序列，\"xxcxx\" 作为第二个子序列。\n它们的乘积为 5 * 5 = 25 。\n```\n\n**提示：**\n\n-   `2 <= s.length <= 12`\n-   `s` 只含有小写英文字母。\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n    i32 countOnes(i32 x)\n    {\n        x = ((x >> 1) & 0x55555555) + (x & 0x55555555);\n        x = ((x >> 2) & 0x33333333) + (x & 0x33333333);\n        x = ((x >> 4) & 0x0f0f0f0f) + (x & 0x0f0f0f0f);\n        x = ((x >> 8) & 0x00ff00ff) + (x & 0x00ff00ff);\n        x = ((x >> 16) & 0x0000ffff) + (x & 0x0000ffff);\n        return x;\n    }\n\n    int maxProduct(str s)\n    {\n        auto check = [&s](i32 status) -> bool\n        {\n            Veci pos1({});\n            for (i32 i = 0; i < 13; ++i)\n            {\n                if (status & (1 << i))\n                    pos1.push_back(i);\n            }\n            if (pos1.size() == 1)\n                return true;\n            i32 i = 0, j = pos1.size() - 1;\n            while (i <= j)\n            {\n                if (s[pos1[i]] != s[pos1[j]])\n                    return false;\n                ++i, --j;\n            }\n            return true;\n        };\n        // 预处理所有回文子串\n        i32 sts = 1 << s.size();\n        Veci checked;\n        for (i32 st = 1; st < sts; ++st)\n        {\n            if (check(st))\n                checked.push_back(st);\n        }\n        // 遍历所有回文字串求结果\n        i32 ans = -Inf;\n        i32 clen = checked.size();\n        for (i32 i = 0; i < clen; ++i)\n        {\n            i32 sti = checked[i];\n            for (i32 j = i + 1; j < clen; ++j)\n            {\n                i32 stj = checked[j];\n                if ((sti & stj) == 0) // 无重复\n                {\n                    ans = std::max(ans, countOnes(sti) * countOnes(stj));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n>   注：本质是暴力遍历\n\n-   TLE 的原因：一开始直接暴力二重循环，没预处理回文字符串，遍历了大量的垃圾状态\n\n**其他思路**\n\ndfs 两个子序列。对于位置 i ，两个子序列可以选择用或者不用。\n\n```c++\nclass Solution {\npublic:\n    int ans = 0;\n    int maxProduct(string s) {\n        string s1, s2;\n        dfs(s, s1, s2, 0);\n        return ans;\n    }\n    \n    void dfs(string &s, string s1, string s2, int index) {\n        if(check(s1) && check(s2)) ans = max(ans, int(s1.size() * s2.size()));\n        if(index == s.size()) return;\n        dfs(s, s1 + s[index], s2, index + 1);//子序列s1使用该字符\n        dfs(s, s1, s2 + s[index], index + 1);//子序列s2使用该字符\n        dfs(s, s1, s2, index + 1);//子序列都不使用该字符\n    }\n    \n    bool check(string &s) {\n        int l = 0, r = s.size() - 1;\n        while(l < r) {\n            if(s[l++] != s[r--]) return false;\n        }\n        return true;\n    }\n};\n\n作者：ytmartian\n链接：https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/dfsliang-ge-zi-xu-lie-by-ytmartian-svyn/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T4 5870. 每棵子树内缺失的最小基因值\n\n-   **通过的用户数**175\n-   **尝试过的用户数**539\n-   **用户总通过次数**213\n-   **用户总提交次数**1154\n-   **题目难度** **Hard**\n\n有一棵根节点为 `0` 的 **家族树** ，总共包含 `n` 个节点，节点编号为 `0` 到 `n - 1` 。给你一个下标从 **0** 开始的整数数组 `parents` ，其中 `parents[i]` 是节点 `i` 的父节点。由于节点 `0` 是 **根** ，所以 `parents[0] == -1` 。\n\n总共有 `105` 个基因值，每个基因值都用 **闭区间** `[1, 105]` 中的一个整数表示。给你一个下标从 **0** 开始的整数数组 `nums` ，其中 `nums[i]` 是节点 `i` 的基因值，且基因值 **互不相同** 。\n\n请你返回一个数组 `ans` ，长度为 `n` ，其中 `ans[i]` 是以节点 `i` 为根的子树内 **缺失** 的 **最小** 基因值。\n\n节点 `x` 为根的 **子树** 包含节点 `x` 和它所有的 **后代** 节点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/23/case-1.png)\n\n```\n输入：parents = [-1,0,0,2], nums = [1,2,3,4]\n输出：[5,1,1,1]\n解释：每个子树答案计算结果如下：\n- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。\n- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。\n- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。\n- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/23/case-2.png)\n\n```\n输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]\n输出：[7,1,1,4,2,1]\n解释：每个子树答案计算结果如下：\n- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。\n- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。\n- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。\n- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。\n- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。\n- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。\n```\n\n**示例 3：**\n\n```\n输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]\n输出：[1,1,1,1,1,1,1]\n解释：所有子树都缺失基因值 1 。\n```\n\n**提示：**\n\n-   `n == parents.length == nums.length`\n-   `2 <= n <= 105`\n-   对于 `i != 0` ，满足 `0 <= parents[i] <= n - 1`\n-   `parents[0] == -1`\n-   `parents` 表示一棵合法的树。\n-   `1 <= nums[i] <= 105`\n-   `nums[i]` 互不相同。\n\n**解法笔记**\n\n**解法一：启发式合并**\n遍历整棵树，统计每棵子树包含的基因值集合以及缺失的最小基因值，记作 $\\textit{mex}$。合并基因值集合时，总是从小的往大的合并（类似并查集的按秩合并），同时更新当前子树的 $\\textit{mex}$ 的最大值。合并完成后再不断自增子树的 $\\textit{mex}$ 直至其不在基因值集合中。\n\n这一方法同时也适用于有相同基因值的情况。\n\n时间复杂度：$O(n\\log n)$。证明。\n\n```go\nfunc smallestMissingValueSubtree(parents []int, nums []int) []int {\n\tn := len(parents)\n\tg := make([][]int, n)\n\tfor w := 1; w < n; w++ {\n\t\tv := parents[w]\n\t\tg[v] = append(g[v], w)\n\t}\n\tmex := make([]int, n)\n\tvar f func(int) map[int]bool\n\tf = func(v int) map[int]bool {\n\t\tset := map[int]bool{}\n\t\tmex[v] = 1\n\t\tfor _, w := range g[v] {\n\t\t\ts := f(w)\n\t\t\t// 保证总是从小集合合并到大集合上\n\t\t\tif len(s) > len(set) {\n\t\t\t\tset, s = s, set\n\t\t\t}\n\t\t\tfor x := range s {\n\t\t\t\tset[x] = true\n\t\t\t}\n\t\t\tif mex[w] > mex[v] {\n\t\t\t\tmex[v] = mex[w]\n\t\t\t}\n\t\t}\n\t\tset[nums[v]] = true\n\t\tfor set[mex[v]] {\n\t\t\tmex[v]++ // 不断自增 mex 直至其不在基因值集合中\n\t\t}\n\t\treturn set\n\t}\n\tf(0)\n\treturn mex\n}\n\n作者：endlesscheng\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n**解法二：利用无重复基因值的性质**\n由于没有重复基因值，若存在节点 $x$，其基因值等于 $1$，则从 $x$ 到根的这一条链上的所有节点的 $\\textit{mex}$ 均超过 $1$，而其余节点的 $\\textit{mex}$ 值均为 $1$。我们顺着 $x$ 往根上走，同时收集当前子树的基因值到集合中，然后更新当前子树的 $\\textit{mex}$ 值。\n\n时间复杂度：$O(n)$。\n\n```go\nfunc smallestMissingValueSubtree(parents []int, nums []int) []int {\n\tn := len(parents)\n\tg := make([][]int, n)\n\tfor w := 1; w < n; w++ {\n\t\tv := parents[w]\n\t\tg[v] = append(g[v], w)\n\t}\n\n\tmex := make([]int, n)\n\tfor i := range mex {\n\t\tmex[i] = 1\n\t}\n\t\n\tset := map[int]bool{}\n\tvis := make([]bool, n)\n\tvar f func(int)\n\tf = func(v int) {\n\t\tset[nums[v]] = true // 收集基因值到 set 中\n\t\tfor _, w := range g[v] {\n\t\t\tif !vis[w] {\n\t\t\t\tf(w)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 找基因值等于 1 的节点 x\n\tx := -1\n\tfor i, v := range nums {\n\t\tif v == 1 {\n\t\t\tx = i\n\t\t\tbreak\n\t\t}\n\t}\n\t// x 顺着父节点往上走\n\tfor cur := 2; x >= 0; x = parents[x] {\n\t\tf(x)\n\t\tvis[x] = true // 这是保证时间复杂度的关键：之后遍历父节点子树时，就无需再次遍历 x 子树了\n\t\tfor set[cur] {\n\t\t\tcur++ // 不断自增直至不在基因值集合中\n\t\t}\n\t\tmex[x] = cur\n\t}\n\treturn mex\n}\n\n作者：endlesscheng\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n**不一样的思路：主席树+dfs序（突破值互不相同的限制）**\n\n-   看到很多题解是从基因值互不相同的条件入手写的，后来突然发现我的解法不需要考虑这个\n-   可能我的思路比较繁琐，时间复杂度有没有O(n)的优秀，固在此也只是想提供一个与众不同的思路罢了（勿喷）\n-   前置知识：主席树，dfs序\n-   注意到，这题的本质就是求mex，但不同的是，其不是真正的mex，最小的数是1，mex最小的数是0，但不影响做这题。\n-   将问题转化一下，求一个区间的mex，可以线段树、主席树，这里使用主席树做方便\n-   主席树找mex的思路\n    -   利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了\n    -   最终查询 `[L, R]` 区间的mex时，则是在版本 `R` 的权值线段树中找下标小于 `L` 的最小的数即可\n-   再来就是怎么将区间转化成树上查询，显然可以用到dfs序了\n\n```c++\nconst int N = 1e5 + 5;\nstruct pii {\n    int x, y;\n};\npii p[N];\n\nint head[N], cnt, tim;\n\n//初始化\nvoid init(int n) { fill_n(head, n + 5, -1); cnt = -1; tim = 0; }\n\nstruct edges {\n    int to, next;\n    void add(int t, int n) {\n        to = t, next = n;\n    }\n}edge[N << 1]; //无向图则需要乘2\n\ninline void add(int u, int v) {\n    edge[++cnt].add(v, head[u]);\n    head[u] = cnt;\n}\n\nint a[N], ram, root[N], vis[N];\nvoid dfs(int u, vector<int>& num) {\n    p[u].x = ++tim;\n    a[tim] = num[u]; // 重置数组\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        dfs(edge[i].to, num);\n    }\n    p[u].y = tim;\n}\n\n\nstruct nodes {int l, r, minv; } hjt[N * 25];\n\nint modify(int pre, int l, int r, int val, int pos) {\n    int now = ++ram;\n    hjt[now] = hjt[pre];\n    if (l == r) {\n        hjt[now].minv = pos;\n        return now;\n    }\n    int mid = (l + r) >> 1;\n    if (val <= mid) hjt[now].l = modify(hjt[now].l, l, mid, val, pos);\n    else hjt[now].r = modify(hjt[now].r, mid + 1, r, val, pos);\n    hjt[now].minv = min(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv);\n    return now;\n}\n\nint query(int tr, int l, int r, int ql) {\n    if (l == r) return l;\n    int mid = (l + r) >> 1;\n    if (hjt[hjt[tr].l].minv < ql) return query(hjt[tr].l, l, mid, ql);\n    return query(hjt[tr].r, mid + 1, r, ql);\n}\n\n\nclass Solution {\npublic:\n    vector<int> smallestMissingValueSubtree(vector<int>& pa, vector<int>& nums) {\n        int n = pa.size();\n        init(n);\n        ram = 0;\n        for (int i = 0; i < n; ++i) {\n            if (pa[i] != -1) {\n                add(pa[i], i);\n            }\n        }\n        dfs(0, nums); // 预处理dfs序\n        vector<int> ans(n, 0);\n        int len = *max_element(nums.begin(), nums.end()) + 1; // 找到最大值，记得+1\n        for (int i = 1; i <= n; ++i) {\n            root[i] = modify(root[i - 1], 1, len, a[i], i); // 主席树插入，注意此时用到的数组是a，不是nums了\n        }\n        for (int i = 0; i < n; ++i) {\n            // cout << p[i].x << ' ' << p[i].y << endl;\n            ans[i] = query(root[p[i].y], 1, len, p[i].x);// 查询结点i的子树，意味在查询dfs序中区间[p[i].x, p[i].y]的答案\n        }\n        return ans;\n    }\n};\n\n作者：haoboy\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/zhu-xi-shu-dfsxu-tu-po-zhi-hu-bu-xiang-t-7nh8/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","source":"_posts/weekly-contest-258.md","raw":"---\ntitle: LeetCode 周赛 258\ndate: 2021-09-12 16:51:09\ntags: LeetCode 周赛总结\n---\n\n---\n\n# LeetCode 周赛 258\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-258/problems/reverse-prefix-of-word/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-258/problems/number-of-pairs-of-interchangeable-rectangles/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-258/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-258/problems/smallest-missing-genetic-value-in-each-subtree/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 738 / 4518 | MiracleSNeko | 12   | 1:09:58  | 0:20:57                                                      | 0:33:48 1                                                    | 0:59:58 1                                                    |                                                              |\n\n## T1 5867. 反转单词前缀\n\n-   **通过的用户数**3464\n-   **尝试过的用户数**3498\n-   **用户总通过次数**3507\n-   **用户总提交次数**4264\n-   **题目难度** **Easy**\n\n给你一个下标从 **0** 开始的字符串 `word` 和一个字符 `ch` 。找出 `ch` 第一次出现的下标 `i` ，**反转** `word` 中从下标 `0` 开始、直到下标 `i` 结束（含下标 `i` ）的那段字符。如果 `word` 中不存在字符 `ch` ，则无需进行任何操作。\n\n-   例如，如果 `word = \"abcdefd\"` 且 `ch = \"d\"` ，那么你应该 **反转** 从下标 0 开始、直到下标 `3` 结束（含下标 `3` ）。结果字符串将会是 `\"***dcba***efd\"` 。\n\n返回 **结果字符串** 。\n\n**示例 1：**\n\n```\n输入：word = \"abcdefd\", ch = \"d\"\n输出：\"dcbaefd\"\n解释：\"d\" 第一次出现在下标 3 。 \n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"dcbaefd\" 。\n```\n\n**示例 2：**\n\n```\n输入：word = \"xyxzxe\", ch = \"z\"\n输出：\"zxyxxe\"\n解释：\"z\" 第一次也是唯一一次出现是在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"zxyxxe\" 。\n```\n\n**示例 3：**\n\n```\n输入：word = \"abcd\", ch = \"z\"\n输出：\"abcd\"\n解释：\"z\" 不存在于 word 中。\n无需执行反转操作，结果字符串是 \"abcd\" 。\n```\n\n**提示：**\n\n-   `1 <= word.length <= 250`\n-   `word` 由小写英文字母组成\n-   `ch` 是一个小写英文字母\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n    std::string reversePrefix(std::string word, char ch)\n    {\n        CHEATING_HEAD;\n        auto pos = word.find(ch);\n        if (pos != str::npos)\n        {\n            str prv = str(word.begin(), word.begin() + pos + 1);\n            str pst = str(word.begin() + pos + 1, word.end());\n            prv = str(prv.rbegin(), prv.rend());\n            return prv + pst;\n        }\n        return word;\n    }\n};\n```\n\n\n\n## T2 5868. 可互换矩形的组数\n\n-   **通过的用户数**2656\n-   **尝试过的用户数**3291\n-   **用户总通过次数**2705\n-   **用户总提交次数**9238\n-   **题目难度** **Medium**\n\n用一个下标从 **0** 开始的二维整数数组 `rectangles` 来表示 `n` 个矩形，其中 `rectangles[i] = [widthi, heighti]` 表示第 `i` 个矩形的宽度和高度。\n\n如果两个矩形 `i` 和 `j`（`i < j`）的宽高比相同，则认为这两个矩形 **可互换** 。更规范的说法是，两个矩形满足 `widthi/heighti == widthj/heightj`（使用实数除法而非整数除法），则认为这两个矩形 **可互换** 。\n\n计算并返回 `rectangles` 中有多少对 **可互换** 矩形。\n\n**示例 1：**\n\n```\n输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]\n输出：6\n解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：\n- 矩形 0 和矩形 1 ：4/8 == 3/6\n- 矩形 0 和矩形 2 ：4/8 == 10/20\n- 矩形 0 和矩形 3 ：4/8 == 15/30\n- 矩形 1 和矩形 2 ：3/6 == 10/20\n- 矩形 1 和矩形 3 ：3/6 == 15/30\n- 矩形 2 和矩形 3 ：10/20 == 15/30\n```\n\n**示例 2：**\n\n```\n输入：rectangles = [[4,5],[7,8]]\n输出：0\n解释：不存在成对的可互换矩形。\n```\n\n**提示：**\n\n-   `n == rectangles.length`\n-   `1 <= n <= 105`\n-   `rectangles[i].length == 2`\n-   `1 <= widthi, heighti <= 105`\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n/*     static constexpr auto Fracs = []()\n    {\n        std::array<i64, 21> fracs({1});\n        for (i64 i = 1; i <= 20; ++i)\n        {\n            fracs[i] = fracs[i - 1] * i;\n        }\n        return fracs;\n    }(); */\n\n    i64 interchangeableRectangles(std::vector<std::vector<int>> &rectangles)\n    {\n        // 找比例相等个数，求组合数 nC2\n        Vecd fracs;\n        for (auto &rect : rectangles)\n        {\n            fracs.emplace_back(static_cast<f64>(rect[0]) / static_cast<f64>(rect[1]));\n        }\n        HashMap<f64, i32> mp;\n        for (auto &f : fracs)\n        {\n            if (mp.count(f) == 0)\n            {\n                mp[f] = 1;\n            }\n            else\n            {\n                mp[f] += 1;\n            }\n        }\n        i64 ans = 0;\n        for (auto &kv : mp)\n        {\n            i64 cnt = kv.second;\n            if (cnt > 1)\n            {\n                ans += cnt * (cnt - 1) / 2;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n>   注：此处用 `double` 类型不涉及加减运算，只涉及判等，所以 `double` 作为 `key` 不会导致精度问题。\n\n-   WA 的原因： 把 $C(n, 2) = n(n - 1) / 2$ 写成了 $n!(n-1)!/2$\n\n\n\n## L3 5869. 两个回文子序列长度的最大乘积\n\n-   **通过的用户数**971\n-   **尝试过的用户数**1189\n-   **用户总通过次数**1017\n-   **用户总提交次数**2093\n-   **题目难度** **Medium**\n\n给你一个字符串 `s` ，请你找到 `s` 中两个 **不相交回文子序列** ，使得它们长度的 **乘积最大** 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 **不相交** 的。\n\n请你返回两个回文子序列长度可以达到的 **最大乘积** 。\n\n**子序列** 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 **回文字符串** 。\n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png)\n\n```\n输入：s = \"leetcodecom\"\n输出：9\n解释：最优方案是选择 \"ete\" 作为第一个子序列，\"cdc\" 作为第二个子序列。\n它们的乘积为 3 * 3 = 9 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"bb\"\n输出：1\n解释：最优方案为选择 \"b\" （第一个字符）作为第一个子序列，\"b\" （第二个字符）作为第二个子序列。\n它们的乘积为 1 * 1 = 1 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"accbcaxxcxx\"\n输出：25\n解释：最优方案为选择 \"accca\" 作为第一个子序列，\"xxcxx\" 作为第二个子序列。\n它们的乘积为 5 * 5 = 25 。\n```\n\n**提示：**\n\n-   `2 <= s.length <= 12`\n-   `s` 只含有小写英文字母。\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n    i32 countOnes(i32 x)\n    {\n        x = ((x >> 1) & 0x55555555) + (x & 0x55555555);\n        x = ((x >> 2) & 0x33333333) + (x & 0x33333333);\n        x = ((x >> 4) & 0x0f0f0f0f) + (x & 0x0f0f0f0f);\n        x = ((x >> 8) & 0x00ff00ff) + (x & 0x00ff00ff);\n        x = ((x >> 16) & 0x0000ffff) + (x & 0x0000ffff);\n        return x;\n    }\n\n    int maxProduct(str s)\n    {\n        auto check = [&s](i32 status) -> bool\n        {\n            Veci pos1({});\n            for (i32 i = 0; i < 13; ++i)\n            {\n                if (status & (1 << i))\n                    pos1.push_back(i);\n            }\n            if (pos1.size() == 1)\n                return true;\n            i32 i = 0, j = pos1.size() - 1;\n            while (i <= j)\n            {\n                if (s[pos1[i]] != s[pos1[j]])\n                    return false;\n                ++i, --j;\n            }\n            return true;\n        };\n        // 预处理所有回文子串\n        i32 sts = 1 << s.size();\n        Veci checked;\n        for (i32 st = 1; st < sts; ++st)\n        {\n            if (check(st))\n                checked.push_back(st);\n        }\n        // 遍历所有回文字串求结果\n        i32 ans = -Inf;\n        i32 clen = checked.size();\n        for (i32 i = 0; i < clen; ++i)\n        {\n            i32 sti = checked[i];\n            for (i32 j = i + 1; j < clen; ++j)\n            {\n                i32 stj = checked[j];\n                if ((sti & stj) == 0) // 无重复\n                {\n                    ans = std::max(ans, countOnes(sti) * countOnes(stj));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n>   注：本质是暴力遍历\n\n-   TLE 的原因：一开始直接暴力二重循环，没预处理回文字符串，遍历了大量的垃圾状态\n\n**其他思路**\n\ndfs 两个子序列。对于位置 i ，两个子序列可以选择用或者不用。\n\n```c++\nclass Solution {\npublic:\n    int ans = 0;\n    int maxProduct(string s) {\n        string s1, s2;\n        dfs(s, s1, s2, 0);\n        return ans;\n    }\n    \n    void dfs(string &s, string s1, string s2, int index) {\n        if(check(s1) && check(s2)) ans = max(ans, int(s1.size() * s2.size()));\n        if(index == s.size()) return;\n        dfs(s, s1 + s[index], s2, index + 1);//子序列s1使用该字符\n        dfs(s, s1, s2 + s[index], index + 1);//子序列s2使用该字符\n        dfs(s, s1, s2, index + 1);//子序列都不使用该字符\n    }\n    \n    bool check(string &s) {\n        int l = 0, r = s.size() - 1;\n        while(l < r) {\n            if(s[l++] != s[r--]) return false;\n        }\n        return true;\n    }\n};\n\n作者：ytmartian\n链接：https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/dfsliang-ge-zi-xu-lie-by-ytmartian-svyn/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T4 5870. 每棵子树内缺失的最小基因值\n\n-   **通过的用户数**175\n-   **尝试过的用户数**539\n-   **用户总通过次数**213\n-   **用户总提交次数**1154\n-   **题目难度** **Hard**\n\n有一棵根节点为 `0` 的 **家族树** ，总共包含 `n` 个节点，节点编号为 `0` 到 `n - 1` 。给你一个下标从 **0** 开始的整数数组 `parents` ，其中 `parents[i]` 是节点 `i` 的父节点。由于节点 `0` 是 **根** ，所以 `parents[0] == -1` 。\n\n总共有 `105` 个基因值，每个基因值都用 **闭区间** `[1, 105]` 中的一个整数表示。给你一个下标从 **0** 开始的整数数组 `nums` ，其中 `nums[i]` 是节点 `i` 的基因值，且基因值 **互不相同** 。\n\n请你返回一个数组 `ans` ，长度为 `n` ，其中 `ans[i]` 是以节点 `i` 为根的子树内 **缺失** 的 **最小** 基因值。\n\n节点 `x` 为根的 **子树** 包含节点 `x` 和它所有的 **后代** 节点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/23/case-1.png)\n\n```\n输入：parents = [-1,0,0,2], nums = [1,2,3,4]\n输出：[5,1,1,1]\n解释：每个子树答案计算结果如下：\n- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。\n- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。\n- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。\n- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/23/case-2.png)\n\n```\n输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]\n输出：[7,1,1,4,2,1]\n解释：每个子树答案计算结果如下：\n- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。\n- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。\n- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。\n- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。\n- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。\n- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。\n```\n\n**示例 3：**\n\n```\n输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]\n输出：[1,1,1,1,1,1,1]\n解释：所有子树都缺失基因值 1 。\n```\n\n**提示：**\n\n-   `n == parents.length == nums.length`\n-   `2 <= n <= 105`\n-   对于 `i != 0` ，满足 `0 <= parents[i] <= n - 1`\n-   `parents[0] == -1`\n-   `parents` 表示一棵合法的树。\n-   `1 <= nums[i] <= 105`\n-   `nums[i]` 互不相同。\n\n**解法笔记**\n\n**解法一：启发式合并**\n遍历整棵树，统计每棵子树包含的基因值集合以及缺失的最小基因值，记作 $\\textit{mex}$。合并基因值集合时，总是从小的往大的合并（类似并查集的按秩合并），同时更新当前子树的 $\\textit{mex}$ 的最大值。合并完成后再不断自增子树的 $\\textit{mex}$ 直至其不在基因值集合中。\n\n这一方法同时也适用于有相同基因值的情况。\n\n时间复杂度：$O(n\\log n)$。证明。\n\n```go\nfunc smallestMissingValueSubtree(parents []int, nums []int) []int {\n\tn := len(parents)\n\tg := make([][]int, n)\n\tfor w := 1; w < n; w++ {\n\t\tv := parents[w]\n\t\tg[v] = append(g[v], w)\n\t}\n\tmex := make([]int, n)\n\tvar f func(int) map[int]bool\n\tf = func(v int) map[int]bool {\n\t\tset := map[int]bool{}\n\t\tmex[v] = 1\n\t\tfor _, w := range g[v] {\n\t\t\ts := f(w)\n\t\t\t// 保证总是从小集合合并到大集合上\n\t\t\tif len(s) > len(set) {\n\t\t\t\tset, s = s, set\n\t\t\t}\n\t\t\tfor x := range s {\n\t\t\t\tset[x] = true\n\t\t\t}\n\t\t\tif mex[w] > mex[v] {\n\t\t\t\tmex[v] = mex[w]\n\t\t\t}\n\t\t}\n\t\tset[nums[v]] = true\n\t\tfor set[mex[v]] {\n\t\t\tmex[v]++ // 不断自增 mex 直至其不在基因值集合中\n\t\t}\n\t\treturn set\n\t}\n\tf(0)\n\treturn mex\n}\n\n作者：endlesscheng\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n**解法二：利用无重复基因值的性质**\n由于没有重复基因值，若存在节点 $x$，其基因值等于 $1$，则从 $x$ 到根的这一条链上的所有节点的 $\\textit{mex}$ 均超过 $1$，而其余节点的 $\\textit{mex}$ 值均为 $1$。我们顺着 $x$ 往根上走，同时收集当前子树的基因值到集合中，然后更新当前子树的 $\\textit{mex}$ 值。\n\n时间复杂度：$O(n)$。\n\n```go\nfunc smallestMissingValueSubtree(parents []int, nums []int) []int {\n\tn := len(parents)\n\tg := make([][]int, n)\n\tfor w := 1; w < n; w++ {\n\t\tv := parents[w]\n\t\tg[v] = append(g[v], w)\n\t}\n\n\tmex := make([]int, n)\n\tfor i := range mex {\n\t\tmex[i] = 1\n\t}\n\t\n\tset := map[int]bool{}\n\tvis := make([]bool, n)\n\tvar f func(int)\n\tf = func(v int) {\n\t\tset[nums[v]] = true // 收集基因值到 set 中\n\t\tfor _, w := range g[v] {\n\t\t\tif !vis[w] {\n\t\t\t\tf(w)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 找基因值等于 1 的节点 x\n\tx := -1\n\tfor i, v := range nums {\n\t\tif v == 1 {\n\t\t\tx = i\n\t\t\tbreak\n\t\t}\n\t}\n\t// x 顺着父节点往上走\n\tfor cur := 2; x >= 0; x = parents[x] {\n\t\tf(x)\n\t\tvis[x] = true // 这是保证时间复杂度的关键：之后遍历父节点子树时，就无需再次遍历 x 子树了\n\t\tfor set[cur] {\n\t\t\tcur++ // 不断自增直至不在基因值集合中\n\t\t}\n\t\tmex[x] = cur\n\t}\n\treturn mex\n}\n\n作者：endlesscheng\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n**不一样的思路：主席树+dfs序（突破值互不相同的限制）**\n\n-   看到很多题解是从基因值互不相同的条件入手写的，后来突然发现我的解法不需要考虑这个\n-   可能我的思路比较繁琐，时间复杂度有没有O(n)的优秀，固在此也只是想提供一个与众不同的思路罢了（勿喷）\n-   前置知识：主席树，dfs序\n-   注意到，这题的本质就是求mex，但不同的是，其不是真正的mex，最小的数是1，mex最小的数是0，但不影响做这题。\n-   将问题转化一下，求一个区间的mex，可以线段树、主席树，这里使用主席树做方便\n-   主席树找mex的思路\n    -   利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了\n    -   最终查询 `[L, R]` 区间的mex时，则是在版本 `R` 的权值线段树中找下标小于 `L` 的最小的数即可\n-   再来就是怎么将区间转化成树上查询，显然可以用到dfs序了\n\n```c++\nconst int N = 1e5 + 5;\nstruct pii {\n    int x, y;\n};\npii p[N];\n\nint head[N], cnt, tim;\n\n//初始化\nvoid init(int n) { fill_n(head, n + 5, -1); cnt = -1; tim = 0; }\n\nstruct edges {\n    int to, next;\n    void add(int t, int n) {\n        to = t, next = n;\n    }\n}edge[N << 1]; //无向图则需要乘2\n\ninline void add(int u, int v) {\n    edge[++cnt].add(v, head[u]);\n    head[u] = cnt;\n}\n\nint a[N], ram, root[N], vis[N];\nvoid dfs(int u, vector<int>& num) {\n    p[u].x = ++tim;\n    a[tim] = num[u]; // 重置数组\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        dfs(edge[i].to, num);\n    }\n    p[u].y = tim;\n}\n\n\nstruct nodes {int l, r, minv; } hjt[N * 25];\n\nint modify(int pre, int l, int r, int val, int pos) {\n    int now = ++ram;\n    hjt[now] = hjt[pre];\n    if (l == r) {\n        hjt[now].minv = pos;\n        return now;\n    }\n    int mid = (l + r) >> 1;\n    if (val <= mid) hjt[now].l = modify(hjt[now].l, l, mid, val, pos);\n    else hjt[now].r = modify(hjt[now].r, mid + 1, r, val, pos);\n    hjt[now].minv = min(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv);\n    return now;\n}\n\nint query(int tr, int l, int r, int ql) {\n    if (l == r) return l;\n    int mid = (l + r) >> 1;\n    if (hjt[hjt[tr].l].minv < ql) return query(hjt[tr].l, l, mid, ql);\n    return query(hjt[tr].r, mid + 1, r, ql);\n}\n\n\nclass Solution {\npublic:\n    vector<int> smallestMissingValueSubtree(vector<int>& pa, vector<int>& nums) {\n        int n = pa.size();\n        init(n);\n        ram = 0;\n        for (int i = 0; i < n; ++i) {\n            if (pa[i] != -1) {\n                add(pa[i], i);\n            }\n        }\n        dfs(0, nums); // 预处理dfs序\n        vector<int> ans(n, 0);\n        int len = *max_element(nums.begin(), nums.end()) + 1; // 找到最大值，记得+1\n        for (int i = 1; i <= n; ++i) {\n            root[i] = modify(root[i - 1], 1, len, a[i], i); // 主席树插入，注意此时用到的数组是a，不是nums了\n        }\n        for (int i = 0; i < n; ++i) {\n            // cout << p[i].x << ' ' << p[i].y << endl;\n            ans[i] = query(root[p[i].y], 1, len, p[i].x);// 查询结点i的子树，意味在查询dfs序中区间[p[i].x, p[i].y]的答案\n        }\n        return ans;\n    }\n};\n\n作者：haoboy\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/zhu-xi-shu-dfsxu-tu-po-zhi-hu-bu-xiang-t-7nh8/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","slug":"weekly-contest-258","published":1,"updated":"2021-10-07T13:05:47.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckugyov2k0004kbgd8hh2c1f8","content":"<hr>\n<h1 id=\"LeetCode-周赛-258\"><a href=\"#LeetCode-周赛-258\" class=\"headerlink\" title=\"LeetCode 周赛 258\"></a>LeetCode 周赛 258</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/reverse-prefix-of-word/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/number-of-pairs-of-interchangeable-rectangles/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/smallest-missing-genetic-value-in-each-subtree/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>738 / 4518</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:09:58</td>\n<td>0:20:57</td>\n<td>0:33:48 1</td>\n<td>0:59:58 1</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5867-反转单词前缀\"><a href=\"#T1-5867-反转单词前缀\" class=\"headerlink\" title=\"T1 5867. 反转单词前缀\"></a>T1 5867. 反转单词前缀</h2><ul>\n<li>  <strong>通过的用户数</strong>3464</li>\n<li>  <strong>尝试过的用户数</strong>3498</li>\n<li>  <strong>用户总通过次数</strong>3507</li>\n<li>  <strong>用户总提交次数</strong>4264</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个字符 <code>ch</code> 。找出 <code>ch</code> 第一次出现的下标 <code>i</code> ，<strong>反转</strong> <code>word</code> 中从下标 <code>0</code> 开始、直到下标 <code>i</code> 结束（含下标 <code>i</code> ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p>\n<ul>\n<li>  例如，如果 <code>word = &quot;abcdefd&quot;</code> 且 <code>ch = &quot;d&quot;</code> ，那么你应该 <strong>反转</strong> 从下标 0 开始、直到下标 <code>3</code> 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>&quot;***dcba***efd&quot;</code> 。</li>\n</ul>\n<p>返回 <strong>结果字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;abcdefd&quot;, ch = &quot;d&quot;</span><br><span class=\"line\">输出：&quot;dcbaefd&quot;</span><br><span class=\"line\">解释：&quot;d&quot; 第一次出现在下标 3 。 </span><br><span class=\"line\">反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;dcbaefd&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;xyxzxe&quot;, ch = &quot;z&quot;</span><br><span class=\"line\">输出：&quot;zxyxxe&quot;</span><br><span class=\"line\">解释：&quot;z&quot; 第一次也是唯一一次出现是在下标 3 。</span><br><span class=\"line\">反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;zxyxxe&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;abcd&quot;, ch = &quot;z&quot;</span><br><span class=\"line\">输出：&quot;abcd&quot;</span><br><span class=\"line\">解释：&quot;z&quot; 不存在于 word 中。</span><br><span class=\"line\">无需执行反转操作，结果字符串是 &quot;abcd&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= word.length &lt;= 250</code></li>\n<li>  <code>word</code> 由小写英文字母组成</li>\n<li>  <code>ch</code> 是一个小写英文字母</li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">reversePrefix</span><span class=\"params\">(std::string word, <span class=\"keyword\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        CHEATING_HEAD;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> pos = word.<span class=\"built_in\">find</span>(ch);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos != str::npos)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            str prv = <span class=\"built_in\">str</span>(word.<span class=\"built_in\">begin</span>(), word.<span class=\"built_in\">begin</span>() + pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">            str pst = <span class=\"built_in\">str</span>(word.<span class=\"built_in\">begin</span>() + pos + <span class=\"number\">1</span>, word.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            prv = <span class=\"built_in\">str</span>(prv.<span class=\"built_in\">rbegin</span>(), prv.<span class=\"built_in\">rend</span>());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> prv + pst;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5868-可互换矩形的组数\"><a href=\"#T2-5868-可互换矩形的组数\" class=\"headerlink\" title=\"T2 5868. 可互换矩形的组数\"></a>T2 5868. 可互换矩形的组数</h2><ul>\n<li>  <strong>通过的用户数</strong>2656</li>\n<li>  <strong>尝试过的用户数</strong>3291</li>\n<li>  <strong>用户总通过次数</strong>2705</li>\n<li>  <strong>用户总提交次数</strong>9238</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>用一个下标从 <strong>0</strong> 开始的二维整数数组 <code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [widthi, heighti]</code> 表示第 <code>i</code> 个矩形的宽度和高度。</p>\n<p>如果两个矩形 <code>i</code> 和 <code>j</code>（<code>i &lt; j</code>）的宽高比相同，则认为这两个矩形 <strong>可互换</strong> 。更规范的说法是，两个矩形满足 <code>widthi/heighti == widthj/heightj</code>（使用实数除法而非整数除法），则认为这两个矩形 <strong>可互换</strong> 。</p>\n<p>计算并返回 <code>rectangles</code> 中有多少对 <strong>可互换</strong> 矩形。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：</span><br><span class=\"line\">- 矩形 0 和矩形 1 ：4/8 == 3/6</span><br><span class=\"line\">- 矩形 0 和矩形 2 ：4/8 == 10/20</span><br><span class=\"line\">- 矩形 0 和矩形 3 ：4/8 == 15/30</span><br><span class=\"line\">- 矩形 1 和矩形 2 ：3/6 == 10/20</span><br><span class=\"line\">- 矩形 1 和矩形 3 ：3/6 == 15/30</span><br><span class=\"line\">- 矩形 2 和矩形 3 ：10/20 == 15/30</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[4,5],[7,8]]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：不存在成对的可互换矩形。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == rectangles.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>rectangles[i].length == 2</code></li>\n<li>  <code>1 &lt;= widthi, heighti &lt;= 105</code></li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">/*     static constexpr auto Fracs = []()</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        std::array&lt;i64, 21&gt; fracs(&#123;1&#125;);</span></span><br><span class=\"line\"><span class=\"comment\">        for (i64 i = 1; i &lt;= 20; ++i)</span></span><br><span class=\"line\"><span class=\"comment\">        &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            fracs[i] = fracs[i - 1] * i;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        return fracs;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;(); */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">i64 <span class=\"title\">interchangeableRectangles</span><span class=\"params\">(std::vector&lt;std::vector&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;rectangles)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找比例相等个数，求组合数 nC2</span></span><br><span class=\"line\">        Vecd fracs;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;rect : rectangles)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fracs.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">static_cast</span>&lt;f64&gt;(rect[<span class=\"number\">0</span>]) / <span class=\"keyword\">static_cast</span>&lt;f64&gt;(rect[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HashMap&lt;f64, i32&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;f : fracs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(f) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[f] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[f] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i64 ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;kv : mp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i64 cnt = kv.second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += cnt * (cnt - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  注：此处用 <code>double</code> 类型不涉及加减运算，只涉及判等，所以 <code>double</code> 作为 <code>key</code> 不会导致精度问题。</p>\n</blockquote>\n<ul>\n<li>  WA 的原因： 把 $C(n, 2) = n(n - 1) / 2$ 写成了 $n!(n-1)!/2$</li>\n</ul>\n<h2 id=\"L3-5869-两个回文子序列长度的最大乘积\"><a href=\"#L3-5869-两个回文子序列长度的最大乘积\" class=\"headerlink\" title=\"L3 5869. 两个回文子序列长度的最大乘积\"></a>L3 5869. 两个回文子序列长度的最大乘积</h2><ul>\n<li>  <strong>通过的用户数</strong>971</li>\n<li>  <strong>尝试过的用户数</strong>1189</li>\n<li>  <strong>用户总通过次数</strong>1017</li>\n<li>  <strong>用户总提交次数</strong>2093</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个字符串 <code>s</code> ，请你找到 <code>s</code> 中两个 <strong>不相交回文子序列</strong> ，使得它们长度的 <strong>乘积最大</strong> 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 <strong>不相交</strong> 的。</p>\n<p>请你返回两个回文子序列长度可以达到的 <strong>最大乘积</strong> 。</p>\n<p><strong>子序列</strong> 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 <strong>回文字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;leetcodecom&quot;</span><br><span class=\"line\">输出：9</span><br><span class=\"line\">解释：最优方案是选择 &quot;ete&quot; 作为第一个子序列，&quot;cdc&quot; 作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 3 * 3 = 9 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bb&quot;</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：最优方案为选择 &quot;b&quot; （第一个字符）作为第一个子序列，&quot;b&quot; （第二个字符）作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 1 * 1 = 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;accbcaxxcxx&quot;</span><br><span class=\"line\">输出：25</span><br><span class=\"line\">解释：最优方案为选择 &quot;accca&quot; 作为第一个子序列，&quot;xxcxx&quot; 作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 5 * 5 = 25 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= s.length &lt;= 12</code></li>\n<li>  <code>s</code> 只含有小写英文字母。</li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">i32 <span class=\"title\">countOnes</span><span class=\"params\">(i32 x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">1</span>) &amp; <span class=\"number\">0x55555555</span>) + (x &amp; <span class=\"number\">0x55555555</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">2</span>) &amp; <span class=\"number\">0x33333333</span>) + (x &amp; <span class=\"number\">0x33333333</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0x0f0f0f0f</span>) + (x &amp; <span class=\"number\">0x0f0f0f0f</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0x00ff00ff</span>) + (x &amp; <span class=\"number\">0x00ff00ff</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0x0000ffff</span>) + (x &amp; <span class=\"number\">0x0000ffff</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(str s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;s](i32 status) -&gt; <span class=\"keyword\">bool</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Veci <span class=\"built_in\">pos1</span>(&#123;&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i32 i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">13</span>; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (status &amp; (<span class=\"number\">1</span> &lt;&lt; i))</span><br><span class=\"line\">                    pos1.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos1.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i32 i = <span class=\"number\">0</span>, j = pos1.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[pos1[i]] != s[pos1[j]])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                ++i, --j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 预处理所有回文子串</span></span><br><span class=\"line\">        i32 sts = <span class=\"number\">1</span> &lt;&lt; s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        Veci checked;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i32 st = <span class=\"number\">1</span>; st &lt; sts; ++st)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(st))</span><br><span class=\"line\">                checked.<span class=\"built_in\">push_back</span>(st);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有回文字串求结果</span></span><br><span class=\"line\">        i32 ans = -Inf;</span><br><span class=\"line\">        i32 clen = checked.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i32 i = <span class=\"number\">0</span>; i &lt; clen; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i32 sti = checked[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i32 j = i + <span class=\"number\">1</span>; j &lt; clen; ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i32 stj = checked[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sti &amp; stj) == <span class=\"number\">0</span>) <span class=\"comment\">// 无重复</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ans = std::<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">countOnes</span>(sti) * <span class=\"built_in\">countOnes</span>(stj));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  注：本质是暴力遍历</p>\n</blockquote>\n<ul>\n<li>  TLE 的原因：一开始直接暴力二重循环，没预处理回文字符串，遍历了大量的垃圾状态</li>\n</ul>\n<p><strong>其他思路</strong></p>\n<p>dfs 两个子序列。对于位置 i ，两个子序列可以选择用或者不用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        string s1, s2;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(string &amp;s, string s1, string s2, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(s1) &amp;&amp; <span class=\"built_in\">check</span>(s2)) ans = <span class=\"built_in\">max</span>(ans, <span class=\"built_in\"><span class=\"keyword\">int</span></span>(s1.<span class=\"built_in\">size</span>() * s2.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index == s.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1 + s[index], s2, index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列s1使用该字符</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2 + s[index], index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列s2使用该字符</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2, index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列都不使用该字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(string &amp;s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[l++] != s[r--]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：ytmartian</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/dfsliang-ge-zi-xu-lie-by-ytmartian-svyn/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5870-每棵子树内缺失的最小基因值\"><a href=\"#T4-5870-每棵子树内缺失的最小基因值\" class=\"headerlink\" title=\"T4 5870. 每棵子树内缺失的最小基因值\"></a>T4 5870. 每棵子树内缺失的最小基因值</h2><ul>\n<li>  <strong>通过的用户数</strong>175</li>\n<li>  <strong>尝试过的用户数</strong>539</li>\n<li>  <strong>用户总通过次数</strong>213</li>\n<li>  <strong>用户总提交次数</strong>1154</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>有一棵根节点为 <code>0</code> 的 <strong>家族树</strong> ，总共包含 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是 <strong>根</strong> ，所以 <code>parents[0] == -1</code> 。</p>\n<p>总共有 <code>105</code> 个基因值，每个基因值都用 <strong>闭区间</strong> <code>[1, 105]</code> 中的一个整数表示。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是节点 <code>i</code> 的基因值，且基因值 <strong>互不相同</strong> 。</p>\n<p>请你返回一个数组 <code>ans</code> ，长度为 <code>n</code> ，其中 <code>ans[i]</code> 是以节点 <code>i</code> 为根的子树内 <strong>缺失</strong> 的 <strong>最小</strong> 基因值。</p>\n<p>节点 <code>x</code> 为根的 <strong>子树</strong> 包含节点 <code>x</code> 和它所有的 <strong>后代</strong> 节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/23/case-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,0,0,2], nums = [1,2,3,4]</span><br><span class=\"line\">输出：[5,1,1,1]</span><br><span class=\"line\">解释：每个子树答案计算结果如下：</span><br><span class=\"line\">- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。</span><br><span class=\"line\">- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/23/case-2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]</span><br><span class=\"line\">输出：[7,1,1,4,2,1]</span><br><span class=\"line\">解释：每个子树答案计算结果如下：</span><br><span class=\"line\">- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。</span><br><span class=\"line\">- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。</span><br><span class=\"line\">- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。</span><br><span class=\"line\">- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。</span><br><span class=\"line\">- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]</span><br><span class=\"line\">输出：[1,1,1,1,1,1,1]</span><br><span class=\"line\">解释：所有子树都缺失基因值 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == parents.length == nums.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  对于 <code>i != 0</code> ，满足 <code>0 &lt;= parents[i] &lt;= n - 1</code></li>\n<li>  <code>parents[0] == -1</code></li>\n<li>  <code>parents</code> 表示一棵合法的树。</li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n<li>  <code>nums[i]</code> 互不相同。</li>\n</ul>\n<p><strong>解法笔记</strong></p>\n<p><strong>解法一：启发式合并</strong><br>遍历整棵树，统计每棵子树包含的基因值集合以及缺失的最小基因值，记作 $\\textit{mex}$。合并基因值集合时，总是从小的往大的合并（类似并查集的按秩合并），同时更新当前子树的 $\\textit{mex}$ 的最大值。合并完成后再不断自增子树的 $\\textit{mex}$ 直至其不在基因值集合中。</p>\n<p>这一方法同时也适用于有相同基因值的情况。</p>\n<p>时间复杂度：$O(n\\log n)$。证明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(parents []<span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(parents)</span><br><span class=\"line\">\tg := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt; n; w++ &#123;</span><br><span class=\"line\">\t\tv := parents[w]</span><br><span class=\"line\">\t\tg[v] = <span class=\"built_in\">append</span>(g[v], w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmex := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">int</span>]<span class=\"title\">bool</span></span></span><br><span class=\"line\">\tf = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">int</span>]<span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\tset := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>&#123;&#125;</span><br><span class=\"line\">\t\tmex[v] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> g[v] &#123;</span><br><span class=\"line\">\t\t\ts := f(w)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 保证总是从小集合合并到大集合上</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &gt; <span class=\"built_in\">len</span>(set) &#123;</span><br><span class=\"line\">\t\t\t\tset, s = s, set</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\t\t\tset[x] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> mex[w] &gt; mex[v] &#123;</span><br><span class=\"line\">\t\t\t\tmex[v] = mex[w]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tset[nums[v]] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> set[mex[v]] &#123;</span><br><span class=\"line\">\t\t\tmex[v]++ <span class=\"comment\">// 不断自增 mex 直至其不在基因值集合中</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> set</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：endlesscheng</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<p><strong>解法二：利用无重复基因值的性质</strong><br>由于没有重复基因值，若存在节点 $x$，其基因值等于 $1$，则从 $x$ 到根的这一条链上的所有节点的 $\\textit{mex}$ 均超过 $1$，而其余节点的 $\\textit{mex}$ 值均为 $1$。我们顺着 $x$ 往根上走，同时收集当前子树的基因值到集合中，然后更新当前子树的 $\\textit{mex}$ 值。</p>\n<p>时间复杂度：$O(n)$。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(parents []<span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(parents)</span><br><span class=\"line\">\tg := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt; n; w++ &#123;</span><br><span class=\"line\">\t\tv := parents[w]</span><br><span class=\"line\">\t\tg[v] = <span class=\"built_in\">append</span>(g[v], w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmex := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> mex &#123;</span><br><span class=\"line\">\t\tmex[i] = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tset := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>&#123;&#125;</span><br><span class=\"line\">\tvis := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span></span><br><span class=\"line\">\tf = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tset[nums[v]] = <span class=\"literal\">true</span> <span class=\"comment\">// 收集基因值到 set 中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> g[v] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !vis[w] &#123;</span><br><span class=\"line\">\t\t\t\tf(w)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 找基因值等于 1 的节点 x</span></span><br><span class=\"line\">\tx := <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tx = i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// x 顺着父节点往上走</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> cur := <span class=\"number\">2</span>; x &gt;= <span class=\"number\">0</span>; x = parents[x] &#123;</span><br><span class=\"line\">\t\tf(x)</span><br><span class=\"line\">\t\tvis[x] = <span class=\"literal\">true</span> <span class=\"comment\">// 这是保证时间复杂度的关键：之后遍历父节点子树时，就无需再次遍历 x 子树了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> set[cur] &#123;</span><br><span class=\"line\">\t\t\tcur++ <span class=\"comment\">// 不断自增直至不在基因值集合中</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmex[x] = cur</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：endlesscheng</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<p><strong>不一样的思路：主席树+dfs序（突破值互不相同的限制）</strong></p>\n<ul>\n<li>  看到很多题解是从基因值互不相同的条件入手写的，后来突然发现我的解法不需要考虑这个</li>\n<li>  可能我的思路比较繁琐，时间复杂度有没有O(n)的优秀，固在此也只是想提供一个与众不同的思路罢了（勿喷）</li>\n<li>  前置知识：主席树，dfs序</li>\n<li>  注意到，这题的本质就是求mex，但不同的是，其不是真正的mex，最小的数是1，mex最小的数是0，但不影响做这题。</li>\n<li>  将问题转化一下，求一个区间的mex，可以线段树、主席树，这里使用主席树做方便</li>\n<li>主席树找mex的思路<ul>\n<li>  利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了</li>\n<li>  最终查询 <code>[L, R]</code> 区间的mex时，则是在版本 <code>R</code> 的权值线段树中找下标小于 <code>L</code> 的最小的数即可</li>\n</ul>\n</li>\n<li>  再来就是怎么将区间转化成树上查询，显然可以用到dfs序了</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pii</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">pii p[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> head[N], cnt, tim;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"built_in\">fill_n</span>(head, n + <span class=\"number\">5</span>, <span class=\"number\">-1</span>); cnt = <span class=\"number\">-1</span>; tim = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edges</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to, next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        to = t, next = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;edge[N &lt;&lt; <span class=\"number\">1</span>]; <span class=\"comment\">//无向图则需要乘2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">    edge[++cnt].<span class=\"built_in\">add</span>(v, head[u]);</span><br><span class=\"line\">    head[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[N], ram, root[N], vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; num)</span> </span>&#123;</span><br><span class=\"line\">    p[u].x = ++tim;</span><br><span class=\"line\">    a[tim] = num[u]; <span class=\"comment\">// 重置数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].next) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(edge[i].to, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p[u].y = tim;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nodes</span> &#123;</span><span class=\"keyword\">int</span> l, r, minv; &#125; hjt[N * <span class=\"number\">25</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> pre, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = ++ram;</span><br><span class=\"line\">    hjt[now] = hjt[pre];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">        hjt[now].minv = pos;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (val &lt;= mid) hjt[now].l = <span class=\"built_in\">modify</span>(hjt[now].l, l, mid, val, pos);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> hjt[now].r = <span class=\"built_in\">modify</span>(hjt[now].r, mid + <span class=\"number\">1</span>, r, val, pos);</span><br><span class=\"line\">    hjt[now].minv = <span class=\"built_in\">min</span>(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> tr, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hjt[hjt[tr].l].minv &lt; ql) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(hjt[tr].l, l, mid, ql);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(hjt[tr].r, mid + <span class=\"number\">1</span>, r, ql);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; pa, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = pa.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">init</span>(n);</span><br><span class=\"line\">        ram = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pa[i] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">add</span>(pa[i], i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, nums); <span class=\"comment\">// 预处理dfs序</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = *<span class=\"built_in\">max_element</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()) + <span class=\"number\">1</span>; <span class=\"comment\">// 找到最大值，记得+1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            root[i] = <span class=\"built_in\">modify</span>(root[i - <span class=\"number\">1</span>], <span class=\"number\">1</span>, len, a[i], i); <span class=\"comment\">// 主席树插入，注意此时用到的数组是a，不是nums了</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; p[i].x &lt;&lt; &#x27; &#x27; &lt;&lt; p[i].y &lt;&lt; endl;</span></span><br><span class=\"line\">            ans[i] = <span class=\"built_in\">query</span>(root[p[i].y], <span class=\"number\">1</span>, len, p[i].x);<span class=\"comment\">// 查询结点i的子树，意味在查询dfs序中区间[p[i].x, p[i].y]的答案</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：haoboy</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/zhu-xi-shu-dfsxu-tu-po-zhi-hu-bu-xiang-t-7nh8/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-258\"><a href=\"#LeetCode-周赛-258\" class=\"headerlink\" title=\"LeetCode 周赛 258\"></a>LeetCode 周赛 258</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/reverse-prefix-of-word/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/number-of-pairs-of-interchangeable-rectangles/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/smallest-missing-genetic-value-in-each-subtree/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>738 / 4518</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:09:58</td>\n<td>0:20:57</td>\n<td>0:33:48 1</td>\n<td>0:59:58 1</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5867-反转单词前缀\"><a href=\"#T1-5867-反转单词前缀\" class=\"headerlink\" title=\"T1 5867. 反转单词前缀\"></a>T1 5867. 反转单词前缀</h2><ul>\n<li>  <strong>通过的用户数</strong>3464</li>\n<li>  <strong>尝试过的用户数</strong>3498</li>\n<li>  <strong>用户总通过次数</strong>3507</li>\n<li>  <strong>用户总提交次数</strong>4264</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个字符 <code>ch</code> 。找出 <code>ch</code> 第一次出现的下标 <code>i</code> ，<strong>反转</strong> <code>word</code> 中从下标 <code>0</code> 开始、直到下标 <code>i</code> 结束（含下标 <code>i</code> ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p>\n<ul>\n<li>  例如，如果 <code>word = &quot;abcdefd&quot;</code> 且 <code>ch = &quot;d&quot;</code> ，那么你应该 <strong>反转</strong> 从下标 0 开始、直到下标 <code>3</code> 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>&quot;***dcba***efd&quot;</code> 。</li>\n</ul>\n<p>返回 <strong>结果字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;abcdefd&quot;, ch = &quot;d&quot;</span><br><span class=\"line\">输出：&quot;dcbaefd&quot;</span><br><span class=\"line\">解释：&quot;d&quot; 第一次出现在下标 3 。 </span><br><span class=\"line\">反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;dcbaefd&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;xyxzxe&quot;, ch = &quot;z&quot;</span><br><span class=\"line\">输出：&quot;zxyxxe&quot;</span><br><span class=\"line\">解释：&quot;z&quot; 第一次也是唯一一次出现是在下标 3 。</span><br><span class=\"line\">反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;zxyxxe&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;abcd&quot;, ch = &quot;z&quot;</span><br><span class=\"line\">输出：&quot;abcd&quot;</span><br><span class=\"line\">解释：&quot;z&quot; 不存在于 word 中。</span><br><span class=\"line\">无需执行反转操作，结果字符串是 &quot;abcd&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= word.length &lt;= 250</code></li>\n<li>  <code>word</code> 由小写英文字母组成</li>\n<li>  <code>ch</code> 是一个小写英文字母</li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">reversePrefix</span><span class=\"params\">(std::string word, <span class=\"keyword\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        CHEATING_HEAD;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> pos = word.<span class=\"built_in\">find</span>(ch);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos != str::npos)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            str prv = <span class=\"built_in\">str</span>(word.<span class=\"built_in\">begin</span>(), word.<span class=\"built_in\">begin</span>() + pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">            str pst = <span class=\"built_in\">str</span>(word.<span class=\"built_in\">begin</span>() + pos + <span class=\"number\">1</span>, word.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            prv = <span class=\"built_in\">str</span>(prv.<span class=\"built_in\">rbegin</span>(), prv.<span class=\"built_in\">rend</span>());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> prv + pst;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5868-可互换矩形的组数\"><a href=\"#T2-5868-可互换矩形的组数\" class=\"headerlink\" title=\"T2 5868. 可互换矩形的组数\"></a>T2 5868. 可互换矩形的组数</h2><ul>\n<li>  <strong>通过的用户数</strong>2656</li>\n<li>  <strong>尝试过的用户数</strong>3291</li>\n<li>  <strong>用户总通过次数</strong>2705</li>\n<li>  <strong>用户总提交次数</strong>9238</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>用一个下标从 <strong>0</strong> 开始的二维整数数组 <code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [widthi, heighti]</code> 表示第 <code>i</code> 个矩形的宽度和高度。</p>\n<p>如果两个矩形 <code>i</code> 和 <code>j</code>（<code>i &lt; j</code>）的宽高比相同，则认为这两个矩形 <strong>可互换</strong> 。更规范的说法是，两个矩形满足 <code>widthi/heighti == widthj/heightj</code>（使用实数除法而非整数除法），则认为这两个矩形 <strong>可互换</strong> 。</p>\n<p>计算并返回 <code>rectangles</code> 中有多少对 <strong>可互换</strong> 矩形。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：</span><br><span class=\"line\">- 矩形 0 和矩形 1 ：4/8 == 3/6</span><br><span class=\"line\">- 矩形 0 和矩形 2 ：4/8 == 10/20</span><br><span class=\"line\">- 矩形 0 和矩形 3 ：4/8 == 15/30</span><br><span class=\"line\">- 矩形 1 和矩形 2 ：3/6 == 10/20</span><br><span class=\"line\">- 矩形 1 和矩形 3 ：3/6 == 15/30</span><br><span class=\"line\">- 矩形 2 和矩形 3 ：10/20 == 15/30</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[4,5],[7,8]]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：不存在成对的可互换矩形。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == rectangles.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>rectangles[i].length == 2</code></li>\n<li>  <code>1 &lt;= widthi, heighti &lt;= 105</code></li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">/*     static constexpr auto Fracs = []()</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        std::array&lt;i64, 21&gt; fracs(&#123;1&#125;);</span></span><br><span class=\"line\"><span class=\"comment\">        for (i64 i = 1; i &lt;= 20; ++i)</span></span><br><span class=\"line\"><span class=\"comment\">        &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            fracs[i] = fracs[i - 1] * i;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        return fracs;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;(); */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">i64 <span class=\"title\">interchangeableRectangles</span><span class=\"params\">(std::vector&lt;std::vector&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;rectangles)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找比例相等个数，求组合数 nC2</span></span><br><span class=\"line\">        Vecd fracs;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;rect : rectangles)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fracs.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">static_cast</span>&lt;f64&gt;(rect[<span class=\"number\">0</span>]) / <span class=\"keyword\">static_cast</span>&lt;f64&gt;(rect[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HashMap&lt;f64, i32&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;f : fracs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(f) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[f] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[f] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i64 ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;kv : mp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i64 cnt = kv.second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += cnt * (cnt - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  注：此处用 <code>double</code> 类型不涉及加减运算，只涉及判等，所以 <code>double</code> 作为 <code>key</code> 不会导致精度问题。</p>\n</blockquote>\n<ul>\n<li>  WA 的原因： 把 $C(n, 2) = n(n - 1) / 2$ 写成了 $n!(n-1)!/2$</li>\n</ul>\n<h2 id=\"L3-5869-两个回文子序列长度的最大乘积\"><a href=\"#L3-5869-两个回文子序列长度的最大乘积\" class=\"headerlink\" title=\"L3 5869. 两个回文子序列长度的最大乘积\"></a>L3 5869. 两个回文子序列长度的最大乘积</h2><ul>\n<li>  <strong>通过的用户数</strong>971</li>\n<li>  <strong>尝试过的用户数</strong>1189</li>\n<li>  <strong>用户总通过次数</strong>1017</li>\n<li>  <strong>用户总提交次数</strong>2093</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个字符串 <code>s</code> ，请你找到 <code>s</code> 中两个 <strong>不相交回文子序列</strong> ，使得它们长度的 <strong>乘积最大</strong> 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 <strong>不相交</strong> 的。</p>\n<p>请你返回两个回文子序列长度可以达到的 <strong>最大乘积</strong> 。</p>\n<p><strong>子序列</strong> 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 <strong>回文字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;leetcodecom&quot;</span><br><span class=\"line\">输出：9</span><br><span class=\"line\">解释：最优方案是选择 &quot;ete&quot; 作为第一个子序列，&quot;cdc&quot; 作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 3 * 3 = 9 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bb&quot;</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：最优方案为选择 &quot;b&quot; （第一个字符）作为第一个子序列，&quot;b&quot; （第二个字符）作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 1 * 1 = 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;accbcaxxcxx&quot;</span><br><span class=\"line\">输出：25</span><br><span class=\"line\">解释：最优方案为选择 &quot;accca&quot; 作为第一个子序列，&quot;xxcxx&quot; 作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 5 * 5 = 25 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= s.length &lt;= 12</code></li>\n<li>  <code>s</code> 只含有小写英文字母。</li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">i32 <span class=\"title\">countOnes</span><span class=\"params\">(i32 x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">1</span>) &amp; <span class=\"number\">0x55555555</span>) + (x &amp; <span class=\"number\">0x55555555</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">2</span>) &amp; <span class=\"number\">0x33333333</span>) + (x &amp; <span class=\"number\">0x33333333</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0x0f0f0f0f</span>) + (x &amp; <span class=\"number\">0x0f0f0f0f</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0x00ff00ff</span>) + (x &amp; <span class=\"number\">0x00ff00ff</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0x0000ffff</span>) + (x &amp; <span class=\"number\">0x0000ffff</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(str s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;s](i32 status) -&gt; <span class=\"keyword\">bool</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Veci <span class=\"built_in\">pos1</span>(&#123;&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i32 i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">13</span>; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (status &amp; (<span class=\"number\">1</span> &lt;&lt; i))</span><br><span class=\"line\">                    pos1.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos1.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i32 i = <span class=\"number\">0</span>, j = pos1.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[pos1[i]] != s[pos1[j]])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                ++i, --j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 预处理所有回文子串</span></span><br><span class=\"line\">        i32 sts = <span class=\"number\">1</span> &lt;&lt; s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        Veci checked;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i32 st = <span class=\"number\">1</span>; st &lt; sts; ++st)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(st))</span><br><span class=\"line\">                checked.<span class=\"built_in\">push_back</span>(st);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有回文字串求结果</span></span><br><span class=\"line\">        i32 ans = -Inf;</span><br><span class=\"line\">        i32 clen = checked.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i32 i = <span class=\"number\">0</span>; i &lt; clen; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i32 sti = checked[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i32 j = i + <span class=\"number\">1</span>; j &lt; clen; ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i32 stj = checked[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sti &amp; stj) == <span class=\"number\">0</span>) <span class=\"comment\">// 无重复</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ans = std::<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">countOnes</span>(sti) * <span class=\"built_in\">countOnes</span>(stj));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  注：本质是暴力遍历</p>\n</blockquote>\n<ul>\n<li>  TLE 的原因：一开始直接暴力二重循环，没预处理回文字符串，遍历了大量的垃圾状态</li>\n</ul>\n<p><strong>其他思路</strong></p>\n<p>dfs 两个子序列。对于位置 i ，两个子序列可以选择用或者不用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        string s1, s2;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(string &amp;s, string s1, string s2, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(s1) &amp;&amp; <span class=\"built_in\">check</span>(s2)) ans = <span class=\"built_in\">max</span>(ans, <span class=\"built_in\"><span class=\"keyword\">int</span></span>(s1.<span class=\"built_in\">size</span>() * s2.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index == s.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1 + s[index], s2, index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列s1使用该字符</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2 + s[index], index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列s2使用该字符</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2, index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列都不使用该字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(string &amp;s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[l++] != s[r--]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：ytmartian</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/dfsliang-ge-zi-xu-lie-by-ytmartian-svyn/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5870-每棵子树内缺失的最小基因值\"><a href=\"#T4-5870-每棵子树内缺失的最小基因值\" class=\"headerlink\" title=\"T4 5870. 每棵子树内缺失的最小基因值\"></a>T4 5870. 每棵子树内缺失的最小基因值</h2><ul>\n<li>  <strong>通过的用户数</strong>175</li>\n<li>  <strong>尝试过的用户数</strong>539</li>\n<li>  <strong>用户总通过次数</strong>213</li>\n<li>  <strong>用户总提交次数</strong>1154</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>有一棵根节点为 <code>0</code> 的 <strong>家族树</strong> ，总共包含 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是 <strong>根</strong> ，所以 <code>parents[0] == -1</code> 。</p>\n<p>总共有 <code>105</code> 个基因值，每个基因值都用 <strong>闭区间</strong> <code>[1, 105]</code> 中的一个整数表示。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是节点 <code>i</code> 的基因值，且基因值 <strong>互不相同</strong> 。</p>\n<p>请你返回一个数组 <code>ans</code> ，长度为 <code>n</code> ，其中 <code>ans[i]</code> 是以节点 <code>i</code> 为根的子树内 <strong>缺失</strong> 的 <strong>最小</strong> 基因值。</p>\n<p>节点 <code>x</code> 为根的 <strong>子树</strong> 包含节点 <code>x</code> 和它所有的 <strong>后代</strong> 节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/23/case-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,0,0,2], nums = [1,2,3,4]</span><br><span class=\"line\">输出：[5,1,1,1]</span><br><span class=\"line\">解释：每个子树答案计算结果如下：</span><br><span class=\"line\">- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。</span><br><span class=\"line\">- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/23/case-2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]</span><br><span class=\"line\">输出：[7,1,1,4,2,1]</span><br><span class=\"line\">解释：每个子树答案计算结果如下：</span><br><span class=\"line\">- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。</span><br><span class=\"line\">- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。</span><br><span class=\"line\">- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。</span><br><span class=\"line\">- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。</span><br><span class=\"line\">- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]</span><br><span class=\"line\">输出：[1,1,1,1,1,1,1]</span><br><span class=\"line\">解释：所有子树都缺失基因值 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == parents.length == nums.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  对于 <code>i != 0</code> ，满足 <code>0 &lt;= parents[i] &lt;= n - 1</code></li>\n<li>  <code>parents[0] == -1</code></li>\n<li>  <code>parents</code> 表示一棵合法的树。</li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n<li>  <code>nums[i]</code> 互不相同。</li>\n</ul>\n<p><strong>解法笔记</strong></p>\n<p><strong>解法一：启发式合并</strong><br>遍历整棵树，统计每棵子树包含的基因值集合以及缺失的最小基因值，记作 $\\textit{mex}$。合并基因值集合时，总是从小的往大的合并（类似并查集的按秩合并），同时更新当前子树的 $\\textit{mex}$ 的最大值。合并完成后再不断自增子树的 $\\textit{mex}$ 直至其不在基因值集合中。</p>\n<p>这一方法同时也适用于有相同基因值的情况。</p>\n<p>时间复杂度：$O(n\\log n)$。证明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(parents []<span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(parents)</span><br><span class=\"line\">\tg := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt; n; w++ &#123;</span><br><span class=\"line\">\t\tv := parents[w]</span><br><span class=\"line\">\t\tg[v] = <span class=\"built_in\">append</span>(g[v], w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmex := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">int</span>]<span class=\"title\">bool</span></span></span><br><span class=\"line\">\tf = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">int</span>]<span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\tset := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>&#123;&#125;</span><br><span class=\"line\">\t\tmex[v] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> g[v] &#123;</span><br><span class=\"line\">\t\t\ts := f(w)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 保证总是从小集合合并到大集合上</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &gt; <span class=\"built_in\">len</span>(set) &#123;</span><br><span class=\"line\">\t\t\t\tset, s = s, set</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\t\t\tset[x] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> mex[w] &gt; mex[v] &#123;</span><br><span class=\"line\">\t\t\t\tmex[v] = mex[w]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tset[nums[v]] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> set[mex[v]] &#123;</span><br><span class=\"line\">\t\t\tmex[v]++ <span class=\"comment\">// 不断自增 mex 直至其不在基因值集合中</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> set</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：endlesscheng</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<p><strong>解法二：利用无重复基因值的性质</strong><br>由于没有重复基因值，若存在节点 $x$，其基因值等于 $1$，则从 $x$ 到根的这一条链上的所有节点的 $\\textit{mex}$ 均超过 $1$，而其余节点的 $\\textit{mex}$ 值均为 $1$。我们顺着 $x$ 往根上走，同时收集当前子树的基因值到集合中，然后更新当前子树的 $\\textit{mex}$ 值。</p>\n<p>时间复杂度：$O(n)$。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(parents []<span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(parents)</span><br><span class=\"line\">\tg := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt; n; w++ &#123;</span><br><span class=\"line\">\t\tv := parents[w]</span><br><span class=\"line\">\t\tg[v] = <span class=\"built_in\">append</span>(g[v], w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmex := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> mex &#123;</span><br><span class=\"line\">\t\tmex[i] = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tset := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>&#123;&#125;</span><br><span class=\"line\">\tvis := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span></span><br><span class=\"line\">\tf = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tset[nums[v]] = <span class=\"literal\">true</span> <span class=\"comment\">// 收集基因值到 set 中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> g[v] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !vis[w] &#123;</span><br><span class=\"line\">\t\t\t\tf(w)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 找基因值等于 1 的节点 x</span></span><br><span class=\"line\">\tx := <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tx = i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// x 顺着父节点往上走</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> cur := <span class=\"number\">2</span>; x &gt;= <span class=\"number\">0</span>; x = parents[x] &#123;</span><br><span class=\"line\">\t\tf(x)</span><br><span class=\"line\">\t\tvis[x] = <span class=\"literal\">true</span> <span class=\"comment\">// 这是保证时间复杂度的关键：之后遍历父节点子树时，就无需再次遍历 x 子树了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> set[cur] &#123;</span><br><span class=\"line\">\t\t\tcur++ <span class=\"comment\">// 不断自增直至不在基因值集合中</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmex[x] = cur</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：endlesscheng</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<p><strong>不一样的思路：主席树+dfs序（突破值互不相同的限制）</strong></p>\n<ul>\n<li>  看到很多题解是从基因值互不相同的条件入手写的，后来突然发现我的解法不需要考虑这个</li>\n<li>  可能我的思路比较繁琐，时间复杂度有没有O(n)的优秀，固在此也只是想提供一个与众不同的思路罢了（勿喷）</li>\n<li>  前置知识：主席树，dfs序</li>\n<li>  注意到，这题的本质就是求mex，但不同的是，其不是真正的mex，最小的数是1，mex最小的数是0，但不影响做这题。</li>\n<li>  将问题转化一下，求一个区间的mex，可以线段树、主席树，这里使用主席树做方便</li>\n<li>主席树找mex的思路<ul>\n<li>  利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了</li>\n<li>  最终查询 <code>[L, R]</code> 区间的mex时，则是在版本 <code>R</code> 的权值线段树中找下标小于 <code>L</code> 的最小的数即可</li>\n</ul>\n</li>\n<li>  再来就是怎么将区间转化成树上查询，显然可以用到dfs序了</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pii</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">pii p[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> head[N], cnt, tim;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"built_in\">fill_n</span>(head, n + <span class=\"number\">5</span>, <span class=\"number\">-1</span>); cnt = <span class=\"number\">-1</span>; tim = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edges</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to, next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        to = t, next = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;edge[N &lt;&lt; <span class=\"number\">1</span>]; <span class=\"comment\">//无向图则需要乘2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">    edge[++cnt].<span class=\"built_in\">add</span>(v, head[u]);</span><br><span class=\"line\">    head[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[N], ram, root[N], vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; num)</span> </span>&#123;</span><br><span class=\"line\">    p[u].x = ++tim;</span><br><span class=\"line\">    a[tim] = num[u]; <span class=\"comment\">// 重置数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].next) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(edge[i].to, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p[u].y = tim;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nodes</span> &#123;</span><span class=\"keyword\">int</span> l, r, minv; &#125; hjt[N * <span class=\"number\">25</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> pre, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = ++ram;</span><br><span class=\"line\">    hjt[now] = hjt[pre];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">        hjt[now].minv = pos;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (val &lt;= mid) hjt[now].l = <span class=\"built_in\">modify</span>(hjt[now].l, l, mid, val, pos);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> hjt[now].r = <span class=\"built_in\">modify</span>(hjt[now].r, mid + <span class=\"number\">1</span>, r, val, pos);</span><br><span class=\"line\">    hjt[now].minv = <span class=\"built_in\">min</span>(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> tr, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hjt[hjt[tr].l].minv &lt; ql) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(hjt[tr].l, l, mid, ql);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(hjt[tr].r, mid + <span class=\"number\">1</span>, r, ql);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; pa, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = pa.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">init</span>(n);</span><br><span class=\"line\">        ram = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pa[i] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">add</span>(pa[i], i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, nums); <span class=\"comment\">// 预处理dfs序</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = *<span class=\"built_in\">max_element</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()) + <span class=\"number\">1</span>; <span class=\"comment\">// 找到最大值，记得+1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            root[i] = <span class=\"built_in\">modify</span>(root[i - <span class=\"number\">1</span>], <span class=\"number\">1</span>, len, a[i], i); <span class=\"comment\">// 主席树插入，注意此时用到的数组是a，不是nums了</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; p[i].x &lt;&lt; &#x27; &#x27; &lt;&lt; p[i].y &lt;&lt; endl;</span></span><br><span class=\"line\">            ans[i] = <span class=\"built_in\">query</span>(root[p[i].y], <span class=\"number\">1</span>, len, p[i].x);<span class=\"comment\">// 查询结点i的子树，意味在查询dfs序中区间[p[i].x, p[i].y]的答案</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：haoboy</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/zhu-xi-shu-dfsxu-tu-po-zhi-hu-bu-xiang-t-7nh8/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LeetCode 周赛 259","date":"2021-09-19T06:55:49.000Z","_content":"\n---\n\n# LeetCode 周赛 259\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-259/problems/final-value-of-variable-after-performing-operations/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-259/problems/sum-of-beauty-in-the-array/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-259/problems/detect-squares/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-259/problems/longest-subsequence-repeated-k-times/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1091 / 3774 | MiracleSNeko | 7    | 0:15:15  | 0:01:25                                                      | 0:15:15                                                      |                                                              |                                                              |\n\n\n\n## T1 5875. 执行操作后的变量值\n\n-   **通过的用户数**2937\n-   **尝试过的用户数**2956\n-   **用户总通过次数**2960\n-   **用户总提交次数**3107\n-   **题目难度** **Easy**\n\n存在一种仅支持 4 种操作和 1 个变量 `X` 的编程语言：\n\n-   `++X` 和 `X++` 使变量 `X` 的值 **加** `1`\n-   `--X` 和 `X--` 使变量 `X` 的值 **减** `1`\n\n最初，`X` 的值是 `0`\n\n给你一个字符串数组 `operations` ，这是由操作组成的一个列表，返回执行所有操作后， `X` 的 **最终值** 。\n\n**示例 1：**\n\n```\n输入：operations = [\"--X\",\"X++\",\"X++\"]\n输出：1\n解释：操作按下述步骤执行：\n最初，X = 0\n--X：X 减 1 ，X =  0 - 1 = -1\nX++：X 加 1 ，X = -1 + 1 =  0\nX++：X 加 1 ，X =  0 + 1 =  1\n```\n\n**示例 2：**\n\n```\n输入：operations = [\"++X\",\"++X\",\"X++\"]\n输出：3\n解释：操作按下述步骤执行： \n最初，X = 0\n++X：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\nX++：X 加 1 ，X = 2 + 1 = 3\n```\n\n**示例 3：**\n\n```\n输入：operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\n输出：0\n解释：操作按下述步骤执行：\n最初，X = 0\nX++：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\n--X：X 减 1 ，X = 2 - 1 = 1\nX--：X 减 1 ，X = 1 - 1 = 0\n```\n\n**提示：**\n\n-   `1 <= operations.length <= 100`\n-   `operations[i]` 将会是 `\"++X\"`、`\"X++\"`、`\"--X\"` 或 `\"X--\"`\n\n**我的提交：**\n\n```c++\nclass Solution\n{\npublic:\n    int finalValueAfterOperations(Vec<str> &operations)\n    {\n        auto ans = 0;\n        for(auto op: operations)\n        {\n            if (op == \"++X\" || op == \"X++\") ans++;\n            else ans--;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T2 5876. 数组美丽值求和\n\n-   **通过的用户数**2050\n-   **尝试过的用户数**2749\n-   **用户总通过次数**2088\n-   **用户总提交次数**6951\n-   **题目难度** **Medium**\n\n给你一个下标从 **0** 开始的整数数组 `nums` 。对于每个下标 `i`（`1 <= i <= nums.length - 2`），`nums[i]` 的 **美丽值** 等于：\n\n-   `2`，对于所有 `0 <= j < i` 且 `i < k <= nums.length - 1` ，满足 `nums[j] < nums[i] < nums[k]`\n-   `1`，如果满足 `nums[i - 1] < nums[i] < nums[i + 1]` ，且不满足前面的条件\n-   `0`，如果上述条件全部不满足\n\n返回符合 `1 <= i <= nums.length - 2` 的所有 `nums[i]` 的 **美丽值的总和** 。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：2\n解释：对于每个符合范围 1 <= i <= 1 的下标 i :\n- nums[1] 的美丽值等于 2\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,4,6,4]\n输出：1\n解释：对于每个符合范围 1 <= i <= 2 的下标 i :\n- nums[1] 的美丽值等于 1\n- nums[2] 的美丽值等于 0\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1]\n输出：0\n解释：对于每个符合范围 1 <= i <= 1 的下标 i :\n- nums[1] 的美丽值等于 0\n```\n\n**提示：**\n\n-   `3 <= nums.length <= 105`\n-   `1 <= nums[i] <= 105`\n\n**我的提交：**\n\n>   预处理前后最值\n\n```c++\nclass Solution\n{\npublic:\n    int sumOfBeauties(Veci &nums)\n    {\n        auto len = nums.size();\n        Veci leftmax(len, INT_MIN), rightmin(len, INT_MAX);\n        leftmax[1] = nums[0], rightmin[len - 2] = nums[len - 1];\n        FORINC(i, 2, len)\n        {\n            leftmax[i] = std::max(leftmax[i - 1], nums[i - 1]);\n            rightmin[len - i - 1] = std::min(rightmin[len - i], nums[len - i]);\n        }\n        auto ans = 0;\n        FORINC(i, 1, len - 1)\n        {\n            if (leftmax[i] < nums[i] && nums[i] < rightmin[i])\n                ans += 2;\n            else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1])\n                ans += 1;\n            else\n                continue;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T3 5877. 检测正方形\n\n-   **通过的用户数**952\n-   **尝试过的用户数**1535\n-   **用户总通过次数**988\n-   **用户总提交次数**4100\n-   **题目难度** **Medium**\n\n给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：\n\n-   **添加** 一个在数据流中的新点到某个数据结构中**。**可以添加 **重复** 的点，并会视作不同的点进行处理。\n-   给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 **面积为正** 的 **轴对齐正方形** ，**统计** 满足该要求的方案数目**。**\n\n**轴对齐正方形** 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。\n\n实现 `DetectSquares` 类：\n\n-   `DetectSquares()` 使用空数据结构初始化对象\n-   `void add(int[] point)` 向数据结构添加一个新的点 `point = [x, y]`\n-   `int count(int[] point)` 统计按上述方式与点 `point = [x, y]` 共同构造 **轴对齐正方形** 的方案数。\n\n**示例：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/01/image.png)\n\n```\n输入：\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n输出：\n[null, null, null, null, 1, 0, null, 2]\n\n解释：\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // 返回 1 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\ndetectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。\ndetectSquares.add([11, 2]);    // 允许添加重复的点。\ndetectSquares.count([11, 10]); // 返回 2 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\n                               //   - 第一个，第三个，和第四个点\n```\n\n**提示：**\n\n-   `point.length == 2`\n-   `0 <= x, y <= 1000`\n-   调用 `add` 和 `count` 的 **总次数** 最多为 `5000`\n\n**题解：**\n\n定位正方形时可通过枚举对角线进行，确定能否构成正方形只需要一个点。因为只有 `1000` 个点，所以可以直接开一个静态数组。\n\n>   周赛的时候写了一堆 `std::map` ，没想到静态数组和一点定正方形，跑去算了半天对角线长度，欢声笑语中打出 GG\n\n```c++\nclass DetectSquares\n{\npublic:\n    DetectSquares()\n    {\n        std::ios::sync_with_stdio(false);\n        memset(points, 0, sizeof(int) * 1001 * 1001);\n    }\n    void add(std::vector<int> point)\n    {\n        points[point[0]][point[1]] += 1;\n    }\n    int count(std::vector<int> point)\n    {\n        int x = point[0], y = point[1], ans = 0;\n        for (int ny = 0; ny < 1001; ++ny)\n        {\n            if (points[x][ny] == 0 || ny == y)\n                continue;\n            auto d = ny - y;\n            if ( x + d >= 0 && x + d < 1001)\n            {\n                ans += points[x + d][y] * points[x + d][ny] * points[x][ny];\n            }\n            if ( x - d >= 0 && x - d < 1001)\n            {\n                ans += points[x - d][y] * points[x - d][ny] * points[x][ny];\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    int points[1001][1001];\n};\n```\n\n\n\n## T4 5878. 重复 K 次的最长子序列\n\n-   **通过的用户数**111\n-   **尝试过的用户数**186\n-   **用户总通过次数**149\n-   **用户总提交次数**567\n-   **题目难度** **Hard**\n\n给你一个长度为 `n` 的字符串 `s` ，和一个整数 `k` 。请你找出字符串 `s` 中 **重复** `k` 次的 **最长子序列** 。\n\n**子序列** 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。\n\n如果 `seq * k` 是 `s` 的一个子序列，其中 `seq * k` 表示一个由 `seq` 串联 `k` 次构造的字符串，那么就称 `seq` 是字符串 `s` 中一个 **重复 `k` 次** 的子序列。\n\n-   举个例子，`\"bba\"` 是字符串 `\"bababcba\"` 中的一个重复 `2` 次的子序列，因为字符串 `\"bbabba\"` 是由 `\"bba\"` 串联 `2` 次构造的，而 `\"bbabba\"` 是字符串 `\"bababcba\"` 的一个子序列。\n\n返回字符串 `s` 中 **重复 k 次的最长子序列** 。如果存在多个满足的子序列，则返回 **字典序最大** 的那个。如果不存在这样的子序列，返回一个 **空** 字符串。\n\n**示例 1：**\n\n![example 1](https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png)\n\n```\n输入：s = \"letsleetcode\", k = 2\n输出：\"let\"\n解释：存在两个最长子序列重复 2 次：let\" 和 \"ete\" 。\n\"let\" 是其中字典序最大的一个。\n```\n\n**示例 2：**\n\n```\n输入：s = \"bb\", k = 2\n输出：\"b\"\n解释：重复 2 次的最长子序列是 \"b\" 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"ab\", k = 2\n输出：\"\"\n解释：不存在重复 2 次的最长子序列。返回空字符串。\n```\n\n**示例 4：**\n\n```\n输入：s = \"bbabbabbbbabaababab\", k = 3\n输出：\"bbbb\"\n解释：在 \"bbabbabbbbabaababab\" 中重复 3 次的最长子序列是 \"bbbb\" 。\n```\n\n**提示：**\n\n-   `n == s.length`\n-   `2 <= k <= 2000`\n-   `2 <= n < k * 8`\n-   `s` 由小写英文字母组成\n\n**题解：**\n\n题目所给数据实际上隐含了一条信息：子序列长度不会超过 8，所以对长度为 1 到 7 的全部子序列依次验证即可。\n\n>   纯暴力，C++ 似乎也可以通过全排列函数求解\n\n```c++\nbool check(string &a, string &b, int k){//检测b能否在a中出现k次\n    int cnt = 0;\n    for(int i = 0, j = 0; i < a.size(); i++){\n        if(a[i]==b[j]){\n            j++;\n            if(j==b.size()){\n                j = 0, cnt++;\n                if(cnt==k) return true; \n            }\n        }\n    }\n    return false;\n}\nstring longestSubsequenceRepeatedK(string s, int k) {\n    //易知：子序列长度最多为7 故而可以暴力找出长度为7以内的序列作为要找的子序列 依次验证即可\n    \n    //若对于长度为len的符合条件的子序列 则它一定是由长度为len-1的序列通过添加一个字母生成的\n    //故而递推生成所有可能的子序列即可 然后验证是否符合条件 加入答案数组 最后返回最大的即可\n    vector<string> ans[8];//ans[i]表示长度为i的符合条件的字符串\n    ans[0].push_back(\"\");\n    int i = 1;\n    for( ; i < 8; i++){\n        for(auto v : ans[i-1]){\n            for(char j = 'a'; j <= 'z'; j++){\n                string t = v + j;\n                if(check(s,t,k)) ans[i].push_back(t);\n            }\n        }\n        if(ans[i].empty()) break;\n    }\n    i--;\n    sort(ans[i].begin(),ans[i].end());\n    return ans[i].back();\n}\n\n作者：zeroac\n链接：https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/c-bao-li-mei-ju-chang-du-7yi-nei-xu-lie-febao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","source":"_posts/weekly-contest-259.md","raw":"---\ntitle: LeetCode 周赛 259\ndate: 2021-09-19 14:55:49\ntags: LeetCode 周赛总结\n---\n\n---\n\n# LeetCode 周赛 259\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-259/problems/final-value-of-variable-after-performing-operations/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-259/problems/sum-of-beauty-in-the-array/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-259/problems/detect-squares/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-259/problems/longest-subsequence-repeated-k-times/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1091 / 3774 | MiracleSNeko | 7    | 0:15:15  | 0:01:25                                                      | 0:15:15                                                      |                                                              |                                                              |\n\n\n\n## T1 5875. 执行操作后的变量值\n\n-   **通过的用户数**2937\n-   **尝试过的用户数**2956\n-   **用户总通过次数**2960\n-   **用户总提交次数**3107\n-   **题目难度** **Easy**\n\n存在一种仅支持 4 种操作和 1 个变量 `X` 的编程语言：\n\n-   `++X` 和 `X++` 使变量 `X` 的值 **加** `1`\n-   `--X` 和 `X--` 使变量 `X` 的值 **减** `1`\n\n最初，`X` 的值是 `0`\n\n给你一个字符串数组 `operations` ，这是由操作组成的一个列表，返回执行所有操作后， `X` 的 **最终值** 。\n\n**示例 1：**\n\n```\n输入：operations = [\"--X\",\"X++\",\"X++\"]\n输出：1\n解释：操作按下述步骤执行：\n最初，X = 0\n--X：X 减 1 ，X =  0 - 1 = -1\nX++：X 加 1 ，X = -1 + 1 =  0\nX++：X 加 1 ，X =  0 + 1 =  1\n```\n\n**示例 2：**\n\n```\n输入：operations = [\"++X\",\"++X\",\"X++\"]\n输出：3\n解释：操作按下述步骤执行： \n最初，X = 0\n++X：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\nX++：X 加 1 ，X = 2 + 1 = 3\n```\n\n**示例 3：**\n\n```\n输入：operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\n输出：0\n解释：操作按下述步骤执行：\n最初，X = 0\nX++：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\n--X：X 减 1 ，X = 2 - 1 = 1\nX--：X 减 1 ，X = 1 - 1 = 0\n```\n\n**提示：**\n\n-   `1 <= operations.length <= 100`\n-   `operations[i]` 将会是 `\"++X\"`、`\"X++\"`、`\"--X\"` 或 `\"X--\"`\n\n**我的提交：**\n\n```c++\nclass Solution\n{\npublic:\n    int finalValueAfterOperations(Vec<str> &operations)\n    {\n        auto ans = 0;\n        for(auto op: operations)\n        {\n            if (op == \"++X\" || op == \"X++\") ans++;\n            else ans--;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T2 5876. 数组美丽值求和\n\n-   **通过的用户数**2050\n-   **尝试过的用户数**2749\n-   **用户总通过次数**2088\n-   **用户总提交次数**6951\n-   **题目难度** **Medium**\n\n给你一个下标从 **0** 开始的整数数组 `nums` 。对于每个下标 `i`（`1 <= i <= nums.length - 2`），`nums[i]` 的 **美丽值** 等于：\n\n-   `2`，对于所有 `0 <= j < i` 且 `i < k <= nums.length - 1` ，满足 `nums[j] < nums[i] < nums[k]`\n-   `1`，如果满足 `nums[i - 1] < nums[i] < nums[i + 1]` ，且不满足前面的条件\n-   `0`，如果上述条件全部不满足\n\n返回符合 `1 <= i <= nums.length - 2` 的所有 `nums[i]` 的 **美丽值的总和** 。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：2\n解释：对于每个符合范围 1 <= i <= 1 的下标 i :\n- nums[1] 的美丽值等于 2\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,4,6,4]\n输出：1\n解释：对于每个符合范围 1 <= i <= 2 的下标 i :\n- nums[1] 的美丽值等于 1\n- nums[2] 的美丽值等于 0\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1]\n输出：0\n解释：对于每个符合范围 1 <= i <= 1 的下标 i :\n- nums[1] 的美丽值等于 0\n```\n\n**提示：**\n\n-   `3 <= nums.length <= 105`\n-   `1 <= nums[i] <= 105`\n\n**我的提交：**\n\n>   预处理前后最值\n\n```c++\nclass Solution\n{\npublic:\n    int sumOfBeauties(Veci &nums)\n    {\n        auto len = nums.size();\n        Veci leftmax(len, INT_MIN), rightmin(len, INT_MAX);\n        leftmax[1] = nums[0], rightmin[len - 2] = nums[len - 1];\n        FORINC(i, 2, len)\n        {\n            leftmax[i] = std::max(leftmax[i - 1], nums[i - 1]);\n            rightmin[len - i - 1] = std::min(rightmin[len - i], nums[len - i]);\n        }\n        auto ans = 0;\n        FORINC(i, 1, len - 1)\n        {\n            if (leftmax[i] < nums[i] && nums[i] < rightmin[i])\n                ans += 2;\n            else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1])\n                ans += 1;\n            else\n                continue;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T3 5877. 检测正方形\n\n-   **通过的用户数**952\n-   **尝试过的用户数**1535\n-   **用户总通过次数**988\n-   **用户总提交次数**4100\n-   **题目难度** **Medium**\n\n给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：\n\n-   **添加** 一个在数据流中的新点到某个数据结构中**。**可以添加 **重复** 的点，并会视作不同的点进行处理。\n-   给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 **面积为正** 的 **轴对齐正方形** ，**统计** 满足该要求的方案数目**。**\n\n**轴对齐正方形** 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。\n\n实现 `DetectSquares` 类：\n\n-   `DetectSquares()` 使用空数据结构初始化对象\n-   `void add(int[] point)` 向数据结构添加一个新的点 `point = [x, y]`\n-   `int count(int[] point)` 统计按上述方式与点 `point = [x, y]` 共同构造 **轴对齐正方形** 的方案数。\n\n**示例：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/01/image.png)\n\n```\n输入：\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n输出：\n[null, null, null, null, 1, 0, null, 2]\n\n解释：\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // 返回 1 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\ndetectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。\ndetectSquares.add([11, 2]);    // 允许添加重复的点。\ndetectSquares.count([11, 10]); // 返回 2 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\n                               //   - 第一个，第三个，和第四个点\n```\n\n**提示：**\n\n-   `point.length == 2`\n-   `0 <= x, y <= 1000`\n-   调用 `add` 和 `count` 的 **总次数** 最多为 `5000`\n\n**题解：**\n\n定位正方形时可通过枚举对角线进行，确定能否构成正方形只需要一个点。因为只有 `1000` 个点，所以可以直接开一个静态数组。\n\n>   周赛的时候写了一堆 `std::map` ，没想到静态数组和一点定正方形，跑去算了半天对角线长度，欢声笑语中打出 GG\n\n```c++\nclass DetectSquares\n{\npublic:\n    DetectSquares()\n    {\n        std::ios::sync_with_stdio(false);\n        memset(points, 0, sizeof(int) * 1001 * 1001);\n    }\n    void add(std::vector<int> point)\n    {\n        points[point[0]][point[1]] += 1;\n    }\n    int count(std::vector<int> point)\n    {\n        int x = point[0], y = point[1], ans = 0;\n        for (int ny = 0; ny < 1001; ++ny)\n        {\n            if (points[x][ny] == 0 || ny == y)\n                continue;\n            auto d = ny - y;\n            if ( x + d >= 0 && x + d < 1001)\n            {\n                ans += points[x + d][y] * points[x + d][ny] * points[x][ny];\n            }\n            if ( x - d >= 0 && x - d < 1001)\n            {\n                ans += points[x - d][y] * points[x - d][ny] * points[x][ny];\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    int points[1001][1001];\n};\n```\n\n\n\n## T4 5878. 重复 K 次的最长子序列\n\n-   **通过的用户数**111\n-   **尝试过的用户数**186\n-   **用户总通过次数**149\n-   **用户总提交次数**567\n-   **题目难度** **Hard**\n\n给你一个长度为 `n` 的字符串 `s` ，和一个整数 `k` 。请你找出字符串 `s` 中 **重复** `k` 次的 **最长子序列** 。\n\n**子序列** 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。\n\n如果 `seq * k` 是 `s` 的一个子序列，其中 `seq * k` 表示一个由 `seq` 串联 `k` 次构造的字符串，那么就称 `seq` 是字符串 `s` 中一个 **重复 `k` 次** 的子序列。\n\n-   举个例子，`\"bba\"` 是字符串 `\"bababcba\"` 中的一个重复 `2` 次的子序列，因为字符串 `\"bbabba\"` 是由 `\"bba\"` 串联 `2` 次构造的，而 `\"bbabba\"` 是字符串 `\"bababcba\"` 的一个子序列。\n\n返回字符串 `s` 中 **重复 k 次的最长子序列** 。如果存在多个满足的子序列，则返回 **字典序最大** 的那个。如果不存在这样的子序列，返回一个 **空** 字符串。\n\n**示例 1：**\n\n![example 1](https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png)\n\n```\n输入：s = \"letsleetcode\", k = 2\n输出：\"let\"\n解释：存在两个最长子序列重复 2 次：let\" 和 \"ete\" 。\n\"let\" 是其中字典序最大的一个。\n```\n\n**示例 2：**\n\n```\n输入：s = \"bb\", k = 2\n输出：\"b\"\n解释：重复 2 次的最长子序列是 \"b\" 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"ab\", k = 2\n输出：\"\"\n解释：不存在重复 2 次的最长子序列。返回空字符串。\n```\n\n**示例 4：**\n\n```\n输入：s = \"bbabbabbbbabaababab\", k = 3\n输出：\"bbbb\"\n解释：在 \"bbabbabbbbabaababab\" 中重复 3 次的最长子序列是 \"bbbb\" 。\n```\n\n**提示：**\n\n-   `n == s.length`\n-   `2 <= k <= 2000`\n-   `2 <= n < k * 8`\n-   `s` 由小写英文字母组成\n\n**题解：**\n\n题目所给数据实际上隐含了一条信息：子序列长度不会超过 8，所以对长度为 1 到 7 的全部子序列依次验证即可。\n\n>   纯暴力，C++ 似乎也可以通过全排列函数求解\n\n```c++\nbool check(string &a, string &b, int k){//检测b能否在a中出现k次\n    int cnt = 0;\n    for(int i = 0, j = 0; i < a.size(); i++){\n        if(a[i]==b[j]){\n            j++;\n            if(j==b.size()){\n                j = 0, cnt++;\n                if(cnt==k) return true; \n            }\n        }\n    }\n    return false;\n}\nstring longestSubsequenceRepeatedK(string s, int k) {\n    //易知：子序列长度最多为7 故而可以暴力找出长度为7以内的序列作为要找的子序列 依次验证即可\n    \n    //若对于长度为len的符合条件的子序列 则它一定是由长度为len-1的序列通过添加一个字母生成的\n    //故而递推生成所有可能的子序列即可 然后验证是否符合条件 加入答案数组 最后返回最大的即可\n    vector<string> ans[8];//ans[i]表示长度为i的符合条件的字符串\n    ans[0].push_back(\"\");\n    int i = 1;\n    for( ; i < 8; i++){\n        for(auto v : ans[i-1]){\n            for(char j = 'a'; j <= 'z'; j++){\n                string t = v + j;\n                if(check(s,t,k)) ans[i].push_back(t);\n            }\n        }\n        if(ans[i].empty()) break;\n    }\n    i--;\n    sort(ans[i].begin(),ans[i].end());\n    return ans[i].back();\n}\n\n作者：zeroac\n链接：https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/c-bao-li-mei-ju-chang-du-7yi-nei-xu-lie-febao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","slug":"weekly-contest-259","published":1,"updated":"2021-10-07T13:05:47.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckugyov2m0005kbgdgg2b4tcb","content":"<hr>\n<h1 id=\"LeetCode-周赛-259\"><a href=\"#LeetCode-周赛-259\" class=\"headerlink\" title=\"LeetCode 周赛 259\"></a>LeetCode 周赛 259</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/final-value-of-variable-after-performing-operations/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/sum-of-beauty-in-the-array/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/detect-squares/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/longest-subsequence-repeated-k-times/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1091 / 3774</td>\n<td>MiracleSNeko</td>\n<td>7</td>\n<td>0:15:15</td>\n<td>0:01:25</td>\n<td>0:15:15</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5875-执行操作后的变量值\"><a href=\"#T1-5875-执行操作后的变量值\" class=\"headerlink\" title=\"T1 5875. 执行操作后的变量值\"></a>T1 5875. 执行操作后的变量值</h2><ul>\n<li>  <strong>通过的用户数</strong>2937</li>\n<li>  <strong>尝试过的用户数</strong>2956</li>\n<li>  <strong>用户总通过次数</strong>2960</li>\n<li>  <strong>用户总提交次数</strong>3107</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>存在一种仅支持 4 种操作和 1 个变量 <code>X</code> 的编程语言：</p>\n<ul>\n<li>  <code>++X</code> 和 <code>X++</code> 使变量 <code>X</code> 的值 <strong>加</strong> <code>1</code></li>\n<li>  <code>--X</code> 和 <code>X--</code> 使变量 <code>X</code> 的值 <strong>减</strong> <code>1</code></li>\n</ul>\n<p>最初，<code>X</code> 的值是 <code>0</code></p>\n<p>给你一个字符串数组 <code>operations</code> ，这是由操作组成的一个列表，返回执行所有操作后， <code>X</code> 的 <strong>最终值</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;--X&quot;,&quot;X++&quot;,&quot;X++&quot;]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：操作按下述步骤执行：</span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">--X：X 减 1 ，X =  0 - 1 = -1</span><br><span class=\"line\">X++：X 加 1 ，X = -1 + 1 =  0</span><br><span class=\"line\">X++：X 加 1 ，X =  0 + 1 =  1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;++X&quot;,&quot;++X&quot;,&quot;X++&quot;]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：操作按下述步骤执行： </span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">++X：X 加 1 ，X = 0 + 1 = 1</span><br><span class=\"line\">++X：X 加 1 ，X = 1 + 1 = 2</span><br><span class=\"line\">X++：X 加 1 ，X = 2 + 1 = 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;X++&quot;,&quot;++X&quot;,&quot;--X&quot;,&quot;X--&quot;]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：操作按下述步骤执行：</span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">X++：X 加 1 ，X = 0 + 1 = 1</span><br><span class=\"line\">++X：X 加 1 ，X = 1 + 1 = 2</span><br><span class=\"line\">--X：X 减 1 ，X = 2 - 1 = 1</span><br><span class=\"line\">X--：X 减 1 ，X = 1 - 1 = 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= operations.length &lt;= 100</code></li>\n<li>  <code>operations[i]</code> 将会是 <code>&quot;++X&quot;</code>、<code>&quot;X++&quot;</code>、<code>&quot;--X&quot;</code> 或 <code>&quot;X--&quot;</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">finalValueAfterOperations</span><span class=\"params\">(Vec&lt;str&gt; &amp;operations)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op: operations)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (op == <span class=\"string\">&quot;++X&quot;</span> || op == <span class=\"string\">&quot;X++&quot;</span>) ans++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ans--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5876-数组美丽值求和\"><a href=\"#T2-5876-数组美丽值求和\" class=\"headerlink\" title=\"T2 5876. 数组美丽值求和\"></a>T2 5876. 数组美丽值求和</h2><ul>\n<li>  <strong>通过的用户数</strong>2050</li>\n<li>  <strong>尝试过的用户数</strong>2749</li>\n<li>  <strong>用户总通过次数</strong>2088</li>\n<li>  <strong>用户总提交次数</strong>6951</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。对于每个下标 <code>i</code>（<code>1 &lt;= i &lt;= nums.length - 2</code>），<code>nums[i]</code> 的 <strong>美丽值</strong> 等于：</p>\n<ul>\n<li>  <code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code> ，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li>\n<li>  <code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code> ，且不满足前面的条件</li>\n<li>  <code>0</code>，如果上述条件全部不满足</li>\n</ul>\n<p>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有 <code>nums[i]</code> 的 <strong>美丽值的总和</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,4,6,4]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 2 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 1</span><br><span class=\"line\">- nums[2] 的美丽值等于 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>3 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  预处理前后最值</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfBeauties</span><span class=\"params\">(Veci &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">Veci <span class=\"title\">leftmax</span><span class=\"params\">(len, INT_MIN)</span>, <span class=\"title\">rightmin</span><span class=\"params\">(len, INT_MAX)</span></span>;</span><br><span class=\"line\">        leftmax[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>], rightmin[len - <span class=\"number\">2</span>] = nums[len - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(i, <span class=\"number\">2</span>, len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            leftmax[i] = std::<span class=\"built_in\">max</span>(leftmax[i - <span class=\"number\">1</span>], nums[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            rightmin[len - i - <span class=\"number\">1</span>] = std::<span class=\"built_in\">min</span>(rightmin[len - i], nums[len - i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(i, <span class=\"number\">1</span>, len - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftmax[i] &lt; nums[i] &amp;&amp; nums[i] &lt; rightmin[i])</span><br><span class=\"line\">                ans += <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] &lt; nums[i] &amp;&amp; nums[i] &lt; nums[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">                ans += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-5877-检测正方形\"><a href=\"#T3-5877-检测正方形\" class=\"headerlink\" title=\"T3 5877. 检测正方形\"></a>T3 5877. 检测正方形</h2><ul>\n<li>  <strong>通过的用户数</strong>952</li>\n<li>  <strong>尝试过的用户数</strong>1535</li>\n<li>  <strong>用户总通过次数</strong>988</li>\n<li>  <strong>用户总提交次数</strong>4100</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：</p>\n<ul>\n<li>  <strong>添加</strong> 一个在数据流中的新点到某个数据结构中<strong>。</strong>可以添加 <strong>重复</strong> 的点，并会视作不同的点进行处理。</li>\n<li>  给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 <strong>面积为正</strong> 的 <strong>轴对齐正方形</strong> ，<strong>统计</strong> 满足该要求的方案数目<strong>。</strong></li>\n</ul>\n<p><strong>轴对齐正方形</strong> 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</p>\n<p>实现 <code>DetectSquares</code> 类：</p>\n<ul>\n<li>  <code>DetectSquares()</code> 使用空数据结构初始化对象</li>\n<li>  <code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]</code></li>\n<li>  <code>int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 <strong>轴对齐正方形</strong> 的方案数。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/01/image.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;DetectSquares&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]</span><br><span class=\"line\">[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, null, 1, 0, null, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">DetectSquares detectSquares = new DetectSquares();</span><br><span class=\"line\">detectSquares.add([3, 10]);</span><br><span class=\"line\">detectSquares.add([11, 2]);</span><br><span class=\"line\">detectSquares.add([3, 2]);</span><br><span class=\"line\">detectSquares.count([11, 10]); // 返回 1 。你可以选择：</span><br><span class=\"line\">                               //   - 第一个，第二个，和第三个点</span><br><span class=\"line\">detectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。</span><br><span class=\"line\">detectSquares.add([11, 2]);    // 允许添加重复的点。</span><br><span class=\"line\">detectSquares.count([11, 10]); // 返回 2 。你可以选择：</span><br><span class=\"line\">                               //   - 第一个，第二个，和第三个点</span><br><span class=\"line\">                               //   - 第一个，第三个，和第四个点</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>point.length == 2</code></li>\n<li>  <code>0 &lt;= x, y &lt;= 1000</code></li>\n<li>  调用 <code>add</code> 和 <code>count</code> 的 <strong>总次数</strong> 最多为 <code>5000</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>定位正方形时可通过枚举对角线进行，确定能否构成正方形只需要一个点。因为只有 <code>1000</code> 个点，所以可以直接开一个静态数组。</p>\n<blockquote>\n<p>  周赛的时候写了一堆 <code>std::map</code> ，没想到静态数组和一点定正方形，跑去算了半天对角线长度，欢声笑语中打出 GG</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DetectSquares</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">DetectSquares</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(points, <span class=\"number\">0</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>) * <span class=\"number\">1001</span> * <span class=\"number\">1001</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; point)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        points[point[<span class=\"number\">0</span>]][point[<span class=\"number\">1</span>]] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; point)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = point[<span class=\"number\">0</span>], y = point[<span class=\"number\">1</span>], ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> ny = <span class=\"number\">0</span>; ny &lt; <span class=\"number\">1001</span>; ++ny)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (points[x][ny] == <span class=\"number\">0</span> || ny == y)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> d = ny - y;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( x + d &gt;= <span class=\"number\">0</span> &amp;&amp; x + d &lt; <span class=\"number\">1001</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += points[x + d][y] * points[x + d][ny] * points[x][ny];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( x - d &gt;= <span class=\"number\">0</span> &amp;&amp; x - d &lt; <span class=\"number\">1001</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += points[x - d][y] * points[x - d][ny] * points[x][ny];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> points[<span class=\"number\">1001</span>][<span class=\"number\">1001</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5878-重复-K-次的最长子序列\"><a href=\"#T4-5878-重复-K-次的最长子序列\" class=\"headerlink\" title=\"T4 5878. 重复 K 次的最长子序列\"></a>T4 5878. 重复 K 次的最长子序列</h2><ul>\n<li>  <strong>通过的用户数</strong>111</li>\n<li>  <strong>尝试过的用户数</strong>186</li>\n<li>  <strong>用户总通过次数</strong>149</li>\n<li>  <strong>用户总提交次数</strong>567</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个长度为 <code>n</code> 的字符串 <code>s</code> ，和一个整数 <code>k</code> 。请你找出字符串 <code>s</code> 中 <strong>重复</strong> <code>k</code> 次的 <strong>最长子序列</strong> 。</p>\n<p><strong>子序列</strong> 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p>\n<p>如果 <code>seq * k</code> 是 <code>s</code> 的一个子序列，其中 <code>seq * k</code> 表示一个由 <code>seq</code> 串联 <code>k</code> 次构造的字符串，那么就称 <code>seq</code> 是字符串 <code>s</code> 中一个 <strong>重复 <code>k</code> 次</strong> 的子序列。</p>\n<ul>\n<li>  举个例子，<code>&quot;bba&quot;</code> 是字符串 <code>&quot;bababcba&quot;</code> 中的一个重复 <code>2</code> 次的子序列，因为字符串 <code>&quot;bbabba&quot;</code> 是由 <code>&quot;bba&quot;</code> 串联 <code>2</code> 次构造的，而 <code>&quot;bbabba&quot;</code> 是字符串 <code>&quot;bababcba&quot;</code> 的一个子序列。</li>\n</ul>\n<p>返回字符串 <code>s</code> 中 <strong>重复 k 次的最长子序列</strong> 。如果存在多个满足的子序列，则返回 <strong>字典序最大</strong> 的那个。如果不存在这样的子序列，返回一个 <strong>空</strong> 字符串。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png\" alt=\"example 1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;letsleetcode&quot;, k = 2</span><br><span class=\"line\">输出：&quot;let&quot;</span><br><span class=\"line\">解释：存在两个最长子序列重复 2 次：let&quot; 和 &quot;ete&quot; 。</span><br><span class=\"line\">&quot;let&quot; 是其中字典序最大的一个。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bb&quot;, k = 2</span><br><span class=\"line\">输出：&quot;b&quot;</span><br><span class=\"line\">解释：重复 2 次的最长子序列是 &quot;b&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ab&quot;, k = 2</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：不存在重复 2 次的最长子序列。返回空字符串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bbabbabbbbabaababab&quot;, k = 3</span><br><span class=\"line\">输出：&quot;bbbb&quot;</span><br><span class=\"line\">解释：在 &quot;bbabbabbbbabaababab&quot; 中重复 3 次的最长子序列是 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == s.length</code></li>\n<li>  <code>2 &lt;= k &lt;= 2000</code></li>\n<li>  <code>2 &lt;= n &lt; k * 8</code></li>\n<li>  <code>s</code> 由小写英文字母组成</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>题目所给数据实际上隐含了一条信息：子序列长度不会超过 8，所以对长度为 1 到 7 的全部子序列依次验证即可。</p>\n<blockquote>\n<p>  纯暴力，C++ 似乎也可以通过全排列函数求解</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(string &amp;a, string &amp;b, <span class=\"keyword\">int</span> k)</span></span>&#123;<span class=\"comment\">//检测b能否在a中出现k次</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; a.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]==b[j])&#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j==b.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>, cnt++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cnt==k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">longestSubsequenceRepeatedK</span><span class=\"params\">(string s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//易知：子序列长度最多为7 故而可以暴力找出长度为7以内的序列作为要找的子序列 依次验证即可</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//若对于长度为len的符合条件的子序列 则它一定是由长度为len-1的序列通过添加一个字母生成的</span></span><br><span class=\"line\">    <span class=\"comment\">//故而递推生成所有可能的子序列即可 然后验证是否符合条件 加入答案数组 最后返回最大的即可</span></span><br><span class=\"line\">    vector&lt;string&gt; ans[<span class=\"number\">8</span>];<span class=\"comment\">//ans[i]表示长度为i的符合条件的字符串</span></span><br><span class=\"line\">    ans[<span class=\"number\">0</span>].<span class=\"built_in\">push_back</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; i &lt; <span class=\"number\">8</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> v : ans[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> j = <span class=\"string\">&#x27;a&#x27;</span>; j &lt;= <span class=\"string\">&#x27;z&#x27;</span>; j++)&#123;</span><br><span class=\"line\">                string t = v + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(s,t,k)) ans[i].<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans[i].<span class=\"built_in\">empty</span>()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(ans[i].<span class=\"built_in\">begin</span>(),ans[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[i].<span class=\"built_in\">back</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：zeroac</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/c-bao-li-mei-ju-chang-du-7yi-nei-xu-lie-febao/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-259\"><a href=\"#LeetCode-周赛-259\" class=\"headerlink\" title=\"LeetCode 周赛 259\"></a>LeetCode 周赛 259</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/final-value-of-variable-after-performing-operations/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/sum-of-beauty-in-the-array/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/detect-squares/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/longest-subsequence-repeated-k-times/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1091 / 3774</td>\n<td>MiracleSNeko</td>\n<td>7</td>\n<td>0:15:15</td>\n<td>0:01:25</td>\n<td>0:15:15</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5875-执行操作后的变量值\"><a href=\"#T1-5875-执行操作后的变量值\" class=\"headerlink\" title=\"T1 5875. 执行操作后的变量值\"></a>T1 5875. 执行操作后的变量值</h2><ul>\n<li>  <strong>通过的用户数</strong>2937</li>\n<li>  <strong>尝试过的用户数</strong>2956</li>\n<li>  <strong>用户总通过次数</strong>2960</li>\n<li>  <strong>用户总提交次数</strong>3107</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>存在一种仅支持 4 种操作和 1 个变量 <code>X</code> 的编程语言：</p>\n<ul>\n<li>  <code>++X</code> 和 <code>X++</code> 使变量 <code>X</code> 的值 <strong>加</strong> <code>1</code></li>\n<li>  <code>--X</code> 和 <code>X--</code> 使变量 <code>X</code> 的值 <strong>减</strong> <code>1</code></li>\n</ul>\n<p>最初，<code>X</code> 的值是 <code>0</code></p>\n<p>给你一个字符串数组 <code>operations</code> ，这是由操作组成的一个列表，返回执行所有操作后， <code>X</code> 的 <strong>最终值</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;--X&quot;,&quot;X++&quot;,&quot;X++&quot;]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：操作按下述步骤执行：</span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">--X：X 减 1 ，X =  0 - 1 = -1</span><br><span class=\"line\">X++：X 加 1 ，X = -1 + 1 =  0</span><br><span class=\"line\">X++：X 加 1 ，X =  0 + 1 =  1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;++X&quot;,&quot;++X&quot;,&quot;X++&quot;]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：操作按下述步骤执行： </span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">++X：X 加 1 ，X = 0 + 1 = 1</span><br><span class=\"line\">++X：X 加 1 ，X = 1 + 1 = 2</span><br><span class=\"line\">X++：X 加 1 ，X = 2 + 1 = 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;X++&quot;,&quot;++X&quot;,&quot;--X&quot;,&quot;X--&quot;]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：操作按下述步骤执行：</span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">X++：X 加 1 ，X = 0 + 1 = 1</span><br><span class=\"line\">++X：X 加 1 ，X = 1 + 1 = 2</span><br><span class=\"line\">--X：X 减 1 ，X = 2 - 1 = 1</span><br><span class=\"line\">X--：X 减 1 ，X = 1 - 1 = 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= operations.length &lt;= 100</code></li>\n<li>  <code>operations[i]</code> 将会是 <code>&quot;++X&quot;</code>、<code>&quot;X++&quot;</code>、<code>&quot;--X&quot;</code> 或 <code>&quot;X--&quot;</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">finalValueAfterOperations</span><span class=\"params\">(Vec&lt;str&gt; &amp;operations)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op: operations)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (op == <span class=\"string\">&quot;++X&quot;</span> || op == <span class=\"string\">&quot;X++&quot;</span>) ans++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ans--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5876-数组美丽值求和\"><a href=\"#T2-5876-数组美丽值求和\" class=\"headerlink\" title=\"T2 5876. 数组美丽值求和\"></a>T2 5876. 数组美丽值求和</h2><ul>\n<li>  <strong>通过的用户数</strong>2050</li>\n<li>  <strong>尝试过的用户数</strong>2749</li>\n<li>  <strong>用户总通过次数</strong>2088</li>\n<li>  <strong>用户总提交次数</strong>6951</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。对于每个下标 <code>i</code>（<code>1 &lt;= i &lt;= nums.length - 2</code>），<code>nums[i]</code> 的 <strong>美丽值</strong> 等于：</p>\n<ul>\n<li>  <code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code> ，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li>\n<li>  <code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code> ，且不满足前面的条件</li>\n<li>  <code>0</code>，如果上述条件全部不满足</li>\n</ul>\n<p>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有 <code>nums[i]</code> 的 <strong>美丽值的总和</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,4,6,4]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 2 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 1</span><br><span class=\"line\">- nums[2] 的美丽值等于 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>3 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  预处理前后最值</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfBeauties</span><span class=\"params\">(Veci &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">Veci <span class=\"title\">leftmax</span><span class=\"params\">(len, INT_MIN)</span>, <span class=\"title\">rightmin</span><span class=\"params\">(len, INT_MAX)</span></span>;</span><br><span class=\"line\">        leftmax[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>], rightmin[len - <span class=\"number\">2</span>] = nums[len - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(i, <span class=\"number\">2</span>, len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            leftmax[i] = std::<span class=\"built_in\">max</span>(leftmax[i - <span class=\"number\">1</span>], nums[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            rightmin[len - i - <span class=\"number\">1</span>] = std::<span class=\"built_in\">min</span>(rightmin[len - i], nums[len - i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(i, <span class=\"number\">1</span>, len - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftmax[i] &lt; nums[i] &amp;&amp; nums[i] &lt; rightmin[i])</span><br><span class=\"line\">                ans += <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] &lt; nums[i] &amp;&amp; nums[i] &lt; nums[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">                ans += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-5877-检测正方形\"><a href=\"#T3-5877-检测正方形\" class=\"headerlink\" title=\"T3 5877. 检测正方形\"></a>T3 5877. 检测正方形</h2><ul>\n<li>  <strong>通过的用户数</strong>952</li>\n<li>  <strong>尝试过的用户数</strong>1535</li>\n<li>  <strong>用户总通过次数</strong>988</li>\n<li>  <strong>用户总提交次数</strong>4100</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：</p>\n<ul>\n<li>  <strong>添加</strong> 一个在数据流中的新点到某个数据结构中<strong>。</strong>可以添加 <strong>重复</strong> 的点，并会视作不同的点进行处理。</li>\n<li>  给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 <strong>面积为正</strong> 的 <strong>轴对齐正方形</strong> ，<strong>统计</strong> 满足该要求的方案数目<strong>。</strong></li>\n</ul>\n<p><strong>轴对齐正方形</strong> 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</p>\n<p>实现 <code>DetectSquares</code> 类：</p>\n<ul>\n<li>  <code>DetectSquares()</code> 使用空数据结构初始化对象</li>\n<li>  <code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]</code></li>\n<li>  <code>int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 <strong>轴对齐正方形</strong> 的方案数。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/01/image.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;DetectSquares&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]</span><br><span class=\"line\">[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, null, 1, 0, null, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">DetectSquares detectSquares = new DetectSquares();</span><br><span class=\"line\">detectSquares.add([3, 10]);</span><br><span class=\"line\">detectSquares.add([11, 2]);</span><br><span class=\"line\">detectSquares.add([3, 2]);</span><br><span class=\"line\">detectSquares.count([11, 10]); // 返回 1 。你可以选择：</span><br><span class=\"line\">                               //   - 第一个，第二个，和第三个点</span><br><span class=\"line\">detectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。</span><br><span class=\"line\">detectSquares.add([11, 2]);    // 允许添加重复的点。</span><br><span class=\"line\">detectSquares.count([11, 10]); // 返回 2 。你可以选择：</span><br><span class=\"line\">                               //   - 第一个，第二个，和第三个点</span><br><span class=\"line\">                               //   - 第一个，第三个，和第四个点</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>point.length == 2</code></li>\n<li>  <code>0 &lt;= x, y &lt;= 1000</code></li>\n<li>  调用 <code>add</code> 和 <code>count</code> 的 <strong>总次数</strong> 最多为 <code>5000</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>定位正方形时可通过枚举对角线进行，确定能否构成正方形只需要一个点。因为只有 <code>1000</code> 个点，所以可以直接开一个静态数组。</p>\n<blockquote>\n<p>  周赛的时候写了一堆 <code>std::map</code> ，没想到静态数组和一点定正方形，跑去算了半天对角线长度，欢声笑语中打出 GG</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DetectSquares</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">DetectSquares</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(points, <span class=\"number\">0</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>) * <span class=\"number\">1001</span> * <span class=\"number\">1001</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; point)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        points[point[<span class=\"number\">0</span>]][point[<span class=\"number\">1</span>]] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; point)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = point[<span class=\"number\">0</span>], y = point[<span class=\"number\">1</span>], ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> ny = <span class=\"number\">0</span>; ny &lt; <span class=\"number\">1001</span>; ++ny)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (points[x][ny] == <span class=\"number\">0</span> || ny == y)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> d = ny - y;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( x + d &gt;= <span class=\"number\">0</span> &amp;&amp; x + d &lt; <span class=\"number\">1001</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += points[x + d][y] * points[x + d][ny] * points[x][ny];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( x - d &gt;= <span class=\"number\">0</span> &amp;&amp; x - d &lt; <span class=\"number\">1001</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += points[x - d][y] * points[x - d][ny] * points[x][ny];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> points[<span class=\"number\">1001</span>][<span class=\"number\">1001</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5878-重复-K-次的最长子序列\"><a href=\"#T4-5878-重复-K-次的最长子序列\" class=\"headerlink\" title=\"T4 5878. 重复 K 次的最长子序列\"></a>T4 5878. 重复 K 次的最长子序列</h2><ul>\n<li>  <strong>通过的用户数</strong>111</li>\n<li>  <strong>尝试过的用户数</strong>186</li>\n<li>  <strong>用户总通过次数</strong>149</li>\n<li>  <strong>用户总提交次数</strong>567</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个长度为 <code>n</code> 的字符串 <code>s</code> ，和一个整数 <code>k</code> 。请你找出字符串 <code>s</code> 中 <strong>重复</strong> <code>k</code> 次的 <strong>最长子序列</strong> 。</p>\n<p><strong>子序列</strong> 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p>\n<p>如果 <code>seq * k</code> 是 <code>s</code> 的一个子序列，其中 <code>seq * k</code> 表示一个由 <code>seq</code> 串联 <code>k</code> 次构造的字符串，那么就称 <code>seq</code> 是字符串 <code>s</code> 中一个 <strong>重复 <code>k</code> 次</strong> 的子序列。</p>\n<ul>\n<li>  举个例子，<code>&quot;bba&quot;</code> 是字符串 <code>&quot;bababcba&quot;</code> 中的一个重复 <code>2</code> 次的子序列，因为字符串 <code>&quot;bbabba&quot;</code> 是由 <code>&quot;bba&quot;</code> 串联 <code>2</code> 次构造的，而 <code>&quot;bbabba&quot;</code> 是字符串 <code>&quot;bababcba&quot;</code> 的一个子序列。</li>\n</ul>\n<p>返回字符串 <code>s</code> 中 <strong>重复 k 次的最长子序列</strong> 。如果存在多个满足的子序列，则返回 <strong>字典序最大</strong> 的那个。如果不存在这样的子序列，返回一个 <strong>空</strong> 字符串。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png\" alt=\"example 1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;letsleetcode&quot;, k = 2</span><br><span class=\"line\">输出：&quot;let&quot;</span><br><span class=\"line\">解释：存在两个最长子序列重复 2 次：let&quot; 和 &quot;ete&quot; 。</span><br><span class=\"line\">&quot;let&quot; 是其中字典序最大的一个。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bb&quot;, k = 2</span><br><span class=\"line\">输出：&quot;b&quot;</span><br><span class=\"line\">解释：重复 2 次的最长子序列是 &quot;b&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ab&quot;, k = 2</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：不存在重复 2 次的最长子序列。返回空字符串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bbabbabbbbabaababab&quot;, k = 3</span><br><span class=\"line\">输出：&quot;bbbb&quot;</span><br><span class=\"line\">解释：在 &quot;bbabbabbbbabaababab&quot; 中重复 3 次的最长子序列是 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == s.length</code></li>\n<li>  <code>2 &lt;= k &lt;= 2000</code></li>\n<li>  <code>2 &lt;= n &lt; k * 8</code></li>\n<li>  <code>s</code> 由小写英文字母组成</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>题目所给数据实际上隐含了一条信息：子序列长度不会超过 8，所以对长度为 1 到 7 的全部子序列依次验证即可。</p>\n<blockquote>\n<p>  纯暴力，C++ 似乎也可以通过全排列函数求解</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(string &amp;a, string &amp;b, <span class=\"keyword\">int</span> k)</span></span>&#123;<span class=\"comment\">//检测b能否在a中出现k次</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; a.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]==b[j])&#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j==b.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>, cnt++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cnt==k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">longestSubsequenceRepeatedK</span><span class=\"params\">(string s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//易知：子序列长度最多为7 故而可以暴力找出长度为7以内的序列作为要找的子序列 依次验证即可</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//若对于长度为len的符合条件的子序列 则它一定是由长度为len-1的序列通过添加一个字母生成的</span></span><br><span class=\"line\">    <span class=\"comment\">//故而递推生成所有可能的子序列即可 然后验证是否符合条件 加入答案数组 最后返回最大的即可</span></span><br><span class=\"line\">    vector&lt;string&gt; ans[<span class=\"number\">8</span>];<span class=\"comment\">//ans[i]表示长度为i的符合条件的字符串</span></span><br><span class=\"line\">    ans[<span class=\"number\">0</span>].<span class=\"built_in\">push_back</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; i &lt; <span class=\"number\">8</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> v : ans[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> j = <span class=\"string\">&#x27;a&#x27;</span>; j &lt;= <span class=\"string\">&#x27;z&#x27;</span>; j++)&#123;</span><br><span class=\"line\">                string t = v + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(s,t,k)) ans[i].<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans[i].<span class=\"built_in\">empty</span>()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(ans[i].<span class=\"built_in\">begin</span>(),ans[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[i].<span class=\"built_in\">back</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：zeroac</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/c-bao-li-mei-ju-chang-du-7yi-nei-xu-lie-febao/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"洛谷模板题集合","date":"2021-10-09T16:01:12.000Z","_content":"\n---------\n\n# 洛谷模板题集合\n\n> 参考[这篇文章](https://www.cnblogs.com/Ender-hz/p/15018563.html)列出的题目\n\n## 0. 工具宏 & 包导入声明\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::io;\nuse std::rc::Rc;\n\nmacro_rules! init_cin {\n    () => {{\n        (io::stdin(), String::new())\n    }};\n}\nmacro_rules! scanf {\n    ($buf: expr, $div: expr, $($x:ty), +) => {{\n        let mut iter = $buf.split($div);\n        ($(iter.next().and_then(|token| token.parse::<$x>().ok()), ) *)\n    }};\n}\nmacro_rules! getline {\n    ($cin: expr, $buf: expr) => {{\n        $buf.clear();\n        $cin.read_line(&mut $buf)?;\n    }};\n}\n```\n\n## 1. 普及-\n\n### P3367 并查集\n\n```rust\nstruct DisjointSet<T>\nwhere\n    T: Sized + Eq + Copy + TryInto<usize>,\n{\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n    phantom: PhantomData<T>,\n}\n\nimpl<T> DisjointSet<T>\nwhere\n    T: Sized + Eq + Copy + TryInto<usize>,\n{\n    pub fn with_capacity(cap: usize) -> Self {\n        Self {\n            parent: vec![usize::MAX; cap],\n            rank: vec![0; cap],\n            phantom: PhantomData,\n        }\n    }\n    pub fn modify(&mut self, x: T, p: usize) {\n        match x.try_into() {\n            Ok(x) => { self.parent[x] = p; },\n            Err(_) => panic!()\n        }\n    }\n    pub fn union(&mut self, x: T, y: T) -> bool {\n        let (mut fx, mut fy) = (self.find(x), self.find(y));\n        if fx == fy || fx == usize::MAX || fy == usize::MAX {\n            false\n        } else {\n            if self.rank[fx] > self.rank[fy] {\n                std::mem::swap(&mut fx, &mut fy);\n            }\n            self.parent[fx] = fy;\n            if self.rank[fx] == self.rank[fy] {\n                self.rank[fy] += 1;\n            }\n            true\n        }\n    }\n    pub fn find(&mut self, x: T) -> usize {\n        match x.try_into() {\n            Ok(x) => self.find_wrapper(x),\n            Err(_) => usize::MAX\n        }\n    }\n    fn find_wrapper(&mut self, x: usize) -> usize {\n        if x != self.parent[x] {\n            self.parent[x] = self.find_wrapper(self.parent[x]);\n        }\n        self.parent[x]\n    }\n}\n\nfn main() -> io::Result<()> {\n    let cin = io::stdin();\n    let mut buf = String::new();\n    getline!(cin, buf);\n    // n m\n    if let (Some(n), Some(mut m)) = scanf!(buf, char::is_whitespace, i32, i32) {\n        let mut dsj = DisjointSet::<i32>::with_capacity(n as usize + 1);\n        (1..=n).for_each(|i| dsj.modify(i, i as usize));\n        while m > 0 {\n            getline!(cin, buf);\n            if let (Some(op), Some(arg1), Some(arg2)) =\n                scanf!(buf, char::is_whitespace, i32, i32, i32)\n            {\n                match op {\n                    1 => { dsj.union(arg1, arg2); },\n                    2 => { println!(\"{:}\", if dsj.find(arg1) == dsj.find(arg2) && dsj.find(arg1) != usize::MAX {\"Y\"} else {\"N\"})},\n                    _ => unreachable!()\n                }\n            }\n            m -= 1;\n        }\n    }\n    Ok(())\n}\n```\n\n\n\n### P3371 单源最短路（非随机数据）\n\n> 看描述似乎允许 SPFA ，但是原版 SPFA 还是被卡掉了三个用例\n\n```rust\nmod my {\n    #[derive(Debug, Clone)]\n    struct LFSNode {\n        to: usize,\n        next: usize,\n        w: i32,\n    }\n    pub struct LinkedForwardStar {\n        edges: Vec<LFSNode>,\n        head: Vec<usize>,\n        tot: usize,\n    }\n    impl LinkedForwardStar {\n        pub fn with_capacity(nodes: usize, edges: usize) -> Self {\n            Self {\n                edges: vec![\n                    LFSNode {\n                        to: usize::MAX,\n                        next: usize::MAX,\n                        w: 0\n                    };\n                    edges\n                ],\n                head: vec![usize::MAX; nodes],\n                tot: 0,\n            }\n        }\n        pub fn add(&mut self, src: usize, dst: usize, weight: i32) {\n            self.edges[self.tot].next = self.head[src];\n            self.edges[self.tot].to = dst;\n            self.edges[self.tot].w = weight;\n            self.head[src] = self.tot;\n            self.tot += 1;\n        }\n    }\n    pub fn spfa_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n        let mut vis = vec![false; lfs.tot];\n        let mut dist = vec![i32::MAX; lfs.head.len()];\n        let mut queue = vec![src];\n        dist[src] = 0;\n        vis[src] = true;\n        while !queue.is_empty() {\n            let x = queue.pop().unwrap();\n            vis[x] = false;\n            let mut i = lfs.head[x];\n            while i != usize::MAX {\n                let y = lfs.edges[i].to;\n                if dist[y] - lfs.edges[i].w > dist[x] {\n                    dist[y] = dist[x] + lfs.edges[i].w;\n                    if !vis[y] {\n                        vis[y] = true;\n                        queue.push(y);\n                    }\n                }\n                i = lfs.edges[i].next;\n            }\n        }\n        dist\n    }\n    pub fn dijkstra_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n        let mut vis = vec![false; lfs.head.len()];\n        let mut dist = vec![i32::MAX; lfs.head.len()];\n        let mut x = src;\n        dist[src] = 0;\n        while !vis[x] {\n            let mut curr = i32::MAX;\n            vis[x] = true;\n            let mut y = lfs.head[x];\n            while y != usize::MAX {\n                if !vis[lfs.edges[y].to] && dist[lfs.edges[y].to] - lfs.edges[y].w > dist[x] {\n                    dist[lfs.edges[y].to] = dist[x] + lfs.edges[y].w;\n                }\n                y = lfs.edges[y].next;\n            }\n            for i in 1..lfs.head.len() {\n                if dist[i] < curr && !vis[i] {\n                    curr = dist[i];\n                    x = i;\n                }\n            }\n        }\n        dist\n    }\n}\nuse my::*;\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m), Some(src)) = scanf!(buf, char::is_whitespace, usize, usize, usize)\n    {\n        let mut lfs = LinkedForwardStar::with_capacity(n + 1, m + 1);\n        while m > 0 {\n            m -= 1;\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                lfs.add(u, v, w);\n            }\n        }\n        // spfa_solver(lfs, src)\n        dijkstra_solver(lfs, src)\n            .iter()\n            .skip(1)\n            .for_each(|i| print!(\"{:} \", i))\n    }\n    Ok(())\n}\n```\n\n\n\n### P1226 快速幂\n\n```rust\nfn fast_pow(x: i64, n: i64, m: i64) -> i64 {\n    let (mut x, mut n, mut ret) = (x, n, 1);\n    while n > 0 {\n        if (n & 1) == 1 {\n            ret *= x;\n            ret %= m;\n        }\n        x *= x;\n        x %= m;\n        n >>= 1;\n    }\n    ret % m\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(x), Some(n), Some(m)) = scanf!(buf, char::is_whitespace, i64, i64, i64) {\n        println!(\"{0}^{1} mod {2}={3}\", x, n, m, fast_pow(x, n, m));\n    }\n    Ok(())\n}\n```\n\n\n\n### P4779 单源最短路（标准）\n\n> 不优化的 Dijkstra 也寄了，堆优化的 AC\n\n```rust\n#[derive(Default, Debug, Clone)]\nstruct LFSNode {\n    to: usize,\n    next: usize,\n    w: i32,\n}\npub struct LinkedForwardStar {\n    edges: Vec<LFSNode>,\n    head: Vec<usize>,\n    tot: usize,\n}\nimpl LinkedForwardStar {\n    pub fn with_capacity(node_cap: usize, edge_cap: usize) -> Self {\n        Self {\n            edges: vec![LFSNode::default(); edge_cap],\n            head: vec![usize::MAX; node_cap],\n            tot: 0,\n        }\n    }\n    pub fn add(&mut self, src: usize, dst: usize, weight: i32) {\n        self.edges[self.tot].next = self.head[src];\n        self.edges[self.tot].to = dst;\n        self.edges[self.tot].w = weight;\n        self.head[src] = self.tot;\n        self.tot += 1;\n    }\n}\npub fn spfa_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n    let mut vis = vec![false; lfs.tot];\n    let mut dist = vec![i32::MAX; lfs.head.len()];\n    let mut queue = vec![src];\n    dist[src] = 0;\n    vis[src] = true;\n    while !queue.is_empty() {\n        let x = queue.pop().unwrap();\n        vis[x] = false;\n        let mut i = lfs.head[x];\n        while i != usize::MAX {\n            let y = lfs.edges[i].to;\n            if dist[y] - lfs.edges[i].w > dist[x] {\n                dist[y] = dist[x] + lfs.edges[i].w;\n                if !vis[y] {\n                    vis[y] = true;\n                    queue.push(y);\n                }\n            }\n            i = lfs.edges[i].next;\n        }\n    }\n    dist\n}\n/// Dijkstra with Heap optimization\npub fn dijkstra_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n    let mut vis = vec![false; lfs.head.len()];\n    let mut dist = vec![i32::MAX; lfs.head.len()];\n    let mut pq = BinaryHeap::new();\n    dist[src] = 0;\n    pq.push(Reverse((dist[src], src)));\n    while let Some(Reverse((_, u))) = pq.pop() {\n        if vis[u] {\n            continue;\n        }\n        vis[u] = true;\n        let mut e = lfs.head[u];\n        while e != usize::MAX {\n            let v = lfs.edges[e].to;\n            let w = lfs.edges[e].w;\n            if dist[v] > dist[u] + w {\n                dist[v] = dist[u] + w;\n                pq.push(Reverse((dist[v], v)));\n            }\n            e = lfs.edges[e].next;\n        }\n    }\n    dist\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m), Some(src)) = scanf!(buf, char::is_whitespace, usize, usize, usize)\n    {\n        let mut lfs = LinkedForwardStar::with_capacity(n + 1, m + 1);\n        while m > 0 {\n            m -= 1;\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                lfs.add(u, v, w);\n            }\n        }\n        // spfa_solver(lfs, src)\n        dijkstra_solver(lfs, src)\n            .iter()\n            .skip(1)\n            .for_each(|i| print!(\"{:} \", i))\n    }\n    Ok(())\n}\n```\n\n","source":"_posts/Luogu-Template.md","raw":"---\ntitle: 洛谷模板题集合\ndate: 2021-10-10 00:01:12\ntags: 模板\n---\n\n---------\n\n# 洛谷模板题集合\n\n> 参考[这篇文章](https://www.cnblogs.com/Ender-hz/p/15018563.html)列出的题目\n\n## 0. 工具宏 & 包导入声明\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::io;\nuse std::rc::Rc;\n\nmacro_rules! init_cin {\n    () => {{\n        (io::stdin(), String::new())\n    }};\n}\nmacro_rules! scanf {\n    ($buf: expr, $div: expr, $($x:ty), +) => {{\n        let mut iter = $buf.split($div);\n        ($(iter.next().and_then(|token| token.parse::<$x>().ok()), ) *)\n    }};\n}\nmacro_rules! getline {\n    ($cin: expr, $buf: expr) => {{\n        $buf.clear();\n        $cin.read_line(&mut $buf)?;\n    }};\n}\n```\n\n## 1. 普及-\n\n### P3367 并查集\n\n```rust\nstruct DisjointSet<T>\nwhere\n    T: Sized + Eq + Copy + TryInto<usize>,\n{\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n    phantom: PhantomData<T>,\n}\n\nimpl<T> DisjointSet<T>\nwhere\n    T: Sized + Eq + Copy + TryInto<usize>,\n{\n    pub fn with_capacity(cap: usize) -> Self {\n        Self {\n            parent: vec![usize::MAX; cap],\n            rank: vec![0; cap],\n            phantom: PhantomData,\n        }\n    }\n    pub fn modify(&mut self, x: T, p: usize) {\n        match x.try_into() {\n            Ok(x) => { self.parent[x] = p; },\n            Err(_) => panic!()\n        }\n    }\n    pub fn union(&mut self, x: T, y: T) -> bool {\n        let (mut fx, mut fy) = (self.find(x), self.find(y));\n        if fx == fy || fx == usize::MAX || fy == usize::MAX {\n            false\n        } else {\n            if self.rank[fx] > self.rank[fy] {\n                std::mem::swap(&mut fx, &mut fy);\n            }\n            self.parent[fx] = fy;\n            if self.rank[fx] == self.rank[fy] {\n                self.rank[fy] += 1;\n            }\n            true\n        }\n    }\n    pub fn find(&mut self, x: T) -> usize {\n        match x.try_into() {\n            Ok(x) => self.find_wrapper(x),\n            Err(_) => usize::MAX\n        }\n    }\n    fn find_wrapper(&mut self, x: usize) -> usize {\n        if x != self.parent[x] {\n            self.parent[x] = self.find_wrapper(self.parent[x]);\n        }\n        self.parent[x]\n    }\n}\n\nfn main() -> io::Result<()> {\n    let cin = io::stdin();\n    let mut buf = String::new();\n    getline!(cin, buf);\n    // n m\n    if let (Some(n), Some(mut m)) = scanf!(buf, char::is_whitespace, i32, i32) {\n        let mut dsj = DisjointSet::<i32>::with_capacity(n as usize + 1);\n        (1..=n).for_each(|i| dsj.modify(i, i as usize));\n        while m > 0 {\n            getline!(cin, buf);\n            if let (Some(op), Some(arg1), Some(arg2)) =\n                scanf!(buf, char::is_whitespace, i32, i32, i32)\n            {\n                match op {\n                    1 => { dsj.union(arg1, arg2); },\n                    2 => { println!(\"{:}\", if dsj.find(arg1) == dsj.find(arg2) && dsj.find(arg1) != usize::MAX {\"Y\"} else {\"N\"})},\n                    _ => unreachable!()\n                }\n            }\n            m -= 1;\n        }\n    }\n    Ok(())\n}\n```\n\n\n\n### P3371 单源最短路（非随机数据）\n\n> 看描述似乎允许 SPFA ，但是原版 SPFA 还是被卡掉了三个用例\n\n```rust\nmod my {\n    #[derive(Debug, Clone)]\n    struct LFSNode {\n        to: usize,\n        next: usize,\n        w: i32,\n    }\n    pub struct LinkedForwardStar {\n        edges: Vec<LFSNode>,\n        head: Vec<usize>,\n        tot: usize,\n    }\n    impl LinkedForwardStar {\n        pub fn with_capacity(nodes: usize, edges: usize) -> Self {\n            Self {\n                edges: vec![\n                    LFSNode {\n                        to: usize::MAX,\n                        next: usize::MAX,\n                        w: 0\n                    };\n                    edges\n                ],\n                head: vec![usize::MAX; nodes],\n                tot: 0,\n            }\n        }\n        pub fn add(&mut self, src: usize, dst: usize, weight: i32) {\n            self.edges[self.tot].next = self.head[src];\n            self.edges[self.tot].to = dst;\n            self.edges[self.tot].w = weight;\n            self.head[src] = self.tot;\n            self.tot += 1;\n        }\n    }\n    pub fn spfa_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n        let mut vis = vec![false; lfs.tot];\n        let mut dist = vec![i32::MAX; lfs.head.len()];\n        let mut queue = vec![src];\n        dist[src] = 0;\n        vis[src] = true;\n        while !queue.is_empty() {\n            let x = queue.pop().unwrap();\n            vis[x] = false;\n            let mut i = lfs.head[x];\n            while i != usize::MAX {\n                let y = lfs.edges[i].to;\n                if dist[y] - lfs.edges[i].w > dist[x] {\n                    dist[y] = dist[x] + lfs.edges[i].w;\n                    if !vis[y] {\n                        vis[y] = true;\n                        queue.push(y);\n                    }\n                }\n                i = lfs.edges[i].next;\n            }\n        }\n        dist\n    }\n    pub fn dijkstra_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n        let mut vis = vec![false; lfs.head.len()];\n        let mut dist = vec![i32::MAX; lfs.head.len()];\n        let mut x = src;\n        dist[src] = 0;\n        while !vis[x] {\n            let mut curr = i32::MAX;\n            vis[x] = true;\n            let mut y = lfs.head[x];\n            while y != usize::MAX {\n                if !vis[lfs.edges[y].to] && dist[lfs.edges[y].to] - lfs.edges[y].w > dist[x] {\n                    dist[lfs.edges[y].to] = dist[x] + lfs.edges[y].w;\n                }\n                y = lfs.edges[y].next;\n            }\n            for i in 1..lfs.head.len() {\n                if dist[i] < curr && !vis[i] {\n                    curr = dist[i];\n                    x = i;\n                }\n            }\n        }\n        dist\n    }\n}\nuse my::*;\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m), Some(src)) = scanf!(buf, char::is_whitespace, usize, usize, usize)\n    {\n        let mut lfs = LinkedForwardStar::with_capacity(n + 1, m + 1);\n        while m > 0 {\n            m -= 1;\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                lfs.add(u, v, w);\n            }\n        }\n        // spfa_solver(lfs, src)\n        dijkstra_solver(lfs, src)\n            .iter()\n            .skip(1)\n            .for_each(|i| print!(\"{:} \", i))\n    }\n    Ok(())\n}\n```\n\n\n\n### P1226 快速幂\n\n```rust\nfn fast_pow(x: i64, n: i64, m: i64) -> i64 {\n    let (mut x, mut n, mut ret) = (x, n, 1);\n    while n > 0 {\n        if (n & 1) == 1 {\n            ret *= x;\n            ret %= m;\n        }\n        x *= x;\n        x %= m;\n        n >>= 1;\n    }\n    ret % m\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(x), Some(n), Some(m)) = scanf!(buf, char::is_whitespace, i64, i64, i64) {\n        println!(\"{0}^{1} mod {2}={3}\", x, n, m, fast_pow(x, n, m));\n    }\n    Ok(())\n}\n```\n\n\n\n### P4779 单源最短路（标准）\n\n> 不优化的 Dijkstra 也寄了，堆优化的 AC\n\n```rust\n#[derive(Default, Debug, Clone)]\nstruct LFSNode {\n    to: usize,\n    next: usize,\n    w: i32,\n}\npub struct LinkedForwardStar {\n    edges: Vec<LFSNode>,\n    head: Vec<usize>,\n    tot: usize,\n}\nimpl LinkedForwardStar {\n    pub fn with_capacity(node_cap: usize, edge_cap: usize) -> Self {\n        Self {\n            edges: vec![LFSNode::default(); edge_cap],\n            head: vec![usize::MAX; node_cap],\n            tot: 0,\n        }\n    }\n    pub fn add(&mut self, src: usize, dst: usize, weight: i32) {\n        self.edges[self.tot].next = self.head[src];\n        self.edges[self.tot].to = dst;\n        self.edges[self.tot].w = weight;\n        self.head[src] = self.tot;\n        self.tot += 1;\n    }\n}\npub fn spfa_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n    let mut vis = vec![false; lfs.tot];\n    let mut dist = vec![i32::MAX; lfs.head.len()];\n    let mut queue = vec![src];\n    dist[src] = 0;\n    vis[src] = true;\n    while !queue.is_empty() {\n        let x = queue.pop().unwrap();\n        vis[x] = false;\n        let mut i = lfs.head[x];\n        while i != usize::MAX {\n            let y = lfs.edges[i].to;\n            if dist[y] - lfs.edges[i].w > dist[x] {\n                dist[y] = dist[x] + lfs.edges[i].w;\n                if !vis[y] {\n                    vis[y] = true;\n                    queue.push(y);\n                }\n            }\n            i = lfs.edges[i].next;\n        }\n    }\n    dist\n}\n/// Dijkstra with Heap optimization\npub fn dijkstra_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n    let mut vis = vec![false; lfs.head.len()];\n    let mut dist = vec![i32::MAX; lfs.head.len()];\n    let mut pq = BinaryHeap::new();\n    dist[src] = 0;\n    pq.push(Reverse((dist[src], src)));\n    while let Some(Reverse((_, u))) = pq.pop() {\n        if vis[u] {\n            continue;\n        }\n        vis[u] = true;\n        let mut e = lfs.head[u];\n        while e != usize::MAX {\n            let v = lfs.edges[e].to;\n            let w = lfs.edges[e].w;\n            if dist[v] > dist[u] + w {\n                dist[v] = dist[u] + w;\n                pq.push(Reverse((dist[v], v)));\n            }\n            e = lfs.edges[e].next;\n        }\n    }\n    dist\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m), Some(src)) = scanf!(buf, char::is_whitespace, usize, usize, usize)\n    {\n        let mut lfs = LinkedForwardStar::with_capacity(n + 1, m + 1);\n        while m > 0 {\n            m -= 1;\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                lfs.add(u, v, w);\n            }\n        }\n        // spfa_solver(lfs, src)\n        dijkstra_solver(lfs, src)\n            .iter()\n            .skip(1)\n            .for_each(|i| print!(\"{:} \", i))\n    }\n    Ok(())\n}\n```\n\n","slug":"Luogu-Template","published":1,"updated":"2021-10-09T16:14:55.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckuk02vwm00004ogdeavgcv0j","content":"<hr>\n<h1 id=\"洛谷模板题集合\"><a href=\"#洛谷模板题集合\" class=\"headerlink\" title=\"洛谷模板题集合\"></a>洛谷模板题集合</h1><blockquote>\n<p>参考<a href=\"https://www.cnblogs.com/Ender-hz/p/15018563.html\">这篇文章</a>列出的题目</p>\n</blockquote>\n<h2 id=\"0-工具宏-amp-包导入声明\"><a href=\"#0-工具宏-amp-包导入声明\" class=\"headerlink\" title=\"0. 工具宏 &amp; 包导入声明\"></a>0. 工具宏 &amp; 包导入声明</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> init_cin &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#123;</span><br><span class=\"line\">        (io::stdin(), <span class=\"built_in\">String</span>::new())</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> scanf &#123;</span><br><span class=\"line\">    ($buf: expr, $div: expr, $($x:ty), +) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> iter = $buf.split($div);</span><br><span class=\"line\">        ($(iter.next().and_then(|token| token.parse::&lt;$x&gt;().ok()), ) *)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> getline &#123;</span><br><span class=\"line\">    ($cin: expr, $buf: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $buf.clear();</span><br><span class=\"line\">        $cin.read_line(&amp;<span class=\"keyword\">mut</span> $buf)?;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-普及\"><a href=\"#1-普及\" class=\"headerlink\" title=\"1. 普及-\"></a>1. 普及-</h2><h3 id=\"P3367-并查集\"><a href=\"#P3367-并查集\" class=\"headerlink\" title=\"P3367 并查集\"></a>P3367 并查集</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DisjointSet</span></span>&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"built_in\">Sized</span> + <span class=\"built_in\">Eq</span> + <span class=\"built_in\">Copy</span> + TryInto&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    parent: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    rank: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    phantom: PhantomData&lt;T&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; DisjointSet&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"built_in\">Sized</span> + <span class=\"built_in\">Eq</span> + <span class=\"built_in\">Copy</span> + TryInto&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            parent: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            rank: <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; cap],</span><br><span class=\"line\">            phantom: PhantomData,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">modify</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T, p: <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> x.try_into() &#123;</span><br><span class=\"line\">            <span class=\"literal\">Ok</span>(x) =&gt; &#123; <span class=\"keyword\">self</span>.parent[x] = p; &#125;,</span><br><span class=\"line\">            <span class=\"literal\">Err</span>(_) =&gt; <span class=\"built_in\">panic!</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">union</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T, y: T) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> fx, <span class=\"keyword\">mut</span> fy) = (<span class=\"keyword\">self</span>.find(x), <span class=\"keyword\">self</span>.find(y));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fx == fy || fx == <span class=\"built_in\">usize</span>::MAX || fy == <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fx] &gt; <span class=\"keyword\">self</span>.rank[fy] &#123;</span><br><span class=\"line\">                std::mem::swap(&amp;<span class=\"keyword\">mut</span> fx, &amp;<span class=\"keyword\">mut</span> fy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[fx] = fy;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fx] == <span class=\"keyword\">self</span>.rank[fy] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.rank[fy] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> x.try_into() &#123;</span><br><span class=\"line\">            <span class=\"literal\">Ok</span>(x) =&gt; <span class=\"keyword\">self</span>.find_wrapper(x),</span><br><span class=\"line\">            <span class=\"literal\">Err</span>(_) =&gt; <span class=\"built_in\">usize</span>::MAX</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find_wrapper</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != <span class=\"keyword\">self</span>.parent[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[x] = <span class=\"keyword\">self</span>.find_wrapper(<span class=\"keyword\">self</span>.parent[x]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent[x]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cin = io::stdin();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buf = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"comment\">// n m</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dsj = DisjointSet::&lt;<span class=\"built_in\">i32</span>&gt;::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">        (<span class=\"number\">1</span>..=n).for_each(|i| dsj.modify(i, i <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>));</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(op), <span class=\"literal\">Some</span>(arg1), <span class=\"literal\">Some</span>(arg2)) =</span><br><span class=\"line\">                scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">match</span> op &#123;</span><br><span class=\"line\">                    <span class=\"number\">1</span> =&gt; &#123; dsj.union(arg1, arg2); &#125;,</span><br><span class=\"line\">                    <span class=\"number\">2</span> =&gt; &#123; <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:&#125;&quot;</span>, <span class=\"keyword\">if</span> dsj.find(arg1) == dsj.find(arg2) &amp;&amp; dsj.find(arg1) != <span class=\"built_in\">usize</span>::MAX &#123;<span class=\"string\">&quot;Y&quot;</span>&#125; <span class=\"keyword\">else</span> &#123;<span class=\"string\">&quot;N&quot;</span>&#125;)&#125;,</span><br><span class=\"line\">                    _ =&gt; <span class=\"built_in\">unreachable!</span>()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P3371-单源最短路（非随机数据）\"><a href=\"#P3371-单源最短路（非随机数据）\" class=\"headerlink\" title=\"P3371 单源最短路（非随机数据）\"></a>P3371 单源最短路（非随机数据）</h3><blockquote>\n<p>看描述似乎允许 SPFA ，但是原版 SPFA 还是被卡掉了三个用例</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> my &#123;</span><br><span class=\"line\">    <span class=\"meta\">#[derive(Debug, Clone)]</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFSNode</span></span> &#123;</span><br><span class=\"line\">        to: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">        next: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">        w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">        edges: <span class=\"built_in\">Vec</span>&lt;LFSNode&gt;,</span><br><span class=\"line\">        head: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">        tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(nodes: <span class=\"built_in\">usize</span>, edges: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">                edges: <span class=\"built_in\">vec!</span>[</span><br><span class=\"line\">                    LFSNode &#123;</span><br><span class=\"line\">                        to: <span class=\"built_in\">usize</span>::MAX,</span><br><span class=\"line\">                        next: <span class=\"built_in\">usize</span>::MAX,</span><br><span class=\"line\">                        w: <span class=\"number\">0</span></span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                    edges</span><br><span class=\"line\">                ],</span><br><span class=\"line\">                head: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; nodes],</span><br><span class=\"line\">                tot: <span class=\"number\">0</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, dst: <span class=\"built_in\">usize</span>, weight: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].next = <span class=\"keyword\">self</span>.head[src];</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].to = dst;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].w = weight;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.head[src] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">spfa_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.tot];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> queue = <span class=\"built_in\">vec!</span>[src];</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !queue.is_empty() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> x = queue.pop().unwrap();</span><br><span class=\"line\">            vis[x] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = lfs.head[x];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> y = lfs.edges[i].to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[y] - lfs.edges[i].w &gt; dist[x] &#123;</span><br><span class=\"line\">                    dist[y] = dist[x] + lfs.edges[i].w;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> !vis[y] &#123;</span><br><span class=\"line\">                        vis[y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        queue.push(y);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i = lfs.edges[i].next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dist</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> x = src;</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !vis[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> curr = <span class=\"built_in\">i32</span>::MAX;</span><br><span class=\"line\">            vis[x] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> y = lfs.head[x];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> y != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> !vis[lfs.edges[y].to] &amp;&amp; dist[lfs.edges[y].to] - lfs.edges[y].w &gt; dist[x] &#123;</span><br><span class=\"line\">                    dist[lfs.edges[y].to] = dist[x] + lfs.edges[y].w;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                y = lfs.edges[y].next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..lfs.head.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[i] &lt; curr &amp;&amp; !vis[i] &#123;</span><br><span class=\"line\">                    curr = dist[i];</span><br><span class=\"line\">                    x = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dist</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">use</span> my::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m), <span class=\"literal\">Some</span>(src)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(n + <span class=\"number\">1</span>, m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                lfs.add(u, v, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// spfa_solver(lfs, src)</span></span><br><span class=\"line\">        dijkstra_solver(lfs, src)</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">            .for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;:&#125; &quot;</span>, i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P1226-快速幂\"><a href=\"#P1226-快速幂\" class=\"headerlink\" title=\"P1226 快速幂\"></a>P1226 快速幂</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">fast_pow</span></span>(x: <span class=\"built_in\">i64</span>, n: <span class=\"built_in\">i64</span>, m: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">i64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> x, <span class=\"keyword\">mut</span> n, <span class=\"keyword\">mut</span> ret) = (x, n, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            ret *= x;</span><br><span class=\"line\">            ret %= m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x *= x;</span><br><span class=\"line\">        x %= m;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret % m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(x), <span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i64</span>, <span class=\"built_in\">i64</span>, <span class=\"built_in\">i64</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;^&#123;1&#125; mod &#123;2&#125;=&#123;3&#125;&quot;</span>, x, n, m, fast_pow(x, n, m));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P4779-单源最短路（标准）\"><a href=\"#P4779-单源最短路（标准）\" class=\"headerlink\" title=\"P4779 单源最短路（标准）\"></a>P4779 单源最短路（标准）</h3><blockquote>\n<p>不优化的 Dijkstra 也寄了，堆优化的 AC</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Default, Debug, Clone)]</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFSNode</span></span> &#123;</span><br><span class=\"line\">    to: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    next: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">    edges: <span class=\"built_in\">Vec</span>&lt;LFSNode&gt;,</span><br><span class=\"line\">    head: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(node_cap: <span class=\"built_in\">usize</span>, edge_cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            edges: <span class=\"built_in\">vec!</span>[LFSNode::default(); edge_cap],</span><br><span class=\"line\">            head: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; node_cap],</span><br><span class=\"line\">            tot: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, dst: <span class=\"built_in\">usize</span>, weight: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].next = <span class=\"keyword\">self</span>.head[src];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].to = dst;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].w = weight;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.head[src] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">spfa_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.tot];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> queue = <span class=\"built_in\">vec!</span>[src];</span><br><span class=\"line\">    dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> !queue.is_empty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = queue.pop().unwrap();</span><br><span class=\"line\">        vis[x] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = lfs.head[x];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> y = lfs.edges[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[y] - lfs.edges[i].w &gt; dist[x] &#123;</span><br><span class=\"line\">                dist[y] = dist[x] + lfs.edges[i].w;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> !vis[y] &#123;</span><br><span class=\"line\">                    vis[y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    queue.push(y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i = lfs.edges[i].next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dist</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// Dijkstra with Heap optimization</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> pq = BinaryHeap::new();</span><br><span class=\"line\">    dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pq.push(Reverse((dist[src], src)));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(Reverse((_, u))) = pq.pop() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> vis[u] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> e = lfs.head[u];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> e != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> v = lfs.edges[e].to;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> w = lfs.edges[e].w;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[v] &gt; dist[u] + w &#123;</span><br><span class=\"line\">                dist[v] = dist[u] + w;</span><br><span class=\"line\">                pq.push(Reverse((dist[v], v)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = lfs.edges[e].next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dist</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m), <span class=\"literal\">Some</span>(src)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(n + <span class=\"number\">1</span>, m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                lfs.add(u, v, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// spfa_solver(lfs, src)</span></span><br><span class=\"line\">        dijkstra_solver(lfs, src)</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">            .for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;:&#125; &quot;</span>, i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"洛谷模板题集合\"><a href=\"#洛谷模板题集合\" class=\"headerlink\" title=\"洛谷模板题集合\"></a>洛谷模板题集合</h1><blockquote>\n<p>参考<a href=\"https://www.cnblogs.com/Ender-hz/p/15018563.html\">这篇文章</a>列出的题目</p>\n</blockquote>\n<h2 id=\"0-工具宏-amp-包导入声明\"><a href=\"#0-工具宏-amp-包导入声明\" class=\"headerlink\" title=\"0. 工具宏 &amp; 包导入声明\"></a>0. 工具宏 &amp; 包导入声明</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> init_cin &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#123;</span><br><span class=\"line\">        (io::stdin(), <span class=\"built_in\">String</span>::new())</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> scanf &#123;</span><br><span class=\"line\">    ($buf: expr, $div: expr, $($x:ty), +) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> iter = $buf.split($div);</span><br><span class=\"line\">        ($(iter.next().and_then(|token| token.parse::&lt;$x&gt;().ok()), ) *)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> getline &#123;</span><br><span class=\"line\">    ($cin: expr, $buf: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $buf.clear();</span><br><span class=\"line\">        $cin.read_line(&amp;<span class=\"keyword\">mut</span> $buf)?;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-普及\"><a href=\"#1-普及\" class=\"headerlink\" title=\"1. 普及-\"></a>1. 普及-</h2><h3 id=\"P3367-并查集\"><a href=\"#P3367-并查集\" class=\"headerlink\" title=\"P3367 并查集\"></a>P3367 并查集</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DisjointSet</span></span>&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"built_in\">Sized</span> + <span class=\"built_in\">Eq</span> + <span class=\"built_in\">Copy</span> + TryInto&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    parent: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    rank: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    phantom: PhantomData&lt;T&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; DisjointSet&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"built_in\">Sized</span> + <span class=\"built_in\">Eq</span> + <span class=\"built_in\">Copy</span> + TryInto&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            parent: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            rank: <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; cap],</span><br><span class=\"line\">            phantom: PhantomData,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">modify</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T, p: <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> x.try_into() &#123;</span><br><span class=\"line\">            <span class=\"literal\">Ok</span>(x) =&gt; &#123; <span class=\"keyword\">self</span>.parent[x] = p; &#125;,</span><br><span class=\"line\">            <span class=\"literal\">Err</span>(_) =&gt; <span class=\"built_in\">panic!</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">union</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T, y: T) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> fx, <span class=\"keyword\">mut</span> fy) = (<span class=\"keyword\">self</span>.find(x), <span class=\"keyword\">self</span>.find(y));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fx == fy || fx == <span class=\"built_in\">usize</span>::MAX || fy == <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fx] &gt; <span class=\"keyword\">self</span>.rank[fy] &#123;</span><br><span class=\"line\">                std::mem::swap(&amp;<span class=\"keyword\">mut</span> fx, &amp;<span class=\"keyword\">mut</span> fy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[fx] = fy;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fx] == <span class=\"keyword\">self</span>.rank[fy] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.rank[fy] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> x.try_into() &#123;</span><br><span class=\"line\">            <span class=\"literal\">Ok</span>(x) =&gt; <span class=\"keyword\">self</span>.find_wrapper(x),</span><br><span class=\"line\">            <span class=\"literal\">Err</span>(_) =&gt; <span class=\"built_in\">usize</span>::MAX</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find_wrapper</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != <span class=\"keyword\">self</span>.parent[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[x] = <span class=\"keyword\">self</span>.find_wrapper(<span class=\"keyword\">self</span>.parent[x]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent[x]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cin = io::stdin();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buf = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"comment\">// n m</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dsj = DisjointSet::&lt;<span class=\"built_in\">i32</span>&gt;::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">        (<span class=\"number\">1</span>..=n).for_each(|i| dsj.modify(i, i <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>));</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(op), <span class=\"literal\">Some</span>(arg1), <span class=\"literal\">Some</span>(arg2)) =</span><br><span class=\"line\">                scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">match</span> op &#123;</span><br><span class=\"line\">                    <span class=\"number\">1</span> =&gt; &#123; dsj.union(arg1, arg2); &#125;,</span><br><span class=\"line\">                    <span class=\"number\">2</span> =&gt; &#123; <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:&#125;&quot;</span>, <span class=\"keyword\">if</span> dsj.find(arg1) == dsj.find(arg2) &amp;&amp; dsj.find(arg1) != <span class=\"built_in\">usize</span>::MAX &#123;<span class=\"string\">&quot;Y&quot;</span>&#125; <span class=\"keyword\">else</span> &#123;<span class=\"string\">&quot;N&quot;</span>&#125;)&#125;,</span><br><span class=\"line\">                    _ =&gt; <span class=\"built_in\">unreachable!</span>()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P3371-单源最短路（非随机数据）\"><a href=\"#P3371-单源最短路（非随机数据）\" class=\"headerlink\" title=\"P3371 单源最短路（非随机数据）\"></a>P3371 单源最短路（非随机数据）</h3><blockquote>\n<p>看描述似乎允许 SPFA ，但是原版 SPFA 还是被卡掉了三个用例</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> my &#123;</span><br><span class=\"line\">    <span class=\"meta\">#[derive(Debug, Clone)]</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFSNode</span></span> &#123;</span><br><span class=\"line\">        to: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">        next: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">        w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">        edges: <span class=\"built_in\">Vec</span>&lt;LFSNode&gt;,</span><br><span class=\"line\">        head: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">        tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(nodes: <span class=\"built_in\">usize</span>, edges: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">                edges: <span class=\"built_in\">vec!</span>[</span><br><span class=\"line\">                    LFSNode &#123;</span><br><span class=\"line\">                        to: <span class=\"built_in\">usize</span>::MAX,</span><br><span class=\"line\">                        next: <span class=\"built_in\">usize</span>::MAX,</span><br><span class=\"line\">                        w: <span class=\"number\">0</span></span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                    edges</span><br><span class=\"line\">                ],</span><br><span class=\"line\">                head: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; nodes],</span><br><span class=\"line\">                tot: <span class=\"number\">0</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, dst: <span class=\"built_in\">usize</span>, weight: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].next = <span class=\"keyword\">self</span>.head[src];</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].to = dst;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].w = weight;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.head[src] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">spfa_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.tot];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> queue = <span class=\"built_in\">vec!</span>[src];</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !queue.is_empty() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> x = queue.pop().unwrap();</span><br><span class=\"line\">            vis[x] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = lfs.head[x];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> y = lfs.edges[i].to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[y] - lfs.edges[i].w &gt; dist[x] &#123;</span><br><span class=\"line\">                    dist[y] = dist[x] + lfs.edges[i].w;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> !vis[y] &#123;</span><br><span class=\"line\">                        vis[y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        queue.push(y);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i = lfs.edges[i].next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dist</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> x = src;</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !vis[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> curr = <span class=\"built_in\">i32</span>::MAX;</span><br><span class=\"line\">            vis[x] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> y = lfs.head[x];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> y != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> !vis[lfs.edges[y].to] &amp;&amp; dist[lfs.edges[y].to] - lfs.edges[y].w &gt; dist[x] &#123;</span><br><span class=\"line\">                    dist[lfs.edges[y].to] = dist[x] + lfs.edges[y].w;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                y = lfs.edges[y].next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..lfs.head.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[i] &lt; curr &amp;&amp; !vis[i] &#123;</span><br><span class=\"line\">                    curr = dist[i];</span><br><span class=\"line\">                    x = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dist</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">use</span> my::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m), <span class=\"literal\">Some</span>(src)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(n + <span class=\"number\">1</span>, m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                lfs.add(u, v, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// spfa_solver(lfs, src)</span></span><br><span class=\"line\">        dijkstra_solver(lfs, src)</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">            .for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;:&#125; &quot;</span>, i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P1226-快速幂\"><a href=\"#P1226-快速幂\" class=\"headerlink\" title=\"P1226 快速幂\"></a>P1226 快速幂</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">fast_pow</span></span>(x: <span class=\"built_in\">i64</span>, n: <span class=\"built_in\">i64</span>, m: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">i64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> x, <span class=\"keyword\">mut</span> n, <span class=\"keyword\">mut</span> ret) = (x, n, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            ret *= x;</span><br><span class=\"line\">            ret %= m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x *= x;</span><br><span class=\"line\">        x %= m;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret % m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(x), <span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i64</span>, <span class=\"built_in\">i64</span>, <span class=\"built_in\">i64</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;^&#123;1&#125; mod &#123;2&#125;=&#123;3&#125;&quot;</span>, x, n, m, fast_pow(x, n, m));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P4779-单源最短路（标准）\"><a href=\"#P4779-单源最短路（标准）\" class=\"headerlink\" title=\"P4779 单源最短路（标准）\"></a>P4779 单源最短路（标准）</h3><blockquote>\n<p>不优化的 Dijkstra 也寄了，堆优化的 AC</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Default, Debug, Clone)]</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFSNode</span></span> &#123;</span><br><span class=\"line\">    to: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    next: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">    edges: <span class=\"built_in\">Vec</span>&lt;LFSNode&gt;,</span><br><span class=\"line\">    head: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(node_cap: <span class=\"built_in\">usize</span>, edge_cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            edges: <span class=\"built_in\">vec!</span>[LFSNode::default(); edge_cap],</span><br><span class=\"line\">            head: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; node_cap],</span><br><span class=\"line\">            tot: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, dst: <span class=\"built_in\">usize</span>, weight: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].next = <span class=\"keyword\">self</span>.head[src];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].to = dst;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].w = weight;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.head[src] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">spfa_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.tot];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> queue = <span class=\"built_in\">vec!</span>[src];</span><br><span class=\"line\">    dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> !queue.is_empty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = queue.pop().unwrap();</span><br><span class=\"line\">        vis[x] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = lfs.head[x];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> y = lfs.edges[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[y] - lfs.edges[i].w &gt; dist[x] &#123;</span><br><span class=\"line\">                dist[y] = dist[x] + lfs.edges[i].w;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> !vis[y] &#123;</span><br><span class=\"line\">                    vis[y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    queue.push(y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i = lfs.edges[i].next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dist</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// Dijkstra with Heap optimization</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> pq = BinaryHeap::new();</span><br><span class=\"line\">    dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pq.push(Reverse((dist[src], src)));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(Reverse((_, u))) = pq.pop() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> vis[u] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> e = lfs.head[u];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> e != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> v = lfs.edges[e].to;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> w = lfs.edges[e].w;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[v] &gt; dist[u] + w &#123;</span><br><span class=\"line\">                dist[v] = dist[u] + w;</span><br><span class=\"line\">                pq.push(Reverse((dist[v], v)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = lfs.edges[e].next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dist</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m), <span class=\"literal\">Some</span>(src)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(n + <span class=\"number\">1</span>, m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                lfs.add(u, v, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// spfa_solver(lfs, src)</span></span><br><span class=\"line\">        dijkstra_solver(lfs, src)</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">            .for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;:&#125; &quot;</span>, i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckugyov2m0005kbgdgg2b4tcb","tag_id":"ckugyov2h0003kbgd718090ey","_id":"ckugyov2q0007kbgdd9otgutg"},{"post_id":"ckugyov2a0001kbgd9fsa3mok","tag_id":"ckugyov2h0003kbgd718090ey","_id":"ckugyov2q0008kbgdgo5d6re3"},{"post_id":"ckugyov2e0002kbgd7oq2hb4c","tag_id":"ckugyov2h0003kbgd718090ey","_id":"ckugyov2r000akbgdcof02ej7"},{"post_id":"ckugyov2k0004kbgd8hh2c1f8","tag_id":"ckugyov2h0003kbgd718090ey","_id":"ckugyov2r000bkbgddpf90hf9"},{"post_id":"ckuk02vwm00004ogdeavgcv0j","tag_id":"ckuk02vwr00014ogd5nsnf6lf","_id":"ckuk02vwu00024ogdf4vzcguy"}],"Tag":[{"name":"LeetCode 周赛总结","_id":"ckugyov2h0003kbgd718090ey"},{"name":"模板","_id":"ckuk02vwr00014ogd5nsnf6lf"}]}}