{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"eb50f30edd16cc1b5d5c5155dde0c3a3b6975e33","modified":1637126511642},{"_id":"source/.DS_Store","hash":"6aa9f49f3fa36399b3a780b77c9f8a8c8daf1f71","modified":1637126511640},{"_id":"source/_posts/Ar-Blog-rre-MSNeko.md","hash":"bbd993321de5dacc6d002bc410d2c4759d919163","modified":1637126511646},{"_id":"source/_posts/Luogu-Template.md","hash":"8ca15914cb34362662f39c3201e415c3c80690a5","modified":1637126511649},{"_id":"source/_posts/biweekly-contest-61.md","hash":"9108aa3066f3d0b21d955e9ca49f285ab6618245","modified":1637126511655},{"_id":"source/_posts/biweekly-contest-62.md","hash":"b5bdaa268dcb4091abc0a76a73b82e9e1e263253","modified":1637126511659},{"_id":"source/_posts/saikr-contest-2021autumn.md","hash":"48ea6ae4fcc9e9dd7b1d3babad4054fff196f61c","modified":1637126511664},{"_id":"source/_posts/biweekly-contest-65.md","hash":"3ed39200f3f3d42fe846476040ec057667123519","modified":1637126511662},{"_id":"source/_posts/virtual-contest-103.md","hash":"73e70f810a064c98fadfb5581ed97a87538cef46","modified":1637162216273},{"_id":"source/_posts/weekly-contest-258.md","hash":"252de277770cd9d8b20ef0b9ab20a8b3b7d57520","modified":1637126511670},{"_id":"source/_posts/weekly-contest-259.md","hash":"0ec65b6f9f99fcfd793addd77924acc77718fcc3","modified":1637126511672},{"_id":"source/_posts/weekly-contest-262.md","hash":"f936566fec392ab2796a77aefc5440f36a66b26e","modified":1637859765891},{"_id":"source/_posts/weekly-contest-263.md","hash":"d4e5f8b058d099d06b021cd35e1e5dae47770b35","modified":1637126511677},{"_id":"source/_posts/weekly-contest-267.md","hash":"c7d6c33b4e1c66e253eed9468c28b37e4c584696","modified":1637469228628},{"_id":"source/_posts/acwing-note.md","hash":"c606758173655355b6008f799312faedb16876f7","modified":1637817521835},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":1637126494633},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1637126494633},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":1637126494637},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"63d1a594969b7b5b97e1babebc7b85ef07c02e4f","modified":1637126494637},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"58f9c520976198df8f0941d30ca400988ee4cc2b","modified":1637126495053},{"_id":"node_modules/hexo-theme-butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1637126494620},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1637126494642},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1637126494642},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1637126494649},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1637126494649},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1637126494649},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1637126494649},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1637126495044},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1637126495044},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1637126495044},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1637126495044},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1637126494617},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1637126494620},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1637126494620},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1637126494620},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":1637126494649},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1637126494665},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1637126494669},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":1637126494669},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1637126494727},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1637126494759},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1637126494774},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":1637126494783},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1637126495060},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":1637126495060},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1637126495060},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":1637126495060},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1637126495075},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1637126495078},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1637126495082},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":1637126495082},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1637126495082},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"54b9324e3506dcc9c9991ef5e11e37e66e21594f","modified":1637126495091},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":1637126495091},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1637126495091},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1637126495091},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1637126495107},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1637126495110},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1637126495110},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1637126495110},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1637126495110},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1637126495300},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":1637126495301},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1637126495301},{"_id":"node_modules/hexo-theme-butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1637126495301},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1637126495301},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1637126495317},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1637126495321},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1637126495333},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1637126495338},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1637126494669},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1637126494680},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1637126494680},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":1637126494687},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1637126494692},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1637126494692},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1637126494696},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1637126494696},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1637126494696},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1637126494696},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1637126494713},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1637126494713},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1637126494713},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1637126494713},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1637126494727},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1637126494727},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1637126494743},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":1637126494743},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1637126494743},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1637126494759},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1637126494759},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":1637126494759},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1637126494759},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":1637126494774},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1637126494788},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1637126494901},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1637126494949},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":1637126494954},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1637126494958},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1637126494996},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1637126495002},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1637126495006},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1637126495006},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":1637126495012},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1637126495012},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1637126495012},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":1637126495012},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1637126495012},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1637126495029},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1637126495029},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1637126495029},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1637126495029},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":1637126495029},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1637126495123},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"e211efbd1952d4b1b881287aa43423133c1d166e","modified":1637126495133},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":1637126495139},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1637126495173},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":1637126495175},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1637126495175},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1637126495185},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1637126495185},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"98235fcda3b87ad6f7e91eafbed94d0d6ae847ca","modified":1637126495190},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1637126495190},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1637126495190},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":1637126495190},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1637126495190},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1637126495206},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1637126495208},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":1637126495212},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":1637126495212},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":1637126495212},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":1637126495222},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":1637126495229},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1637126495235},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1637126495238},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"97fec1e814f88237862f4d800a35362b802f6625","modified":1637126495238},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":1637126495238},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1637126495238},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1637126495238},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":1637126495256},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":1637126495256},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":1637126495256},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":1637126495270},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1637126495273},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1637126495273},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1637126495278},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1637126495278},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":1637126495285},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1637126495285},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1637126495285},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1637126495295},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1637126495321},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1637126495333},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1637126494790},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1637126494806},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1637126494790},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1637126494809},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1637126494809},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1637126494822},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1637126494822},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1637126494831},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1637126494809},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1637126494838},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1637126494838},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1637126494838},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1637126494838},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"2e52c64e89f16267596a8465841dd46f51820982","modified":1637126494857},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":1637126494862},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":1637126494869},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1637126494869},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1637126494869},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1637126494869},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1637126494886},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1637126494889},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":1637126494889},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"36f3c603d2a2ecddaa6d2675a89d76ad94968f72","modified":1637126494889},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1637126494910},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1637126494914},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1637126494917},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1637126494917},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":1637126494917},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":1637126494932},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1637126494937},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1637126494937},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1637126494937},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":1637126494949},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1637126494964},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1637126494964},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1637126494964},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1637126494981},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1637126494981},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1637126494981},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1637126494981},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1637126495139},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1637126495139},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1637126495161},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1637126495169},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1637126495165},{"_id":"public/2021/09/05/Ar-Blog-rre-MSNeko/index.html","hash":"4cf1fef0b9dfbcdaebe2c60ea794383b14fad45a","modified":1638110163672},{"_id":"public/archives/2021/11/index.html","hash":"75dd5270e5a95ea25ef57b771d6eda842d0a5153","modified":1638110163672},{"_id":"public/2021/11/15/virtual-contest-103/index.html","hash":"6ad5fb70a2949ded2be1e667e50036f90be1ae47","modified":1638110163672},{"_id":"public/2021/11/14/biweekly-contest-65/index.html","hash":"ef09a0c756c3d971ef1419a20548fc89a0e4a029","modified":1638110163672},{"_id":"public/2021/11/14/weekly-contest-267/index.html","hash":"5666da24770447d624ea6040a999b88fa1091271","modified":1638110163672},{"_id":"public/2021/10/25/saikr-contest-2021autumn/index.html","hash":"e7286d950b78ebaf7936a43e424d2daacbbbba24","modified":1638110163672},{"_id":"public/2021/10/17/weekly-contest-263/index.html","hash":"98ab6bcc504b2b59f2d84fb7a214249d3d291e70","modified":1638110163672},{"_id":"public/2021/10/11/acwing-note/index.html","hash":"0781b68b54ccd62f4dc26f44d9789ff902127dae","modified":1638110163672},{"_id":"public/2021/10/10/weekly-contest-262/index.html","hash":"8a958441797410ebbf705bc54758f6d321568fa1","modified":1638110163672},{"_id":"public/2021/10/10/Luogu-Template/index.html","hash":"61a408de13ec1d0654588c2a94783d43d7bae783","modified":1638110163672},{"_id":"public/2021/10/06/biweekly-contest-62/index.html","hash":"e06f4c8cfc2c5f64a59736954e4e3002661242aa","modified":1638110163672},{"_id":"public/2021/09/19/weekly-contest-259/index.html","hash":"3f7182bc34547881dd341dece8c8df7319de9d55","modified":1638110163672},{"_id":"public/2021/09/19/biweekly-contest-61/index.html","hash":"e820e9630cfe93200e6eab43adfb318c388c48ac","modified":1638110163672},{"_id":"public/2021/09/12/weekly-contest-258/index.html","hash":"0a6d8df82e32ef5a63aec73c3c6f11e05b8f6742","modified":1638110163672},{"_id":"public/archives/index.html","hash":"f356a7ed8ae1866617a9d79e9d3aa9b4fc01e54d","modified":1638110163672},{"_id":"public/archives/page/2/index.html","hash":"cf9d08b7d8bf31488ce3b76909f904ae399f18fb","modified":1638110163672},{"_id":"public/archives/2021/index.html","hash":"0a5b714a1f66792853b1faf099d63d1b0f0a493a","modified":1638110163672},{"_id":"public/archives/2021/page/2/index.html","hash":"c553c9a4725ca9e709487bec70e806d11ab3b892","modified":1638110163672},{"_id":"public/archives/2021/09/index.html","hash":"4a1f1df22dfe447bdfaa226184d8be8937845a2f","modified":1638110163672},{"_id":"public/index.html","hash":"1cf4edc981adf9f04be8bdfb0a210d5f1d103a8e","modified":1638110163672},{"_id":"public/tags/算法笔记/index.html","hash":"fd7ecb09f8cb61082cbfca1600b964e49e0d2a23","modified":1638110163672},{"_id":"public/tags/saikr/index.html","hash":"af25573c6d0306778736d60b0fff6669001cb020","modified":1638110163672},{"_id":"public/tags/模板/index.html","hash":"432b179a37dc4a0833f7c80f1c9eb8efb1544673","modified":1638110163672},{"_id":"public/archives/2021/10/index.html","hash":"654153b38e2e0d4a3dc5bb8f810de3d472e947b1","modified":1638110163672},{"_id":"public/page/2/index.html","hash":"86d1844b512951de9c1e89e088f1c86f629df38e","modified":1638110163672},{"_id":"public/tags/LeetCode-周赛总结/index.html","hash":"4cc5d3bb106e45a06bcbcc7d885ca2692aebd7d9","modified":1638110163672},{"_id":"public/CNAME","hash":"eb50f30edd16cc1b5d5c5155dde0c3a3b6975e33","modified":1637156858063},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1637156858063},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1637156858063},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1637156858063},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1637156858063},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1637156858063},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1637156858063},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1637156858063},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1637156858063},{"_id":"public/css/index.css","hash":"4e5d9ead0952d31f549bbc22765a615a4540f58b","modified":1637156858063},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1637156858063},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1637156858063},{"_id":"source/_posts/virtual-contest-185.md","hash":"75628987e6c9d492edaeceef57f393c0d1513364","modified":1637164300076},{"_id":"public/2021/11/17/virtual-contest-185/index.html","hash":"41b3da858620e94240cd9978f47c262bc0aa28f7","modified":1638110163672},{"_id":"source/_posts/weekly-contest-268.md","hash":"b7ea810410e73025348eca413a95bf72a94d057a","modified":1637470196330},{"_id":"public/2021/11/21/weekly-contest-268/index.html","hash":"0a7dd40ac4e4e96fd07c42cb340529002d848b34","modified":1638110163672},{"_id":"public/tags/LeetCode-周赛总结/page/2/index.html","hash":"87dbfc7aeccd3c3b116c954108a643bb8ead6f15","modified":1638110163672},{"_id":"source/_posts/problem-set.md","hash":"df9d004324f6897058b897986db74ceb0fa1f4e5","modified":1637679226150},{"_id":"public/2021/11/23/problem-set/index.html","hash":"addc17624ff0ea9ee22bca5b424b847cf306f344","modified":1638110163672},{"_id":"public/tags/错题集/index.html","hash":"b2a8d308941b255caaf7b2abb4fdef50bf6320d6","modified":1638110163672},{"_id":"source/_posts/weekly-contest-269.md","hash":"79a38d3aaa7c8915451a9c57060abfc4ab1eb8e6","modified":1638110054059},{"_id":"public/2021/11/28/weekly-contest-269/index.html","hash":"c6d956141b0b959b7850f714844ebca9748105b6","modified":1638110163672},{"_id":"public/tags/LeetCode-周赛/index.html","hash":"a6290a2697a793ad69948465055a59b080f98d48","modified":1638110163672}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Ar Blog rre MSNeko","date":"2021-09-05T14:04:30.000Z","_content":"\n# 你以为会有介绍，其实并不会有\n\n有空再做 blog 的美化\n","source":"_posts/Ar-Blog-rre-MSNeko.md","raw":"---\ntitle: Ar Blog rre MSNeko\ndate: 2021-09-05 22:04:30\ntags: #主页介绍 \n---\n\n# 你以为会有介绍，其实并不会有\n\n有空再做 blog 的美化\n","slug":"Ar-Blog-rre-MSNeko","published":1,"updated":"2021-11-17T05:21:51.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8po00001cy570rwfhp3","content":"<h1 id=\"你以为会有介绍，其实并不会有\"><a href=\"#你以为会有介绍，其实并不会有\" class=\"headerlink\" title=\"你以为会有介绍，其实并不会有\"></a>你以为会有介绍，其实并不会有</h1><p>有空再做 blog 的美化</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"你以为会有介绍，其实并不会有\"><a href=\"#你以为会有介绍，其实并不会有\" class=\"headerlink\" title=\"你以为会有介绍，其实并不会有\"></a>你以为会有介绍，其实并不会有</h1><p>有空再做 blog 的美化</p>\n"},{"title":"AcWing 算法基础课笔记","date":"2021-10-11T14:53:15.000Z","_content":"\n---\n\n# AcWing 算法基础课笔记\n\n>   笔记内容最终将由 `markmap` 工具生成思维导图\n\n## 基础算法\n\n### 快速排序\n\n-   核心思想\n    -   分治法\n-   算法步骤\n    -   确定分界点\n        -   左端点\n        -   右端点\n        -   中间点\n        -   随机点\n    -   调整区间\n        -   目标：使得左半边所有的数小于等于分界点，右半边所有的数大于等于分界点\n        -   调整方法：\n            -   暴力：直接开两个数组，扫描一遍\n            -   常用：左右各一个游标。左边找第一个大于分点的，右边找第一个小于分点的，然后交换即可\n    -   递归处理\n\n-   模板\n\n    ```c++\n    void quick_sort(int q[], int l, int r)\n    {\n        if (l >= r) return;\n    \n        int x = q[(l + r) >> 1], i = l - 1, j = r + 1;\n    \n        while (i < j)\n        {\n            do i++; while (q[i] < x);\n            do j--; while (q[j] > x);\n            if (i < j) swap(q[i], q[j]);\n        }\n    \n        quick_sort(q, l, j);\n        quick_sort(q, j + 1, r);\n    }\n    ```\n    \n\n### 归并排序\n\n-   核心思想\n\n    -   归并\n\n-   算法步骤\n\n    -   先递归左右两侧\n    -   左右有序数组合并成一个有序数组\n\n\n### 二分\n\n-   核心思想\n    -   充分不必要条件\n        -   单调性\n    -   本质\n        -   将序列按照某个性质从中间一分为二，二分法可以寻找两个性质的边界\n    -   关注点\n        -   根据查找的答案属于哪个性质，确定更新方式\n    \n-   模板\n\n    -   右侧二分\n\n    ```c++\n    // 找左边界\n    int l = 0, r = n - 1;\n    while (l < r)\n    {\n        int m = l + r >> 1;\t// 不加 1 会出现 [l, l] 死循环\n        check(m)? r = m; l = m + 1;\n    }\n    ```\n\n    -   左侧二分\n\n    ```c++\n    // 找右边界\n    int l = 0, r = n - 1;\n    while (l < r)\n    {\n        int m = l + r + 1>> 1;\n        check(m)? l = m; r = m - 1;\n    }\n    ```\n\n-   扩展\n    -   浮点数二分\n        -   停止条件是区间长度小于 $\\varepsilon$\n        -   不需要整数二分的考虑边界，直接往 `mid` 靠近即可\n\n### 高精度\n\n-   核心思想\n    -   将大整数的每一位存入数组\n    -   先存低位，后存高位\n-   优化\n    -   一次存 4 位\n\n### 前缀和\n\n-   核心思想\n    -   快速求出原数组里一段数的和\n-   技巧\n    -   定义 $S[0] = 0$ 可以减少很多特判\n\n### 差分\n\n-   核心思想\n    -   前缀和的逆运算，构造一个数组使得该数组的前缀和为原数组\n-   技巧\n    -   在差分数组里做出两个修改 `b[l] += c, b[r + 1] -= c` 等价于原数组 `a[l: r] += c`\n\n### 双指针\n\n-   核心思想\n    -   优化暴力二重循环到 $O(N)$ 复杂度\n    \n-   模板\n\n    ```c++\n    for (int i = 0, j = 0; i < n; ++i)\n    {\n        while (j < i && check(i, j)) ++j;\n        /* Do sth here */\n    }\n    ```\n\n### 离散化\n\n-   核心思想\n    -   跨度较大但稀疏的整数映射到排序后的下标\n    -   核心是保序和二分查找\n\n### 区间合并\n\n-   算法步骤\n    -   按区间左端点排序\n    -   扫描过程中维护一个当前区间，考虑下一个区间和当前区间的关系\n        -   包含：不处理\n        -   相交：更新当前区间右端点\n        -   相离：当前区间结束，更新左右端点为新区间\n\n## 数据结构\n\n### 链表\n\n-   动态链表\n    -   每次 new 一个 Node ，较慢\n-   静态链表\n    -   数组模拟 Elem 和 Next 域，快\n    -   应用\n        -   邻接表\n        -   链式前向星\n    -   扩展\n        -   双向链表\n            -   模拟 Prev 域和 Next 域\n            -   维护一个 head 变量和一个 tail 变量\n\n### 单调栈\n\n-   常见题型\n    -   给定序列，求每一个数左边最近的最小数\n-   时间复杂度\n    -   `O(N)`\n\n### 单调队列\n\n-   常见题型\n    -   滑动窗口最值\n\n### KMP\n\n-   核心思想\n\n    -   暴力思想中，当前匹配失败，会有部分串已匹配\n    -   记录向后移动多少可以使得已匹配的串和新的位置仍然匹配\n    -   这个记录只和模板串有关！这就是 Next 数组\n    -   `next[i] = j` 意味着 `p[1..=j] == p[i - j + 1..=i]`\n    -   假设从 `s[i]` 开始不再匹配，即目前 `s[i - 1] == p[j] && s[i] != p[j + 1] `，此时直接向后移动模式串，将 `p[next[j]]` 对齐到 `s[i-1]`\n    -   预处理思想与匹配相似，如果匹配不上，就回退到 `next` 对应位置，直到退到下标 0\n    \n- 代码模板\n\n    -   匹配过程\n\n        ```c++\n    \t// p[N] 匹配 s[M]\n    \tfor (int i = 1, j = 0; i <= M; ++i) // j 和 i 错开一位\n    \t{\n    \t    while (j && s[i] != p[j + 1]) j = next[j];\t// j 不能退到开头之前\n    \t    if (s[i] == p[j + 1]) ++j;\n    \t    if (j == N) \n    \t    { \n    \t        /* 匹配成功; */  \n    \t        j = next[j]; \t// 准备匹配下一次\n    \t    }\n    \t}\n    \t```\n    \n    -   预处理\n    \n        ```c++\n        for (int i = 2, j = 0; i <= N; ++i)\t// next[1] === 0\n        {\n            while (j && p[i] != p[j + 1]) j = next[j];\n            if (p[i] == p[j + 1]) ++j;\n            next[i] = j;\n        }\n        ```\n    \n    -   注意\n    \n        -   本模板字符串下标均从 1 开始\n\n### Trie 树\n\n-   核心思想\n-   作用\n    -   存储字符串\n    -   查找字符串\n-   实现\n    -   每个单词结尾的节点标记 `is_end = true`\n    -   类似数组模拟链表，用 `tot` 表示当前位置\n\n### 并查集\n\n-   核心思想\n\n    -   路径压缩\n\n    \t>    ​\t我愿将之称为最优美的一行代码\n\n    \t```c++\n    \treturn x == parent[x]? x: parent[x] = find(parent[x]);\n    \t```\n\n    -   按秩合并\n    \n        ```c++\n        if (rank[fy] > rank[fx]) swap(fy, fx);\n        parent[fy] = fx;\n        if (rank[fx] == rank[fy]) rank[fx]++;\n        ```\n    \n-   作用\n\n    -   合并区间\n    -   查询是否同类\n\n-   复杂度\n\n    -   $O(\\alpha(N))$\n\n### 二叉堆\n\n-   核心操作\n    -   Down\n        -   和较小的孩子交换\n        -   继续 Down\n    -   Up\n        -   和父亲交换\n        -   继续 Up\n\n-   实现操作\n\n    -   建堆\n\n        -   从 $n/2$ 到 1 执行 down 操作\n        -   跳过了最后一层叶子节点\n        -   复杂度 $O(N)$\n\n    -   插入\n\n        ```c++\n        heap[++tot] = x, up(tot);\n        ```\n\n    -   删除\n\n        ```c++\n        heap[k] = heap[tot--], if (k != 1) up(k), down(k);\t// up 和 down 至多执行一个\n        ```\n\n    -   修改\n\n        ```c++\n        heap[k] = x, up(k), down(k);\n        ```\n\n    -   修改第 k 个元素\n\n        -   每个元素额外处理两个“指针”\n        -   ph[k] 储存索引 i\n        -   hp[i] 储存索引 i 对应的元素 k\n\n        -   swap 需要交换 ph[hp[a]], ph[hp[b]] 以及 hp[a] 和 hp[b]\n        -   交换完成后堆的元素和 ph 依旧是双向指向关系。交换 ph 修改 ph 指向堆的指针，交换 hp 修改堆指向 ph 的指针\n\n### 散列表\n\n## 搜索与图论\n\n### 搜索\n\n-   深度优先\n    -   数据结构\n        -   栈\n    -   空间\n        -   $O(h)$\n    -   思想\n        -   回溯\n        -   剪枝\n    -   关键操作\n        -   恢复现场\n-   广度优先\n    -   数据结构\n        -   队列\n    -   空间\n        -   $O(2^h)$\n    -   性质\n        -   具有最短路性质\n        -   要求边权相等才可以用于求最短路\n\n### 图\n\n-   图的储存\n    -   邻接矩阵\n    -   邻接表\n        -   链式前向星\n    \n-   拓扑排序\n    \n    -   拓扑序列\n        -   拓扑序列的边一定从前向后\n        -   只针对有向图\n        -   有向无环图一定存在拓扑序列\n    -   拓扑排序\n        -   入度为 0 的点可以排在当前序列最前作为入口\n        -   入度为 0 的点入队\n        -   BFS 枚举所有出边并删掉\n        -   新的入度为 0 的点入队\n        -   队空结束\n    \n\n### 最短路问题\n\n-   分类\n    -   单源最短路\n        -   正权图\n        -   负权图\n    -   多源汇最短路\n-   难点\n    -   抽象原问题到最短路问题\n    -   建图\n-   方法\n    -   朴素 Dijkstra\n        -   复杂度 $O(V^2)$\n    -   堆优化 Dijkstra\n        -   复杂度 $O(E\\log V)$\n    -   Bellman-Ford 算法\n    \n        -  循环 $k \\in [1, E]$ 次\n          -  此时的 dist 数组代表从初始点出发，经过不超过 k 条边的最短路径\n          -  如果一条最短路上有 $E$ 条边，则必有负环\n        -  每次循环遍历所有边，进行一次松弛操作\n    -   SPFA\n        -   队列优化的 Bellman-Ford\n        -   将松弛后的边入队\n\n### 判断负环\n\n-   SPFA\n    -   添加一个 cnt 数组\n    -   cnt 数组记录从初始点出发最短路径经过路径的边数\n    -   如果 $ cnt[x] \\geq V$ ，由抽屉原理可知存在负环\n","source":"_posts/acwing-note.md","raw":"---\ntitle: AcWing 算法基础课笔记\ndate: 2021-10-11 22:53:15\ntags: 算法笔记\n---\n\n---\n\n# AcWing 算法基础课笔记\n\n>   笔记内容最终将由 `markmap` 工具生成思维导图\n\n## 基础算法\n\n### 快速排序\n\n-   核心思想\n    -   分治法\n-   算法步骤\n    -   确定分界点\n        -   左端点\n        -   右端点\n        -   中间点\n        -   随机点\n    -   调整区间\n        -   目标：使得左半边所有的数小于等于分界点，右半边所有的数大于等于分界点\n        -   调整方法：\n            -   暴力：直接开两个数组，扫描一遍\n            -   常用：左右各一个游标。左边找第一个大于分点的，右边找第一个小于分点的，然后交换即可\n    -   递归处理\n\n-   模板\n\n    ```c++\n    void quick_sort(int q[], int l, int r)\n    {\n        if (l >= r) return;\n    \n        int x = q[(l + r) >> 1], i = l - 1, j = r + 1;\n    \n        while (i < j)\n        {\n            do i++; while (q[i] < x);\n            do j--; while (q[j] > x);\n            if (i < j) swap(q[i], q[j]);\n        }\n    \n        quick_sort(q, l, j);\n        quick_sort(q, j + 1, r);\n    }\n    ```\n    \n\n### 归并排序\n\n-   核心思想\n\n    -   归并\n\n-   算法步骤\n\n    -   先递归左右两侧\n    -   左右有序数组合并成一个有序数组\n\n\n### 二分\n\n-   核心思想\n    -   充分不必要条件\n        -   单调性\n    -   本质\n        -   将序列按照某个性质从中间一分为二，二分法可以寻找两个性质的边界\n    -   关注点\n        -   根据查找的答案属于哪个性质，确定更新方式\n    \n-   模板\n\n    -   右侧二分\n\n    ```c++\n    // 找左边界\n    int l = 0, r = n - 1;\n    while (l < r)\n    {\n        int m = l + r >> 1;\t// 不加 1 会出现 [l, l] 死循环\n        check(m)? r = m; l = m + 1;\n    }\n    ```\n\n    -   左侧二分\n\n    ```c++\n    // 找右边界\n    int l = 0, r = n - 1;\n    while (l < r)\n    {\n        int m = l + r + 1>> 1;\n        check(m)? l = m; r = m - 1;\n    }\n    ```\n\n-   扩展\n    -   浮点数二分\n        -   停止条件是区间长度小于 $\\varepsilon$\n        -   不需要整数二分的考虑边界，直接往 `mid` 靠近即可\n\n### 高精度\n\n-   核心思想\n    -   将大整数的每一位存入数组\n    -   先存低位，后存高位\n-   优化\n    -   一次存 4 位\n\n### 前缀和\n\n-   核心思想\n    -   快速求出原数组里一段数的和\n-   技巧\n    -   定义 $S[0] = 0$ 可以减少很多特判\n\n### 差分\n\n-   核心思想\n    -   前缀和的逆运算，构造一个数组使得该数组的前缀和为原数组\n-   技巧\n    -   在差分数组里做出两个修改 `b[l] += c, b[r + 1] -= c` 等价于原数组 `a[l: r] += c`\n\n### 双指针\n\n-   核心思想\n    -   优化暴力二重循环到 $O(N)$ 复杂度\n    \n-   模板\n\n    ```c++\n    for (int i = 0, j = 0; i < n; ++i)\n    {\n        while (j < i && check(i, j)) ++j;\n        /* Do sth here */\n    }\n    ```\n\n### 离散化\n\n-   核心思想\n    -   跨度较大但稀疏的整数映射到排序后的下标\n    -   核心是保序和二分查找\n\n### 区间合并\n\n-   算法步骤\n    -   按区间左端点排序\n    -   扫描过程中维护一个当前区间，考虑下一个区间和当前区间的关系\n        -   包含：不处理\n        -   相交：更新当前区间右端点\n        -   相离：当前区间结束，更新左右端点为新区间\n\n## 数据结构\n\n### 链表\n\n-   动态链表\n    -   每次 new 一个 Node ，较慢\n-   静态链表\n    -   数组模拟 Elem 和 Next 域，快\n    -   应用\n        -   邻接表\n        -   链式前向星\n    -   扩展\n        -   双向链表\n            -   模拟 Prev 域和 Next 域\n            -   维护一个 head 变量和一个 tail 变量\n\n### 单调栈\n\n-   常见题型\n    -   给定序列，求每一个数左边最近的最小数\n-   时间复杂度\n    -   `O(N)`\n\n### 单调队列\n\n-   常见题型\n    -   滑动窗口最值\n\n### KMP\n\n-   核心思想\n\n    -   暴力思想中，当前匹配失败，会有部分串已匹配\n    -   记录向后移动多少可以使得已匹配的串和新的位置仍然匹配\n    -   这个记录只和模板串有关！这就是 Next 数组\n    -   `next[i] = j` 意味着 `p[1..=j] == p[i - j + 1..=i]`\n    -   假设从 `s[i]` 开始不再匹配，即目前 `s[i - 1] == p[j] && s[i] != p[j + 1] `，此时直接向后移动模式串，将 `p[next[j]]` 对齐到 `s[i-1]`\n    -   预处理思想与匹配相似，如果匹配不上，就回退到 `next` 对应位置，直到退到下标 0\n    \n- 代码模板\n\n    -   匹配过程\n\n        ```c++\n    \t// p[N] 匹配 s[M]\n    \tfor (int i = 1, j = 0; i <= M; ++i) // j 和 i 错开一位\n    \t{\n    \t    while (j && s[i] != p[j + 1]) j = next[j];\t// j 不能退到开头之前\n    \t    if (s[i] == p[j + 1]) ++j;\n    \t    if (j == N) \n    \t    { \n    \t        /* 匹配成功; */  \n    \t        j = next[j]; \t// 准备匹配下一次\n    \t    }\n    \t}\n    \t```\n    \n    -   预处理\n    \n        ```c++\n        for (int i = 2, j = 0; i <= N; ++i)\t// next[1] === 0\n        {\n            while (j && p[i] != p[j + 1]) j = next[j];\n            if (p[i] == p[j + 1]) ++j;\n            next[i] = j;\n        }\n        ```\n    \n    -   注意\n    \n        -   本模板字符串下标均从 1 开始\n\n### Trie 树\n\n-   核心思想\n-   作用\n    -   存储字符串\n    -   查找字符串\n-   实现\n    -   每个单词结尾的节点标记 `is_end = true`\n    -   类似数组模拟链表，用 `tot` 表示当前位置\n\n### 并查集\n\n-   核心思想\n\n    -   路径压缩\n\n    \t>    ​\t我愿将之称为最优美的一行代码\n\n    \t```c++\n    \treturn x == parent[x]? x: parent[x] = find(parent[x]);\n    \t```\n\n    -   按秩合并\n    \n        ```c++\n        if (rank[fy] > rank[fx]) swap(fy, fx);\n        parent[fy] = fx;\n        if (rank[fx] == rank[fy]) rank[fx]++;\n        ```\n    \n-   作用\n\n    -   合并区间\n    -   查询是否同类\n\n-   复杂度\n\n    -   $O(\\alpha(N))$\n\n### 二叉堆\n\n-   核心操作\n    -   Down\n        -   和较小的孩子交换\n        -   继续 Down\n    -   Up\n        -   和父亲交换\n        -   继续 Up\n\n-   实现操作\n\n    -   建堆\n\n        -   从 $n/2$ 到 1 执行 down 操作\n        -   跳过了最后一层叶子节点\n        -   复杂度 $O(N)$\n\n    -   插入\n\n        ```c++\n        heap[++tot] = x, up(tot);\n        ```\n\n    -   删除\n\n        ```c++\n        heap[k] = heap[tot--], if (k != 1) up(k), down(k);\t// up 和 down 至多执行一个\n        ```\n\n    -   修改\n\n        ```c++\n        heap[k] = x, up(k), down(k);\n        ```\n\n    -   修改第 k 个元素\n\n        -   每个元素额外处理两个“指针”\n        -   ph[k] 储存索引 i\n        -   hp[i] 储存索引 i 对应的元素 k\n\n        -   swap 需要交换 ph[hp[a]], ph[hp[b]] 以及 hp[a] 和 hp[b]\n        -   交换完成后堆的元素和 ph 依旧是双向指向关系。交换 ph 修改 ph 指向堆的指针，交换 hp 修改堆指向 ph 的指针\n\n### 散列表\n\n## 搜索与图论\n\n### 搜索\n\n-   深度优先\n    -   数据结构\n        -   栈\n    -   空间\n        -   $O(h)$\n    -   思想\n        -   回溯\n        -   剪枝\n    -   关键操作\n        -   恢复现场\n-   广度优先\n    -   数据结构\n        -   队列\n    -   空间\n        -   $O(2^h)$\n    -   性质\n        -   具有最短路性质\n        -   要求边权相等才可以用于求最短路\n\n### 图\n\n-   图的储存\n    -   邻接矩阵\n    -   邻接表\n        -   链式前向星\n    \n-   拓扑排序\n    \n    -   拓扑序列\n        -   拓扑序列的边一定从前向后\n        -   只针对有向图\n        -   有向无环图一定存在拓扑序列\n    -   拓扑排序\n        -   入度为 0 的点可以排在当前序列最前作为入口\n        -   入度为 0 的点入队\n        -   BFS 枚举所有出边并删掉\n        -   新的入度为 0 的点入队\n        -   队空结束\n    \n\n### 最短路问题\n\n-   分类\n    -   单源最短路\n        -   正权图\n        -   负权图\n    -   多源汇最短路\n-   难点\n    -   抽象原问题到最短路问题\n    -   建图\n-   方法\n    -   朴素 Dijkstra\n        -   复杂度 $O(V^2)$\n    -   堆优化 Dijkstra\n        -   复杂度 $O(E\\log V)$\n    -   Bellman-Ford 算法\n    \n        -  循环 $k \\in [1, E]$ 次\n          -  此时的 dist 数组代表从初始点出发，经过不超过 k 条边的最短路径\n          -  如果一条最短路上有 $E$ 条边，则必有负环\n        -  每次循环遍历所有边，进行一次松弛操作\n    -   SPFA\n        -   队列优化的 Bellman-Ford\n        -   将松弛后的边入队\n\n### 判断负环\n\n-   SPFA\n    -   添加一个 cnt 数组\n    -   cnt 数组记录从初始点出发最短路径经过路径的边数\n    -   如果 $ cnt[x] \\geq V$ ，由抽屉原理可知存在负环\n","slug":"acwing-note","published":1,"updated":"2021-11-25T05:18:41.835Z","_id":"ckw3kx8ps00011cy5ak93fu82","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h1 id=\"AcWing-算法基础课笔记\"><a href=\"#AcWing-算法基础课笔记\" class=\"headerlink\" title=\"AcWing 算法基础课笔记\"></a>AcWing 算法基础课笔记</h1><blockquote>\n<p>  笔记内容最终将由 <code>markmap</code> 工具生成思维导图</p>\n</blockquote>\n<h2 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>  分治法</li>\n</ul>\n</li>\n<li><p>算法步骤</p>\n<ul>\n<li>确定分界点<ul>\n<li>  左端点</li>\n<li>  右端点</li>\n<li>  中间点</li>\n<li>  随机点</li>\n</ul>\n</li>\n<li>调整区间<ul>\n<li>  目标：使得左半边所有的数小于等于分界点，右半边所有的数大于等于分界点</li>\n<li>调整方法：<ul>\n<li>  暴力：直接开两个数组，扫描一遍</li>\n<li>  常用：左右各一个游标。左边找第一个大于分点的，右边找第一个小于分点的，然后交换即可</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>  递归处理</li>\n</ul>\n</li>\n<li><p>模板</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> q[], <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = q[(l + r) &gt;&gt; <span class=\"number\">1</span>], i = l - <span class=\"number\">1</span>, j = r + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> i++; <span class=\"keyword\">while</span> (q[i] &lt; x);</span><br><span class=\"line\">        <span class=\"keyword\">do</span> j--; <span class=\"keyword\">while</span> (q[j] &gt; x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; j) <span class=\"built_in\">swap</span>(q[i], q[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">quick_sort</span>(q, l, j);</span><br><span class=\"line\">    <span class=\"built_in\">quick_sort</span>(q, j + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>  归并</li>\n</ul>\n</li>\n<li><p>算法步骤</p>\n<ul>\n<li>  先递归左右两侧</li>\n<li>  左右有序数组合并成一个有序数组</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>充分不必要条件<ul>\n<li>  单调性</li>\n</ul>\n</li>\n<li>本质<ul>\n<li>  将序列按照某个性质从中间一分为二，二分法可以寻找两个性质的边界</li>\n</ul>\n</li>\n<li>关注点<ul>\n<li>  根据查找的答案属于哪个性质，确定更新方式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>模板</p>\n<ul>\n<li>  右侧二分</li>\n</ul>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找左边界</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = l + r &gt;&gt; <span class=\"number\">1</span>;\t<span class=\"comment\">// 不加 1 会出现 [l, l] 死循环</span></span><br><span class=\"line\">    <span class=\"built_in\">check</span>(m)? r = m; l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  左侧二分</li>\n</ul>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找右边界</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = l + r + <span class=\"number\">1</span>&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">check</span>(m)? l = m; r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>扩展</p>\n<ul>\n<li>浮点数二分<ul>\n<li>  停止条件是区间长度小于 $\\varepsilon$</li>\n<li>  不需要整数二分的考虑边界，直接往 <code>mid</code> 靠近即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"高精度\"><a href=\"#高精度\" class=\"headerlink\" title=\"高精度\"></a>高精度</h3><ul>\n<li>核心思想<ul>\n<li>  将大整数的每一位存入数组</li>\n<li>  先存低位，后存高位</li>\n</ul>\n</li>\n<li>优化<ul>\n<li>  一次存 4 位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h3><ul>\n<li>核心思想<ul>\n<li>  快速求出原数组里一段数的和</li>\n</ul>\n</li>\n<li>技巧<ul>\n<li>  定义 $S[0] = 0$ 可以减少很多特判</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h3><ul>\n<li>核心思想<ul>\n<li>  前缀和的逆运算，构造一个数组使得该数组的前缀和为原数组</li>\n</ul>\n</li>\n<li>技巧<ul>\n<li>  在差分数组里做出两个修改 <code>b[l] += c, b[r + 1] -= c</code> 等价于原数组 <code>a[l: r] += c</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>优化暴力二重循环到 $O(N)$ 复杂度</li>\n</ul>\n</li>\n<li><p>模板</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; i &amp;&amp; <span class=\"built_in\">check</span>(i, j)) ++j;</span><br><span class=\"line\">    <span class=\"comment\">/* Do sth here */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h3><ul>\n<li>核心思想<ul>\n<li>  跨度较大但稀疏的整数映射到排序后的下标</li>\n<li>  核心是保序和二分查找</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"区间合并\"><a href=\"#区间合并\" class=\"headerlink\" title=\"区间合并\"></a>区间合并</h3><ul>\n<li>算法步骤<ul>\n<li>  按区间左端点排序</li>\n<li>扫描过程中维护一个当前区间，考虑下一个区间和当前区间的关系<ul>\n<li>  包含：不处理</li>\n<li>  相交：更新当前区间右端点</li>\n<li>  相离：当前区间结束，更新左右端点为新区间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><ul>\n<li>动态链表<ul>\n<li>  每次 new 一个 Node ，较慢</li>\n</ul>\n</li>\n<li>静态链表<ul>\n<li>  数组模拟 Elem 和 Next 域，快</li>\n<li>应用<ul>\n<li>  邻接表</li>\n<li>  链式前向星</li>\n</ul>\n</li>\n<li>扩展<ul>\n<li>双向链表<ul>\n<li>  模拟 Prev 域和 Next 域</li>\n<li>  维护一个 head 变量和一个 tail 变量</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><ul>\n<li>常见题型<ul>\n<li>  给定序列，求每一个数左边最近的最小数</li>\n</ul>\n</li>\n<li>时间复杂度<ul>\n<li>  <code>O(N)</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h3><ul>\n<li>常见题型<ul>\n<li>  滑动窗口最值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>  暴力思想中，当前匹配失败，会有部分串已匹配</li>\n<li>  记录向后移动多少可以使得已匹配的串和新的位置仍然匹配</li>\n<li>  这个记录只和模板串有关！这就是 Next 数组</li>\n<li>  <code>next[i] = j</code> 意味着 <code>p[1..=j] == p[i - j + 1..=i]</code></li>\n<li>  假设从 <code>s[i]</code> 开始不再匹配，即目前 <code>s[i - 1] == p[j] &amp;&amp; s[i] != p[j + 1] </code>，此时直接向后移动模式串，将 <code>p[next[j]]</code> 对齐到 <code>s[i-1]</code></li>\n<li>预处理思想与匹配相似，如果匹配不上，就回退到 <code>next</code> 对应位置，直到退到下标 0</li>\n</ul>\n</li>\n<li><p>代码模板</p>\n<ul>\n<li><p>匹配过程</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p[N] 匹配 s[M]</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &lt;= M; ++i) <span class=\"comment\">// j 和 i 错开一位</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &amp;&amp; s[i] != p[j + <span class=\"number\">1</span>]) j = next[j];\t<span class=\"comment\">// j 不能退到开头之前</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] == p[j + <span class=\"number\">1</span>]) ++j;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == N) </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* 匹配成功; */</span>  </span><br><span class=\"line\">        j = next[j]; \t<span class=\"comment\">// 准备匹配下一次</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>预处理</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>, j = <span class=\"number\">0</span>; i &lt;= N; ++i)\t<span class=\"comment\">// next[1] === 0</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &amp;&amp; p[i] != p[j + <span class=\"number\">1</span>]) j = next[j];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[i] == p[j + <span class=\"number\">1</span>]) ++j;</span><br><span class=\"line\">    next[i] = j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>注意</p>\n<ul>\n<li>  本模板字符串下标均从 1 开始</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Trie-树\"><a href=\"#Trie-树\" class=\"headerlink\" title=\"Trie 树\"></a>Trie 树</h3><ul>\n<li>  核心思想</li>\n<li>作用<ul>\n<li>  存储字符串</li>\n<li>  查找字符串</li>\n</ul>\n</li>\n<li>实现<ul>\n<li>  每个单词结尾的节点标记 <code>is_end = true</code></li>\n<li>  类似数组模拟链表，用 <code>tot</code> 表示当前位置</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li><p>路径压缩</p>\n<blockquote>\n<p>   ​    我愿将之称为最优美的一行代码</p>\n</blockquote>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> x == parent[x]? x: parent[x] = <span class=\"built_in\">find</span>(parent[x]);</span><br></pre></td></tr></table></figure></li>\n<li><p>按秩合并</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (rank[fy] &gt; rank[fx]) <span class=\"built_in\">swap</span>(fy, fx);</span><br><span class=\"line\">parent[fy] = fx;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (rank[fx] == rank[fy]) rank[fx]++;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>作用</p>\n<ul>\n<li>  合并区间</li>\n<li>  查询是否同类</li>\n</ul>\n</li>\n<li><p>复杂度</p>\n<ul>\n<li>  $O(\\alpha(N))$</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a>二叉堆</h3><ul>\n<li><p>核心操作</p>\n<ul>\n<li>Down<ul>\n<li>  和较小的孩子交换</li>\n<li>  继续 Down</li>\n</ul>\n</li>\n<li>Up<ul>\n<li>  和父亲交换</li>\n<li>  继续 Up</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实现操作</p>\n<ul>\n<li><p>建堆</p>\n<ul>\n<li>  从 $n/2$ 到 1 执行 down 操作</li>\n<li>  跳过了最后一层叶子节点</li>\n<li>  复杂度 $O(N)$</li>\n</ul>\n</li>\n<li><p>插入</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heap[++tot] = x, <span class=\"built_in\">up</span>(tot);</span><br></pre></td></tr></table></figure></li>\n<li><p>删除</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heap[k] = heap[tot--], <span class=\"keyword\">if</span> (k != <span class=\"number\">1</span>) <span class=\"built_in\">up</span>(k), <span class=\"built_in\">down</span>(k);\t<span class=\"comment\">// up 和 down 至多执行一个</span></span><br></pre></td></tr></table></figure></li>\n<li><p>修改</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heap[k] = x, <span class=\"built_in\">up</span>(k), <span class=\"built_in\">down</span>(k);</span><br></pre></td></tr></table></figure></li>\n<li><p>修改第 k 个元素</p>\n<ul>\n<li><p>  每个元素额外处理两个“指针”</p>\n</li>\n<li><p>  ph[k] 储存索引 i</p>\n</li>\n<li><p>  hp[i] 储存索引 i 对应的元素 k</p>\n</li>\n<li><p>  swap 需要交换 ph[hp[a]], ph[hp[b]] 以及 hp[a] 和 hp[b]</p>\n</li>\n<li><p>  交换完成后堆的元素和 ph 依旧是双向指向关系。交换 ph 修改 ph 指向堆的指针，交换 hp 修改堆指向 ph 的指针</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h3><h2 id=\"搜索与图论\"><a href=\"#搜索与图论\" class=\"headerlink\" title=\"搜索与图论\"></a>搜索与图论</h2><h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><ul>\n<li>深度优先<ul>\n<li>数据结构<ul>\n<li>  栈</li>\n</ul>\n</li>\n<li>空间<ul>\n<li>  $O(h)$</li>\n</ul>\n</li>\n<li>思想<ul>\n<li>  回溯</li>\n<li>  剪枝</li>\n</ul>\n</li>\n<li>关键操作<ul>\n<li>  恢复现场</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>广度优先<ul>\n<li>数据结构<ul>\n<li>  队列</li>\n</ul>\n</li>\n<li>空间<ul>\n<li>  $O(2^h)$</li>\n</ul>\n</li>\n<li>性质<ul>\n<li>  具有最短路性质</li>\n<li>  要求边权相等才可以用于求最短路</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><ul>\n<li>图的储存<ul>\n<li>  邻接矩阵</li>\n<li>邻接表<ul>\n<li>  链式前向星</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>拓扑排序<ul>\n<li>拓扑序列<ul>\n<li>  拓扑序列的边一定从前向后</li>\n<li>  只针对有向图</li>\n<li>  有向无环图一定存在拓扑序列</li>\n</ul>\n</li>\n<li>拓扑排序<ul>\n<li>  入度为 0 的点可以排在当前序列最前作为入口</li>\n<li>  入度为 0 的点入队</li>\n<li>  BFS 枚举所有出边并删掉</li>\n<li>  新的入度为 0 的点入队</li>\n<li>  队空结束</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"最短路问题\"><a href=\"#最短路问题\" class=\"headerlink\" title=\"最短路问题\"></a>最短路问题</h3><ul>\n<li>分类<ul>\n<li>单源最短路<ul>\n<li>  正权图</li>\n<li>  负权图</li>\n</ul>\n</li>\n<li>  多源汇最短路</li>\n</ul>\n</li>\n<li>难点<ul>\n<li>  抽象原问题到最短路问题</li>\n<li>  建图</li>\n</ul>\n</li>\n<li>方法<ul>\n<li>朴素 Dijkstra<ul>\n<li>  复杂度 $O(V^2)$</li>\n</ul>\n</li>\n<li>堆优化 Dijkstra<ul>\n<li>  复杂度 $O(E\\log V)$</li>\n</ul>\n</li>\n<li>Bellman-Ford 算法<ul>\n<li> 循环 $k \\in [1, E]$ 次    -  此时的 dist 数组代表从初始点出发，经过不超过 k 条边的最短路径    -  如果一条最短路上有 $E$ 条边，则必有负环</li>\n<li> 每次循环遍历所有边，进行一次松弛操作</li>\n</ul>\n</li>\n<li>SPFA<ul>\n<li>  队列优化的 Bellman-Ford</li>\n<li>  将松弛后的边入队</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"判断负环\"><a href=\"#判断负环\" class=\"headerlink\" title=\"判断负环\"></a>判断负环</h3><ul>\n<li>SPFA<ul>\n<li>  添加一个 cnt 数组</li>\n<li>  cnt 数组记录从初始点出发最短路径经过路径的边数</li>\n<li>  如果 $ cnt[x] \\geq V$ ，由抽屉原理可知存在负环</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"AcWing-算法基础课笔记\"><a href=\"#AcWing-算法基础课笔记\" class=\"headerlink\" title=\"AcWing 算法基础课笔记\"></a>AcWing 算法基础课笔记</h1><blockquote>\n<p>  笔记内容最终将由 <code>markmap</code> 工具生成思维导图</p>\n</blockquote>\n<h2 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>  分治法</li>\n</ul>\n</li>\n<li><p>算法步骤</p>\n<ul>\n<li>确定分界点<ul>\n<li>  左端点</li>\n<li>  右端点</li>\n<li>  中间点</li>\n<li>  随机点</li>\n</ul>\n</li>\n<li>调整区间<ul>\n<li>  目标：使得左半边所有的数小于等于分界点，右半边所有的数大于等于分界点</li>\n<li>调整方法：<ul>\n<li>  暴力：直接开两个数组，扫描一遍</li>\n<li>  常用：左右各一个游标。左边找第一个大于分点的，右边找第一个小于分点的，然后交换即可</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>  递归处理</li>\n</ul>\n</li>\n<li><p>模板</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> q[], <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = q[(l + r) &gt;&gt; <span class=\"number\">1</span>], i = l - <span class=\"number\">1</span>, j = r + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> i++; <span class=\"keyword\">while</span> (q[i] &lt; x);</span><br><span class=\"line\">        <span class=\"keyword\">do</span> j--; <span class=\"keyword\">while</span> (q[j] &gt; x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; j) <span class=\"built_in\">swap</span>(q[i], q[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">quick_sort</span>(q, l, j);</span><br><span class=\"line\">    <span class=\"built_in\">quick_sort</span>(q, j + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>  归并</li>\n</ul>\n</li>\n<li><p>算法步骤</p>\n<ul>\n<li>  先递归左右两侧</li>\n<li>  左右有序数组合并成一个有序数组</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>充分不必要条件<ul>\n<li>  单调性</li>\n</ul>\n</li>\n<li>本质<ul>\n<li>  将序列按照某个性质从中间一分为二，二分法可以寻找两个性质的边界</li>\n</ul>\n</li>\n<li>关注点<ul>\n<li>  根据查找的答案属于哪个性质，确定更新方式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>模板</p>\n<ul>\n<li>  右侧二分</li>\n</ul>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找左边界</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = l + r &gt;&gt; <span class=\"number\">1</span>;\t<span class=\"comment\">// 不加 1 会出现 [l, l] 死循环</span></span><br><span class=\"line\">    <span class=\"built_in\">check</span>(m)? r = m; l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  左侧二分</li>\n</ul>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找右边界</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = l + r + <span class=\"number\">1</span>&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">check</span>(m)? l = m; r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>扩展</p>\n<ul>\n<li>浮点数二分<ul>\n<li>  停止条件是区间长度小于 $\\varepsilon$</li>\n<li>  不需要整数二分的考虑边界，直接往 <code>mid</code> 靠近即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"高精度\"><a href=\"#高精度\" class=\"headerlink\" title=\"高精度\"></a>高精度</h3><ul>\n<li>核心思想<ul>\n<li>  将大整数的每一位存入数组</li>\n<li>  先存低位，后存高位</li>\n</ul>\n</li>\n<li>优化<ul>\n<li>  一次存 4 位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h3><ul>\n<li>核心思想<ul>\n<li>  快速求出原数组里一段数的和</li>\n</ul>\n</li>\n<li>技巧<ul>\n<li>  定义 $S[0] = 0$ 可以减少很多特判</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h3><ul>\n<li>核心思想<ul>\n<li>  前缀和的逆运算，构造一个数组使得该数组的前缀和为原数组</li>\n</ul>\n</li>\n<li>技巧<ul>\n<li>  在差分数组里做出两个修改 <code>b[l] += c, b[r + 1] -= c</code> 等价于原数组 <code>a[l: r] += c</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>优化暴力二重循环到 $O(N)$ 复杂度</li>\n</ul>\n</li>\n<li><p>模板</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; i &amp;&amp; <span class=\"built_in\">check</span>(i, j)) ++j;</span><br><span class=\"line\">    <span class=\"comment\">/* Do sth here */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h3><ul>\n<li>核心思想<ul>\n<li>  跨度较大但稀疏的整数映射到排序后的下标</li>\n<li>  核心是保序和二分查找</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"区间合并\"><a href=\"#区间合并\" class=\"headerlink\" title=\"区间合并\"></a>区间合并</h3><ul>\n<li>算法步骤<ul>\n<li>  按区间左端点排序</li>\n<li>扫描过程中维护一个当前区间，考虑下一个区间和当前区间的关系<ul>\n<li>  包含：不处理</li>\n<li>  相交：更新当前区间右端点</li>\n<li>  相离：当前区间结束，更新左右端点为新区间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><ul>\n<li>动态链表<ul>\n<li>  每次 new 一个 Node ，较慢</li>\n</ul>\n</li>\n<li>静态链表<ul>\n<li>  数组模拟 Elem 和 Next 域，快</li>\n<li>应用<ul>\n<li>  邻接表</li>\n<li>  链式前向星</li>\n</ul>\n</li>\n<li>扩展<ul>\n<li>双向链表<ul>\n<li>  模拟 Prev 域和 Next 域</li>\n<li>  维护一个 head 变量和一个 tail 变量</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><ul>\n<li>常见题型<ul>\n<li>  给定序列，求每一个数左边最近的最小数</li>\n</ul>\n</li>\n<li>时间复杂度<ul>\n<li>  <code>O(N)</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h3><ul>\n<li>常见题型<ul>\n<li>  滑动窗口最值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li>  暴力思想中，当前匹配失败，会有部分串已匹配</li>\n<li>  记录向后移动多少可以使得已匹配的串和新的位置仍然匹配</li>\n<li>  这个记录只和模板串有关！这就是 Next 数组</li>\n<li>  <code>next[i] = j</code> 意味着 <code>p[1..=j] == p[i - j + 1..=i]</code></li>\n<li>  假设从 <code>s[i]</code> 开始不再匹配，即目前 <code>s[i - 1] == p[j] &amp;&amp; s[i] != p[j + 1] </code>，此时直接向后移动模式串，将 <code>p[next[j]]</code> 对齐到 <code>s[i-1]</code></li>\n<li>预处理思想与匹配相似，如果匹配不上，就回退到 <code>next</code> 对应位置，直到退到下标 0</li>\n</ul>\n</li>\n<li><p>代码模板</p>\n<ul>\n<li><p>匹配过程</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p[N] 匹配 s[M]</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &lt;= M; ++i) <span class=\"comment\">// j 和 i 错开一位</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &amp;&amp; s[i] != p[j + <span class=\"number\">1</span>]) j = next[j];\t<span class=\"comment\">// j 不能退到开头之前</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] == p[j + <span class=\"number\">1</span>]) ++j;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == N) </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* 匹配成功; */</span>  </span><br><span class=\"line\">        j = next[j]; \t<span class=\"comment\">// 准备匹配下一次</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>预处理</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>, j = <span class=\"number\">0</span>; i &lt;= N; ++i)\t<span class=\"comment\">// next[1] === 0</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &amp;&amp; p[i] != p[j + <span class=\"number\">1</span>]) j = next[j];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[i] == p[j + <span class=\"number\">1</span>]) ++j;</span><br><span class=\"line\">    next[i] = j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>注意</p>\n<ul>\n<li>  本模板字符串下标均从 1 开始</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Trie-树\"><a href=\"#Trie-树\" class=\"headerlink\" title=\"Trie 树\"></a>Trie 树</h3><ul>\n<li>  核心思想</li>\n<li>作用<ul>\n<li>  存储字符串</li>\n<li>  查找字符串</li>\n</ul>\n</li>\n<li>实现<ul>\n<li>  每个单词结尾的节点标记 <code>is_end = true</code></li>\n<li>  类似数组模拟链表，用 <code>tot</code> 表示当前位置</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h3><ul>\n<li><p>核心思想</p>\n<ul>\n<li><p>路径压缩</p>\n<blockquote>\n<p>   ​    我愿将之称为最优美的一行代码</p>\n</blockquote>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> x == parent[x]? x: parent[x] = <span class=\"built_in\">find</span>(parent[x]);</span><br></pre></td></tr></table></figure></li>\n<li><p>按秩合并</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (rank[fy] &gt; rank[fx]) <span class=\"built_in\">swap</span>(fy, fx);</span><br><span class=\"line\">parent[fy] = fx;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (rank[fx] == rank[fy]) rank[fx]++;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>作用</p>\n<ul>\n<li>  合并区间</li>\n<li>  查询是否同类</li>\n</ul>\n</li>\n<li><p>复杂度</p>\n<ul>\n<li>  $O(\\alpha(N))$</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a>二叉堆</h3><ul>\n<li><p>核心操作</p>\n<ul>\n<li>Down<ul>\n<li>  和较小的孩子交换</li>\n<li>  继续 Down</li>\n</ul>\n</li>\n<li>Up<ul>\n<li>  和父亲交换</li>\n<li>  继续 Up</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实现操作</p>\n<ul>\n<li><p>建堆</p>\n<ul>\n<li>  从 $n/2$ 到 1 执行 down 操作</li>\n<li>  跳过了最后一层叶子节点</li>\n<li>  复杂度 $O(N)$</li>\n</ul>\n</li>\n<li><p>插入</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heap[++tot] = x, <span class=\"built_in\">up</span>(tot);</span><br></pre></td></tr></table></figure></li>\n<li><p>删除</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heap[k] = heap[tot--], <span class=\"keyword\">if</span> (k != <span class=\"number\">1</span>) <span class=\"built_in\">up</span>(k), <span class=\"built_in\">down</span>(k);\t<span class=\"comment\">// up 和 down 至多执行一个</span></span><br></pre></td></tr></table></figure></li>\n<li><p>修改</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heap[k] = x, <span class=\"built_in\">up</span>(k), <span class=\"built_in\">down</span>(k);</span><br></pre></td></tr></table></figure></li>\n<li><p>修改第 k 个元素</p>\n<ul>\n<li><p>  每个元素额外处理两个“指针”</p>\n</li>\n<li><p>  ph[k] 储存索引 i</p>\n</li>\n<li><p>  hp[i] 储存索引 i 对应的元素 k</p>\n</li>\n<li><p>  swap 需要交换 ph[hp[a]], ph[hp[b]] 以及 hp[a] 和 hp[b]</p>\n</li>\n<li><p>  交换完成后堆的元素和 ph 依旧是双向指向关系。交换 ph 修改 ph 指向堆的指针，交换 hp 修改堆指向 ph 的指针</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h3><h2 id=\"搜索与图论\"><a href=\"#搜索与图论\" class=\"headerlink\" title=\"搜索与图论\"></a>搜索与图论</h2><h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><ul>\n<li>深度优先<ul>\n<li>数据结构<ul>\n<li>  栈</li>\n</ul>\n</li>\n<li>空间<ul>\n<li>  $O(h)$</li>\n</ul>\n</li>\n<li>思想<ul>\n<li>  回溯</li>\n<li>  剪枝</li>\n</ul>\n</li>\n<li>关键操作<ul>\n<li>  恢复现场</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>广度优先<ul>\n<li>数据结构<ul>\n<li>  队列</li>\n</ul>\n</li>\n<li>空间<ul>\n<li>  $O(2^h)$</li>\n</ul>\n</li>\n<li>性质<ul>\n<li>  具有最短路性质</li>\n<li>  要求边权相等才可以用于求最短路</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><ul>\n<li>图的储存<ul>\n<li>  邻接矩阵</li>\n<li>邻接表<ul>\n<li>  链式前向星</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>拓扑排序<ul>\n<li>拓扑序列<ul>\n<li>  拓扑序列的边一定从前向后</li>\n<li>  只针对有向图</li>\n<li>  有向无环图一定存在拓扑序列</li>\n</ul>\n</li>\n<li>拓扑排序<ul>\n<li>  入度为 0 的点可以排在当前序列最前作为入口</li>\n<li>  入度为 0 的点入队</li>\n<li>  BFS 枚举所有出边并删掉</li>\n<li>  新的入度为 0 的点入队</li>\n<li>  队空结束</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"最短路问题\"><a href=\"#最短路问题\" class=\"headerlink\" title=\"最短路问题\"></a>最短路问题</h3><ul>\n<li>分类<ul>\n<li>单源最短路<ul>\n<li>  正权图</li>\n<li>  负权图</li>\n</ul>\n</li>\n<li>  多源汇最短路</li>\n</ul>\n</li>\n<li>难点<ul>\n<li>  抽象原问题到最短路问题</li>\n<li>  建图</li>\n</ul>\n</li>\n<li>方法<ul>\n<li>朴素 Dijkstra<ul>\n<li>  复杂度 $O(V^2)$</li>\n</ul>\n</li>\n<li>堆优化 Dijkstra<ul>\n<li>  复杂度 $O(E\\log V)$</li>\n</ul>\n</li>\n<li>Bellman-Ford 算法<ul>\n<li> 循环 $k \\in [1, E]$ 次    -  此时的 dist 数组代表从初始点出发，经过不超过 k 条边的最短路径    -  如果一条最短路上有 $E$ 条边，则必有负环</li>\n<li> 每次循环遍历所有边，进行一次松弛操作</li>\n</ul>\n</li>\n<li>SPFA<ul>\n<li>  队列优化的 Bellman-Ford</li>\n<li>  将松弛后的边入队</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"判断负环\"><a href=\"#判断负环\" class=\"headerlink\" title=\"判断负环\"></a>判断负环</h3><ul>\n<li>SPFA<ul>\n<li>  添加一个 cnt 数组</li>\n<li>  cnt 数组记录从初始点出发最短路径经过路径的边数</li>\n<li>  如果 $ cnt[x] \\geq V$ ，由抽屉原理可知存在负环</li>\n</ul>\n</li>\n</ul>\n"},{"title":"LeetCode 双周赛 61","date":"2021-09-19T06:56:09.000Z","_content":"\n---\n\n# LeetCode 双周赛 61\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/maximum-earnings-from-taxi/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1103 / 2534 | MiracleSNeko | 7    | 1:33:40  | 0:02:08                                                      | 0:48:40 9                                                    |                                                              |                                                              |\n\n## T1 2006. 差的绝对值为 K 的数对数目\n\n-   **通过的用户数**1773\n-   **尝试过的用户数**1793\n-   **用户总通过次数**1806\n-   **用户总提交次数**1985\n-   **题目难度** **Easy**\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你返回数对 `(i, j)` 的数目，满足 `i < j` 且 `|nums[i] - nums[j]| == k` 。\n\n`|x|` 的值定义为：\n\n-   如果 `x >= 0` ，那么值为 `x` 。\n-   如果 `x < 0` ，那么值为 `-x` 。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,2,1], k = 1\n输出：4\n解释：差的绝对值为 1 的数对为：\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,3], k = 3\n输出：0\n解释：没有任何数对差的绝对值为 3 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1,5,4], k = 2\n输出：3\n解释：差的绝对值为 2 的数对为：\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 200`\n-   `1 <= nums[i] <= 100`\n-   `1 <= k <= 99`\n\n>   T1 的数据量暴力就完事了\n\n**我的提交：**\n\n```c++\nclass Solution\n{\npublic:\n    int countKDifference(std::vector<int> &nums, int k)\n    {\n        auto len = nums.size();\n        auto ans = 0;\n        for (auto i = 0; i < len; ++i)\n        {\n            auto vi = nums[i];\n            for (auto j = i; j < len; ++j)\n            {\n                auto vj = nums[j];\n                if (abs(vi - vj) == k) ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T2 2007. 从双倍数组中还原原数组\n\n-   **通过的用户数**1149\n-   **尝试过的用户数**1598\n-   **用户总通过次数**1187\n-   **用户总提交次数**5278\n-   **题目难度** **Medium**\n\n一个整数数组 `original` 可以转变成一个 **双倍** 数组 `changed` ，转变方式为将 `original` 中每个元素 **值乘以 2** 加入数组中，然后将所有元素 **随机打乱** 。\n\n给你一个数组 `changed` ，如果 `change` 是 **双倍** 数组，那么请你返回 `original`数组，否则请返回空数组。`original` 的元素可以以 **任意** 顺序返回。\n\n**示例 1：**\n\n```\n输入：changed = [1,3,4,2,6,8]\n输出：[1,3,4]\n解释：一个可能的 original 数组为 [1,3,4] :\n- 将 1 乘以 2 ，得到 1 * 2 = 2 。\n- 将 3 乘以 2 ，得到 3 * 2 = 6 。\n- 将 4 乘以 2 ，得到 4 * 2 = 8 。\n其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。\n```\n\n**示例 2：**\n\n```\n输入：changed = [6,3,0,1]\n输出：[]\n解释：changed 不是一个双倍数组。\n```\n\n**示例 3：**\n\n```\n输入：changed = [1]\n输出：[]\n解释：changed 不是一个双倍数组。\n```\n\n**提示：**\n\n-   `1 <= changed.length <= 105`\n-   `0 <= changed[i] <= 105`\n\n**我的提交：**\n\n>   写的时候用数组折腾来折腾去 WA 的死去活来 （9次啊9次），后来发现不如 `std::map` 减减乐\n\n```c++\n// 这个破代码还可以改很多地方\n// 但是如果是用 Rust 写怕不是就炸了，一个 map 在做迭代器的时候还要被改\nclass Solution\n{\npublic:\n    Veci findOriginalArray(Veci &changed)\n    {\n        Veci ans;\n        std::sort(ALL(changed));\n        auto st = UpperBS(changed, 0);\n        if ((st & 1) != 0)\n            return Veci();\n        for (auto i = 0; i < st; i += 2)\n        {\n            ans.push_back(0);\n        }\n        changed = Veci(changed.begin() + st, changed.end());\n        auto len = changed.size();\n        if ((len & 1) != 0)\n            return Veci();\n        Veci odd;\n        std::map<i32, i32> even;\n        for (auto &val : changed)\n        {\n            if ((val & 1) == 0)\n            {\n                if (even.count(val) == 0)\n                {\n                    even[val] = 1;\n                }\n                else\n                {\n                    even[val] += 1;\n                }\n            }\n            else\n            {\n                odd.push_back(val);\n            }\n        }\n        for (auto ii : odd)\n        {\n            if (even.count(2 * ii) == 0 || even[2 * ii] == 0)\n                return Veci();\n            ans.push_back(ii);\n            even[2 * ii] -= 1;\n        }\n        for(auto [k, v]: even)\n        {\n            if (v == 0) continue;\n            if (even.count(2 * k) == 0) return Veci();\n            while(v--)\n            {\n                ans.push_back(k);\n                even[2 * k] -= 1;\n                if (even[2 * k] < 0) return Veci();\n            }\n        }\n        return ans;\n    }\n};\n```\n\n**题解：**\n\n小的值优先匹配小的，所以先用sort进行排序\n然后可以将暂时没匹配到的数字存放至队列中，使用队列也是为了优先匹配小的，小的先进，小的先出。\n每次等到匹配到的时候，就将队列中的数取出。最后判断队列是否为空。\n\n```c++\nclass Solution {\npublic:\n    vector<int> findOriginalArray(vector<int>& changed) {\n        sort(changed.begin(),changed.end());\n        queue<int> q;\n        vector<int> res,empty;\n        int n = changed.size();\n        if(n%2)return empty;\n        for(int i=0;i<n;i++){\n            if(q.empty())\n                q.push(changed[i]);\n            else{\n                if(q.front()*2 == changed[i]){\n                    res.push_back(q.front());\n                    q.pop();\n                }\n                else\n                    q.push(changed[i]);\n            }\n        }\n        if(!q.empty())\n            return empty;\n        return res;\n    }\n};\n\n作者：zhu-146\n链接：https://leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/pai-xu-dui-lie-by-zhu-146-a5bo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T3 2008. 出租车的最大盈利\n\n-   **通过的用户数**519\n-   **尝试过的用户数**832\n-   **用户总通过次数**543\n-   **用户总提交次数**1850\n-   **题目难度** **Medium**\n\n你驾驶出租车行驶在一条有 `n` 个地点的路上。这 `n` 个地点从近到远编号为 `1` 到 `n` ，你想要从 `1` 开到 `n` ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。\n\n乘客信息用一个下标从 **0** 开始的二维数组 `rides` 表示，其中 `rides[i] = [starti, endi, tipi]` 表示第 `i` 位乘客需要从地点 `starti` 前往 `endi` ，愿意支付 `tipi` 元的小费。\n\n**每一位** 你选择接单的乘客 `i` ，你可以 **盈利** `endi - starti + tipi` 元。你同时 **最多** 只能接一个订单。\n\n给你 `n` 和 `rides` ，请你返回在最优接单方案下，你能盈利 **最多** 多少元。\n\n**注意：**你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。\n\n**示例 1：**\n\n```\n输入：n = 5, rides = [[2,5,4],[1,5,1]]\n输出：7\n解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。\n```\n\n**示例 2：**\n\n```\n输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]\n输出：20\n解释：我们可以接以下乘客的订单：\n- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。\n- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。\n- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。\n我们总共获得 9 + 5 + 6 = 20 元。\n```\n\n**提示：**\n\n-   `1 <= n <= 105`\n-   `1 <= rides.length <= 3 * 104`\n-   `rides[i].length == 3`\n-   `1 <= start_i < end_i <= n`\n-   `1 <= tip_i <= 105`\n\n>   我也不知道我是怎么把这么明显的 DP 看成图的，可能是 T2 WA 麻了\n\n**题解：**\n\n定义 f[i] 表示行驶到 i 时的最大盈利。考虑状态转移，一方面，我们可以不接终点为 i 的乘客，这样有 f[i]=f[i-1]；另一方面，我们可以接所有终点为 i 的乘客中收益最大的，这样有 f[i] = \\max (f[start]+end-start+tip)  ，二者取最大值。\n\n最终答案为 f[n]。\n\n```c++\nclass Solution\n{\npublic:\n    i64 maxTaxiEarnings(i32 n, VecVec<i32> &rides)\n    {\n        auto dp = Vecl(n+1, 0);\n        auto prof = VecVec<std::tuple<i64, i64>>(n+1);\n        // 记录每个 end 对应的 start 和 tip\n        for(auto&& r: rides)\n        {\n            auto start = r[0], end = r[1], tip = r[2];\n            prof[end].push_back(TUPLE(start, tip));\n        }\n        FORINC(ed, 1, n+1)\n        {\n            dp[ed] = dp[ed - 1];\n            for(auto&& [st, tip]: prof[ed])\n            {\n                dp[ed] = std::max(dp[ed], dp[st] + ed - st + tip);\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n## T4 2009. 使数组连续的最少操作数\n\n-   **通过的用户数**353\n-   **尝试过的用户数**545\n-   **用户总通过次数**386\n-   **用户总提交次数**1243\n-   **题目难度** **Hard**\n\n给你一个整数数组 `nums` 。每一次操作中，你可以将 `nums` 中 **任意** 一个元素替换成 **任意** 整数。\n\n如果 `nums` 满足以下条件，那么它是 **连续的** ：\n\n-   `nums` 中所有元素都是 **互不相同** 的。\n-   `nums` 中 **最大** 元素与 **最小** 元素的差等于 `nums.length - 1` 。\n\n比方说，`nums = [4, 2, 5, 3]` 是 **连续的** ，但是 `nums = [1, 2, 3, 5, 6]` **不是连续的** 。\n\n请你返回使 `nums` **连续** 的 **最少** 操作次数。\n\n**示例 1：**\n\n```\n输入：nums = [4,2,5,3]\n输出：0\n解释：nums 已经是连续的了。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,5,6]\n输出：1\n解释：一个可能的解是将最后一个元素变为 4 。\n结果数组为 [1,2,3,5,4] ，是连续数组。\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,10,100,1000]\n输出：3\n解释：一个可能的解是：\n- 将第二个元素变为 2 。\n- 将第三个元素变为 3 。\n- 将第四个元素变为 4 。\n结果数组为 [1,2,3,4] ，是连续数组。\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 105`\n-   `1 <= nums[i] <= 109`\n\n","source":"_posts/biweekly-contest-61.md","raw":"---\ntitle: LeetCode 双周赛 61\ndate: 2021-09-19 14:56:09\ntags: LeetCode 周赛总结\n---\n\n---\n\n# LeetCode 双周赛 61\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/maximum-earnings-from-taxi/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1103 / 2534 | MiracleSNeko | 7    | 1:33:40  | 0:02:08                                                      | 0:48:40 9                                                    |                                                              |                                                              |\n\n## T1 2006. 差的绝对值为 K 的数对数目\n\n-   **通过的用户数**1773\n-   **尝试过的用户数**1793\n-   **用户总通过次数**1806\n-   **用户总提交次数**1985\n-   **题目难度** **Easy**\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你返回数对 `(i, j)` 的数目，满足 `i < j` 且 `|nums[i] - nums[j]| == k` 。\n\n`|x|` 的值定义为：\n\n-   如果 `x >= 0` ，那么值为 `x` 。\n-   如果 `x < 0` ，那么值为 `-x` 。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,2,1], k = 1\n输出：4\n解释：差的绝对值为 1 的数对为：\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,3], k = 3\n输出：0\n解释：没有任何数对差的绝对值为 3 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1,5,4], k = 2\n输出：3\n解释：差的绝对值为 2 的数对为：\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 200`\n-   `1 <= nums[i] <= 100`\n-   `1 <= k <= 99`\n\n>   T1 的数据量暴力就完事了\n\n**我的提交：**\n\n```c++\nclass Solution\n{\npublic:\n    int countKDifference(std::vector<int> &nums, int k)\n    {\n        auto len = nums.size();\n        auto ans = 0;\n        for (auto i = 0; i < len; ++i)\n        {\n            auto vi = nums[i];\n            for (auto j = i; j < len; ++j)\n            {\n                auto vj = nums[j];\n                if (abs(vi - vj) == k) ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T2 2007. 从双倍数组中还原原数组\n\n-   **通过的用户数**1149\n-   **尝试过的用户数**1598\n-   **用户总通过次数**1187\n-   **用户总提交次数**5278\n-   **题目难度** **Medium**\n\n一个整数数组 `original` 可以转变成一个 **双倍** 数组 `changed` ，转变方式为将 `original` 中每个元素 **值乘以 2** 加入数组中，然后将所有元素 **随机打乱** 。\n\n给你一个数组 `changed` ，如果 `change` 是 **双倍** 数组，那么请你返回 `original`数组，否则请返回空数组。`original` 的元素可以以 **任意** 顺序返回。\n\n**示例 1：**\n\n```\n输入：changed = [1,3,4,2,6,8]\n输出：[1,3,4]\n解释：一个可能的 original 数组为 [1,3,4] :\n- 将 1 乘以 2 ，得到 1 * 2 = 2 。\n- 将 3 乘以 2 ，得到 3 * 2 = 6 。\n- 将 4 乘以 2 ，得到 4 * 2 = 8 。\n其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。\n```\n\n**示例 2：**\n\n```\n输入：changed = [6,3,0,1]\n输出：[]\n解释：changed 不是一个双倍数组。\n```\n\n**示例 3：**\n\n```\n输入：changed = [1]\n输出：[]\n解释：changed 不是一个双倍数组。\n```\n\n**提示：**\n\n-   `1 <= changed.length <= 105`\n-   `0 <= changed[i] <= 105`\n\n**我的提交：**\n\n>   写的时候用数组折腾来折腾去 WA 的死去活来 （9次啊9次），后来发现不如 `std::map` 减减乐\n\n```c++\n// 这个破代码还可以改很多地方\n// 但是如果是用 Rust 写怕不是就炸了，一个 map 在做迭代器的时候还要被改\nclass Solution\n{\npublic:\n    Veci findOriginalArray(Veci &changed)\n    {\n        Veci ans;\n        std::sort(ALL(changed));\n        auto st = UpperBS(changed, 0);\n        if ((st & 1) != 0)\n            return Veci();\n        for (auto i = 0; i < st; i += 2)\n        {\n            ans.push_back(0);\n        }\n        changed = Veci(changed.begin() + st, changed.end());\n        auto len = changed.size();\n        if ((len & 1) != 0)\n            return Veci();\n        Veci odd;\n        std::map<i32, i32> even;\n        for (auto &val : changed)\n        {\n            if ((val & 1) == 0)\n            {\n                if (even.count(val) == 0)\n                {\n                    even[val] = 1;\n                }\n                else\n                {\n                    even[val] += 1;\n                }\n            }\n            else\n            {\n                odd.push_back(val);\n            }\n        }\n        for (auto ii : odd)\n        {\n            if (even.count(2 * ii) == 0 || even[2 * ii] == 0)\n                return Veci();\n            ans.push_back(ii);\n            even[2 * ii] -= 1;\n        }\n        for(auto [k, v]: even)\n        {\n            if (v == 0) continue;\n            if (even.count(2 * k) == 0) return Veci();\n            while(v--)\n            {\n                ans.push_back(k);\n                even[2 * k] -= 1;\n                if (even[2 * k] < 0) return Veci();\n            }\n        }\n        return ans;\n    }\n};\n```\n\n**题解：**\n\n小的值优先匹配小的，所以先用sort进行排序\n然后可以将暂时没匹配到的数字存放至队列中，使用队列也是为了优先匹配小的，小的先进，小的先出。\n每次等到匹配到的时候，就将队列中的数取出。最后判断队列是否为空。\n\n```c++\nclass Solution {\npublic:\n    vector<int> findOriginalArray(vector<int>& changed) {\n        sort(changed.begin(),changed.end());\n        queue<int> q;\n        vector<int> res,empty;\n        int n = changed.size();\n        if(n%2)return empty;\n        for(int i=0;i<n;i++){\n            if(q.empty())\n                q.push(changed[i]);\n            else{\n                if(q.front()*2 == changed[i]){\n                    res.push_back(q.front());\n                    q.pop();\n                }\n                else\n                    q.push(changed[i]);\n            }\n        }\n        if(!q.empty())\n            return empty;\n        return res;\n    }\n};\n\n作者：zhu-146\n链接：https://leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/pai-xu-dui-lie-by-zhu-146-a5bo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T3 2008. 出租车的最大盈利\n\n-   **通过的用户数**519\n-   **尝试过的用户数**832\n-   **用户总通过次数**543\n-   **用户总提交次数**1850\n-   **题目难度** **Medium**\n\n你驾驶出租车行驶在一条有 `n` 个地点的路上。这 `n` 个地点从近到远编号为 `1` 到 `n` ，你想要从 `1` 开到 `n` ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。\n\n乘客信息用一个下标从 **0** 开始的二维数组 `rides` 表示，其中 `rides[i] = [starti, endi, tipi]` 表示第 `i` 位乘客需要从地点 `starti` 前往 `endi` ，愿意支付 `tipi` 元的小费。\n\n**每一位** 你选择接单的乘客 `i` ，你可以 **盈利** `endi - starti + tipi` 元。你同时 **最多** 只能接一个订单。\n\n给你 `n` 和 `rides` ，请你返回在最优接单方案下，你能盈利 **最多** 多少元。\n\n**注意：**你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。\n\n**示例 1：**\n\n```\n输入：n = 5, rides = [[2,5,4],[1,5,1]]\n输出：7\n解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。\n```\n\n**示例 2：**\n\n```\n输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]\n输出：20\n解释：我们可以接以下乘客的订单：\n- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。\n- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。\n- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。\n我们总共获得 9 + 5 + 6 = 20 元。\n```\n\n**提示：**\n\n-   `1 <= n <= 105`\n-   `1 <= rides.length <= 3 * 104`\n-   `rides[i].length == 3`\n-   `1 <= start_i < end_i <= n`\n-   `1 <= tip_i <= 105`\n\n>   我也不知道我是怎么把这么明显的 DP 看成图的，可能是 T2 WA 麻了\n\n**题解：**\n\n定义 f[i] 表示行驶到 i 时的最大盈利。考虑状态转移，一方面，我们可以不接终点为 i 的乘客，这样有 f[i]=f[i-1]；另一方面，我们可以接所有终点为 i 的乘客中收益最大的，这样有 f[i] = \\max (f[start]+end-start+tip)  ，二者取最大值。\n\n最终答案为 f[n]。\n\n```c++\nclass Solution\n{\npublic:\n    i64 maxTaxiEarnings(i32 n, VecVec<i32> &rides)\n    {\n        auto dp = Vecl(n+1, 0);\n        auto prof = VecVec<std::tuple<i64, i64>>(n+1);\n        // 记录每个 end 对应的 start 和 tip\n        for(auto&& r: rides)\n        {\n            auto start = r[0], end = r[1], tip = r[2];\n            prof[end].push_back(TUPLE(start, tip));\n        }\n        FORINC(ed, 1, n+1)\n        {\n            dp[ed] = dp[ed - 1];\n            for(auto&& [st, tip]: prof[ed])\n            {\n                dp[ed] = std::max(dp[ed], dp[st] + ed - st + tip);\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n## T4 2009. 使数组连续的最少操作数\n\n-   **通过的用户数**353\n-   **尝试过的用户数**545\n-   **用户总通过次数**386\n-   **用户总提交次数**1243\n-   **题目难度** **Hard**\n\n给你一个整数数组 `nums` 。每一次操作中，你可以将 `nums` 中 **任意** 一个元素替换成 **任意** 整数。\n\n如果 `nums` 满足以下条件，那么它是 **连续的** ：\n\n-   `nums` 中所有元素都是 **互不相同** 的。\n-   `nums` 中 **最大** 元素与 **最小** 元素的差等于 `nums.length - 1` 。\n\n比方说，`nums = [4, 2, 5, 3]` 是 **连续的** ，但是 `nums = [1, 2, 3, 5, 6]` **不是连续的** 。\n\n请你返回使 `nums` **连续** 的 **最少** 操作次数。\n\n**示例 1：**\n\n```\n输入：nums = [4,2,5,3]\n输出：0\n解释：nums 已经是连续的了。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,5,6]\n输出：1\n解释：一个可能的解是将最后一个元素变为 4 。\n结果数组为 [1,2,3,5,4] ，是连续数组。\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,10,100,1000]\n输出：3\n解释：一个可能的解是：\n- 将第二个元素变为 2 。\n- 将第三个元素变为 3 。\n- 将第四个元素变为 4 。\n结果数组为 [1,2,3,4] ，是连续数组。\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 105`\n-   `1 <= nums[i] <= 109`\n\n","slug":"biweekly-contest-61","published":1,"updated":"2021-11-17T05:21:51.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8pu00021cy5cq0d2frc","content":"<hr>\n<h1 id=\"LeetCode-双周赛-61\"><a href=\"#LeetCode-双周赛-61\" class=\"headerlink\" title=\"LeetCode 双周赛 61\"></a>LeetCode 双周赛 61</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/maximum-earnings-from-taxi/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1103 / 2534</td>\n<td>MiracleSNeko</td>\n<td>7</td>\n<td>1:33:40</td>\n<td>0:02:08</td>\n<td>0:48:40 9</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-2006-差的绝对值为-K-的数对数目\"><a href=\"#T1-2006-差的绝对值为-K-的数对数目\" class=\"headerlink\" title=\"T1 2006. 差的绝对值为 K 的数对数目\"></a>T1 2006. 差的绝对值为 K 的数对数目</h2><ul>\n<li>  <strong>通过的用户数</strong>1773</li>\n<li>  <strong>尝试过的用户数</strong>1793</li>\n<li>  <strong>用户总通过次数</strong>1806</li>\n<li>  <strong>用户总提交次数</strong>1985</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回数对 <code>(i, j)</code> 的数目，满足 <code>i &lt; j</code> 且 <code>|nums[i] - nums[j]| == k</code> 。</p>\n<p><code>|x|</code> 的值定义为：</p>\n<ul>\n<li>  如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li>\n<li>  如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,2,1], k = 1</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：差的绝对值为 1 的数对为：</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3], k = 3</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：没有任何数对差的绝对值为 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1,5,4], k = 2</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：差的绝对值为 2 的数对为：</span><br><span class=\"line\">- [3,2,1,5,4]</span><br><span class=\"line\">- [3,2,1,5,4]</span><br><span class=\"line\">- [3,2,1,5,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 100</code></li>\n<li>  <code>1 &lt;= k &lt;= 99</code></li>\n</ul>\n<blockquote>\n<p>  T1 的数据量暴力就完事了</p>\n</blockquote>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countKDifference</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; len; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> vi = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> j = i; j &lt; len; ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> vj = nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(vi - vj) == k) ans++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-2007-从双倍数组中还原原数组\"><a href=\"#T2-2007-从双倍数组中还原原数组\" class=\"headerlink\" title=\"T2 2007. 从双倍数组中还原原数组\"></a>T2 2007. 从双倍数组中还原原数组</h2><ul>\n<li>  <strong>通过的用户数</strong>1149</li>\n<li>  <strong>尝试过的用户数</strong>1598</li>\n<li>  <strong>用户总通过次数</strong>1187</li>\n<li>  <strong>用户总提交次数</strong>5278</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>一个整数数组 <code>original</code> 可以转变成一个 <strong>双倍</strong> 数组 <code>changed</code> ，转变方式为将 <code>original</code> 中每个元素 <strong>值乘以 2</strong> 加入数组中，然后将所有元素 <strong>随机打乱</strong> 。</p>\n<p>给你一个数组 <code>changed</code> ，如果 <code>change</code> 是 <strong>双倍</strong> 数组，那么请你返回 <code>original</code>数组，否则请返回空数组。<code>original</code> 的元素可以以 <strong>任意</strong> 顺序返回。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [1,3,4,2,6,8]</span><br><span class=\"line\">输出：[1,3,4]</span><br><span class=\"line\">解释：一个可能的 original 数组为 [1,3,4] :</span><br><span class=\"line\">- 将 1 乘以 2 ，得到 1 * 2 = 2 。</span><br><span class=\"line\">- 将 3 乘以 2 ，得到 3 * 2 = 6 。</span><br><span class=\"line\">- 将 4 乘以 2 ，得到 4 * 2 = 8 。</span><br><span class=\"line\">其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [6,3,0,1]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [1]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= changed.length &lt;= 105</code></li>\n<li>  <code>0 &lt;= changed[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  写的时候用数组折腾来折腾去 WA 的死去活来 （9次啊9次），后来发现不如 <code>std::map</code> 减减乐</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个破代码还可以改很多地方</span></span><br><span class=\"line\"><span class=\"comment\">// 但是如果是用 Rust 写怕不是就炸了，一个 map 在做迭代器的时候还要被改</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Veci <span class=\"title\">findOriginalArray</span><span class=\"params\">(Veci &amp;changed)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Veci ans;</span><br><span class=\"line\">        std::<span class=\"built_in\">sort</span>(<span class=\"built_in\">ALL</span>(changed));</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> st = <span class=\"built_in\">UpperBS</span>(changed, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((st &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; st; i += <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        changed = <span class=\"built_in\">Veci</span>(changed.<span class=\"built_in\">begin</span>() + st, changed.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = changed.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((len &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">        Veci odd;</span><br><span class=\"line\">        std::map&lt;i32, i32&gt; even;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;val : changed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((val &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(val) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    even[val] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    even[val] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                odd.<span class=\"built_in\">push_back</span>(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> ii : odd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(<span class=\"number\">2</span> * ii) == <span class=\"number\">0</span> || even[<span class=\"number\">2</span> * ii] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(ii);</span><br><span class=\"line\">            even[<span class=\"number\">2</span> * ii] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> [k, v]: even)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(<span class=\"number\">2</span> * k) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(v--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(k);</span><br><span class=\"line\">                even[<span class=\"number\">2</span> * k] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (even[<span class=\"number\">2</span> * k] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<p>小的值优先匹配小的，所以先用sort进行排序<br>然后可以将暂时没匹配到的数字存放至队列中，使用队列也是为了优先匹配小的，小的先进，小的先出。<br>每次等到匹配到的时候，就将队列中的数取出。最后判断队列是否为空。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findOriginalArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; changed)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(changed.<span class=\"built_in\">begin</span>(),changed.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; res,empty;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = changed.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>)<span class=\"keyword\">return</span> empty;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(changed[i]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(q.<span class=\"built_in\">front</span>()*<span class=\"number\">2</span> == changed[i])&#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(q.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">                    q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(changed[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> empty;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：zhu<span class=\"number\">-146</span></span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/pai-xu-dui-lie-by-zhu-146-a5bo/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-2008-出租车的最大盈利\"><a href=\"#T3-2008-出租车的最大盈利\" class=\"headerlink\" title=\"T3 2008. 出租车的最大盈利\"></a>T3 2008. 出租车的最大盈利</h2><ul>\n<li>  <strong>通过的用户数</strong>519</li>\n<li>  <strong>尝试过的用户数</strong>832</li>\n<li>  <strong>用户总通过次数</strong>543</li>\n<li>  <strong>用户总提交次数</strong>1850</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>你驾驶出租车行驶在一条有 <code>n</code> 个地点的路上。这 <code>n</code> 个地点从近到远编号为 <code>1</code> 到 <code>n</code> ，你想要从 <code>1</code> 开到 <code>n</code> ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。</p>\n<p>乘客信息用一个下标从 <strong>0</strong> 开始的二维数组 <code>rides</code> 表示，其中 <code>rides[i] = [starti, endi, tipi]</code> 表示第 <code>i</code> 位乘客需要从地点 <code>starti</code> 前往 <code>endi</code> ，愿意支付 <code>tipi</code> 元的小费。</p>\n<p><strong>每一位</strong> 你选择接单的乘客 <code>i</code> ，你可以 <strong>盈利</strong> <code>endi - starti + tipi</code> 元。你同时 <strong>最多</strong> 只能接一个订单。</p>\n<p>给你 <code>n</code> 和 <code>rides</code> ，请你返回在最优接单方案下，你能盈利 <strong>最多</strong> 多少元。</p>\n<p><strong>注意：</strong>你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, rides = [[2,5,4],[1,5,1]]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]</span><br><span class=\"line\">输出：20</span><br><span class=\"line\">解释：我们可以接以下乘客的订单：</span><br><span class=\"line\">- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。</span><br><span class=\"line\">- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。</span><br><span class=\"line\">- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。</span><br><span class=\"line\">我们总共获得 9 + 5 + 6 = 20 元。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>1 &lt;= rides.length &lt;= 3 * 104</code></li>\n<li>  <code>rides[i].length == 3</code></li>\n<li>  <code>1 &lt;= start_i &lt; end_i &lt;= n</code></li>\n<li>  <code>1 &lt;= tip_i &lt;= 105</code></li>\n</ul>\n<blockquote>\n<p>  我也不知道我是怎么把这么明显的 DP 看成图的，可能是 T2 WA 麻了</p>\n</blockquote>\n<p><strong>题解：</strong></p>\n<p>定义 f[i] 表示行驶到 i 时的最大盈利。考虑状态转移，一方面，我们可以不接终点为 i 的乘客，这样有 f[i]=f[i-1]；另一方面，我们可以接所有终点为 i 的乘客中收益最大的，这样有 f[i] = \\max (f[start]+end-start+tip)  ，二者取最大值。</p>\n<p>最终答案为 f[n]。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">i64 <span class=\"title\">maxTaxiEarnings</span><span class=\"params\">(i32 n, VecVec&lt;i32&gt; &amp;rides)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> dp = <span class=\"built_in\">Vecl</span>(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> prof = VecVec&lt;std::tuple&lt;i64, i64&gt;&gt;(n+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 记录每个 end 对应的 start 和 tip</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp;&amp; r: rides)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> start = r[<span class=\"number\">0</span>], end = r[<span class=\"number\">1</span>], tip = r[<span class=\"number\">2</span>];</span><br><span class=\"line\">            prof[end].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">TUPLE</span>(start, tip));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(ed, <span class=\"number\">1</span>, n+<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[ed] = dp[ed - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp;&amp; [st, tip]: prof[ed])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dp[ed] = std::<span class=\"built_in\">max</span>(dp[ed], dp[st] + ed - st + tip);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-2009-使数组连续的最少操作数\"><a href=\"#T4-2009-使数组连续的最少操作数\" class=\"headerlink\" title=\"T4 2009. 使数组连续的最少操作数\"></a>T4 2009. 使数组连续的最少操作数</h2><ul>\n<li>  <strong>通过的用户数</strong>353</li>\n<li>  <strong>尝试过的用户数</strong>545</li>\n<li>  <strong>用户总通过次数</strong>386</li>\n<li>  <strong>用户总提交次数</strong>1243</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 <strong>任意</strong> 一个元素替换成 <strong>任意</strong> 整数。</p>\n<p>如果 <code>nums</code> 满足以下条件，那么它是 <strong>连续的</strong> ：</p>\n<ul>\n<li>  <code>nums</code> 中所有元素都是 <strong>互不相同</strong> 的。</li>\n<li>  <code>nums</code> 中 <strong>最大</strong> 元素与 <strong>最小</strong> 元素的差等于 <code>nums.length - 1</code> 。</li>\n</ul>\n<p>比方说，<code>nums = [4, 2, 5, 3]</code> 是 <strong>连续的</strong> ，但是 <code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong> 。</p>\n<p>请你返回使 <code>nums</code> <strong>连续</strong> 的 <strong>最少</strong> 操作次数。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [4,2,5,3]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：nums 已经是连续的了。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3,5,6]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：一个可能的解是将最后一个元素变为 4 。</span><br><span class=\"line\">结果数组为 [1,2,3,5,4] ，是连续数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,10,100,1000]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：一个可能的解是：</span><br><span class=\"line\">- 将第二个元素变为 2 。</span><br><span class=\"line\">- 将第三个元素变为 3 。</span><br><span class=\"line\">- 将第四个元素变为 4 。</span><br><span class=\"line\">结果数组为 [1,2,3,4] ，是连续数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-双周赛-61\"><a href=\"#LeetCode-双周赛-61\" class=\"headerlink\" title=\"LeetCode 双周赛 61\"></a>LeetCode 双周赛 61</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/maximum-earnings-from-taxi/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1103 / 2534</td>\n<td>MiracleSNeko</td>\n<td>7</td>\n<td>1:33:40</td>\n<td>0:02:08</td>\n<td>0:48:40 9</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-2006-差的绝对值为-K-的数对数目\"><a href=\"#T1-2006-差的绝对值为-K-的数对数目\" class=\"headerlink\" title=\"T1 2006. 差的绝对值为 K 的数对数目\"></a>T1 2006. 差的绝对值为 K 的数对数目</h2><ul>\n<li>  <strong>通过的用户数</strong>1773</li>\n<li>  <strong>尝试过的用户数</strong>1793</li>\n<li>  <strong>用户总通过次数</strong>1806</li>\n<li>  <strong>用户总提交次数</strong>1985</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回数对 <code>(i, j)</code> 的数目，满足 <code>i &lt; j</code> 且 <code>|nums[i] - nums[j]| == k</code> 。</p>\n<p><code>|x|</code> 的值定义为：</p>\n<ul>\n<li>  如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li>\n<li>  如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,2,1], k = 1</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：差的绝对值为 1 的数对为：</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br><span class=\"line\">- [1,2,2,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3], k = 3</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：没有任何数对差的绝对值为 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1,5,4], k = 2</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：差的绝对值为 2 的数对为：</span><br><span class=\"line\">- [3,2,1,5,4]</span><br><span class=\"line\">- [3,2,1,5,4]</span><br><span class=\"line\">- [3,2,1,5,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 100</code></li>\n<li>  <code>1 &lt;= k &lt;= 99</code></li>\n</ul>\n<blockquote>\n<p>  T1 的数据量暴力就完事了</p>\n</blockquote>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countKDifference</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; len; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> vi = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> j = i; j &lt; len; ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> vj = nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(vi - vj) == k) ans++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-2007-从双倍数组中还原原数组\"><a href=\"#T2-2007-从双倍数组中还原原数组\" class=\"headerlink\" title=\"T2 2007. 从双倍数组中还原原数组\"></a>T2 2007. 从双倍数组中还原原数组</h2><ul>\n<li>  <strong>通过的用户数</strong>1149</li>\n<li>  <strong>尝试过的用户数</strong>1598</li>\n<li>  <strong>用户总通过次数</strong>1187</li>\n<li>  <strong>用户总提交次数</strong>5278</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>一个整数数组 <code>original</code> 可以转变成一个 <strong>双倍</strong> 数组 <code>changed</code> ，转变方式为将 <code>original</code> 中每个元素 <strong>值乘以 2</strong> 加入数组中，然后将所有元素 <strong>随机打乱</strong> 。</p>\n<p>给你一个数组 <code>changed</code> ，如果 <code>change</code> 是 <strong>双倍</strong> 数组，那么请你返回 <code>original</code>数组，否则请返回空数组。<code>original</code> 的元素可以以 <strong>任意</strong> 顺序返回。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [1,3,4,2,6,8]</span><br><span class=\"line\">输出：[1,3,4]</span><br><span class=\"line\">解释：一个可能的 original 数组为 [1,3,4] :</span><br><span class=\"line\">- 将 1 乘以 2 ，得到 1 * 2 = 2 。</span><br><span class=\"line\">- 将 3 乘以 2 ，得到 3 * 2 = 6 。</span><br><span class=\"line\">- 将 4 乘以 2 ，得到 4 * 2 = 8 。</span><br><span class=\"line\">其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [6,3,0,1]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：changed = [1]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= changed.length &lt;= 105</code></li>\n<li>  <code>0 &lt;= changed[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  写的时候用数组折腾来折腾去 WA 的死去活来 （9次啊9次），后来发现不如 <code>std::map</code> 减减乐</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个破代码还可以改很多地方</span></span><br><span class=\"line\"><span class=\"comment\">// 但是如果是用 Rust 写怕不是就炸了，一个 map 在做迭代器的时候还要被改</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Veci <span class=\"title\">findOriginalArray</span><span class=\"params\">(Veci &amp;changed)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Veci ans;</span><br><span class=\"line\">        std::<span class=\"built_in\">sort</span>(<span class=\"built_in\">ALL</span>(changed));</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> st = <span class=\"built_in\">UpperBS</span>(changed, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((st &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; st; i += <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        changed = <span class=\"built_in\">Veci</span>(changed.<span class=\"built_in\">begin</span>() + st, changed.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = changed.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((len &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">        Veci odd;</span><br><span class=\"line\">        std::map&lt;i32, i32&gt; even;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;val : changed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((val &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(val) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    even[val] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    even[val] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                odd.<span class=\"built_in\">push_back</span>(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> ii : odd)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(<span class=\"number\">2</span> * ii) == <span class=\"number\">0</span> || even[<span class=\"number\">2</span> * ii] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(ii);</span><br><span class=\"line\">            even[<span class=\"number\">2</span> * ii] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> [k, v]: even)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (even.<span class=\"built_in\">count</span>(<span class=\"number\">2</span> * k) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(v--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(k);</span><br><span class=\"line\">                even[<span class=\"number\">2</span> * k] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (even[<span class=\"number\">2</span> * k] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Veci</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<p>小的值优先匹配小的，所以先用sort进行排序<br>然后可以将暂时没匹配到的数字存放至队列中，使用队列也是为了优先匹配小的，小的先进，小的先出。<br>每次等到匹配到的时候，就将队列中的数取出。最后判断队列是否为空。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findOriginalArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; changed)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(changed.<span class=\"built_in\">begin</span>(),changed.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; res,empty;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = changed.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>)<span class=\"keyword\">return</span> empty;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(changed[i]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(q.<span class=\"built_in\">front</span>()*<span class=\"number\">2</span> == changed[i])&#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(q.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">                    q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(changed[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> empty;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：zhu<span class=\"number\">-146</span></span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/find-original-array-from-doubled-array/solution/pai-xu-dui-lie-by-zhu-146-a5bo/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-2008-出租车的最大盈利\"><a href=\"#T3-2008-出租车的最大盈利\" class=\"headerlink\" title=\"T3 2008. 出租车的最大盈利\"></a>T3 2008. 出租车的最大盈利</h2><ul>\n<li>  <strong>通过的用户数</strong>519</li>\n<li>  <strong>尝试过的用户数</strong>832</li>\n<li>  <strong>用户总通过次数</strong>543</li>\n<li>  <strong>用户总提交次数</strong>1850</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>你驾驶出租车行驶在一条有 <code>n</code> 个地点的路上。这 <code>n</code> 个地点从近到远编号为 <code>1</code> 到 <code>n</code> ，你想要从 <code>1</code> 开到 <code>n</code> ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。</p>\n<p>乘客信息用一个下标从 <strong>0</strong> 开始的二维数组 <code>rides</code> 表示，其中 <code>rides[i] = [starti, endi, tipi]</code> 表示第 <code>i</code> 位乘客需要从地点 <code>starti</code> 前往 <code>endi</code> ，愿意支付 <code>tipi</code> 元的小费。</p>\n<p><strong>每一位</strong> 你选择接单的乘客 <code>i</code> ，你可以 <strong>盈利</strong> <code>endi - starti + tipi</code> 元。你同时 <strong>最多</strong> 只能接一个订单。</p>\n<p>给你 <code>n</code> 和 <code>rides</code> ，请你返回在最优接单方案下，你能盈利 <strong>最多</strong> 多少元。</p>\n<p><strong>注意：</strong>你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, rides = [[2,5,4],[1,5,1]]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]</span><br><span class=\"line\">输出：20</span><br><span class=\"line\">解释：我们可以接以下乘客的订单：</span><br><span class=\"line\">- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。</span><br><span class=\"line\">- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。</span><br><span class=\"line\">- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。</span><br><span class=\"line\">我们总共获得 9 + 5 + 6 = 20 元。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>1 &lt;= rides.length &lt;= 3 * 104</code></li>\n<li>  <code>rides[i].length == 3</code></li>\n<li>  <code>1 &lt;= start_i &lt; end_i &lt;= n</code></li>\n<li>  <code>1 &lt;= tip_i &lt;= 105</code></li>\n</ul>\n<blockquote>\n<p>  我也不知道我是怎么把这么明显的 DP 看成图的，可能是 T2 WA 麻了</p>\n</blockquote>\n<p><strong>题解：</strong></p>\n<p>定义 f[i] 表示行驶到 i 时的最大盈利。考虑状态转移，一方面，我们可以不接终点为 i 的乘客，这样有 f[i]=f[i-1]；另一方面，我们可以接所有终点为 i 的乘客中收益最大的，这样有 f[i] = \\max (f[start]+end-start+tip)  ，二者取最大值。</p>\n<p>最终答案为 f[n]。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">i64 <span class=\"title\">maxTaxiEarnings</span><span class=\"params\">(i32 n, VecVec&lt;i32&gt; &amp;rides)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> dp = <span class=\"built_in\">Vecl</span>(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> prof = VecVec&lt;std::tuple&lt;i64, i64&gt;&gt;(n+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 记录每个 end 对应的 start 和 tip</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp;&amp; r: rides)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> start = r[<span class=\"number\">0</span>], end = r[<span class=\"number\">1</span>], tip = r[<span class=\"number\">2</span>];</span><br><span class=\"line\">            prof[end].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">TUPLE</span>(start, tip));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(ed, <span class=\"number\">1</span>, n+<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dp[ed] = dp[ed - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp;&amp; [st, tip]: prof[ed])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dp[ed] = std::<span class=\"built_in\">max</span>(dp[ed], dp[st] + ed - st + tip);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-2009-使数组连续的最少操作数\"><a href=\"#T4-2009-使数组连续的最少操作数\" class=\"headerlink\" title=\"T4 2009. 使数组连续的最少操作数\"></a>T4 2009. 使数组连续的最少操作数</h2><ul>\n<li>  <strong>通过的用户数</strong>353</li>\n<li>  <strong>尝试过的用户数</strong>545</li>\n<li>  <strong>用户总通过次数</strong>386</li>\n<li>  <strong>用户总提交次数</strong>1243</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 <strong>任意</strong> 一个元素替换成 <strong>任意</strong> 整数。</p>\n<p>如果 <code>nums</code> 满足以下条件，那么它是 <strong>连续的</strong> ：</p>\n<ul>\n<li>  <code>nums</code> 中所有元素都是 <strong>互不相同</strong> 的。</li>\n<li>  <code>nums</code> 中 <strong>最大</strong> 元素与 <strong>最小</strong> 元素的差等于 <code>nums.length - 1</code> 。</li>\n</ul>\n<p>比方说，<code>nums = [4, 2, 5, 3]</code> 是 <strong>连续的</strong> ，但是 <code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong> 。</p>\n<p>请你返回使 <code>nums</code> <strong>连续</strong> 的 <strong>最少</strong> 操作次数。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [4,2,5,3]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：nums 已经是连续的了。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3,5,6]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：一个可能的解是将最后一个元素变为 4 。</span><br><span class=\"line\">结果数组为 [1,2,3,5,4] ，是连续数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,10,100,1000]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：一个可能的解是：</span><br><span class=\"line\">- 将第二个元素变为 2 。</span><br><span class=\"line\">- 将第三个元素变为 3 。</span><br><span class=\"line\">- 将第四个元素变为 4 。</span><br><span class=\"line\">结果数组为 [1,2,3,4] ，是连续数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n"},{"title":"LeetCode 双周赛 62","date":"2021-10-06T03:51:36.000Z","_content":"---\n\n# LeetCode 双周赛 62\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 715 / 2619 | MiracleSNeko | 12   | 1:07:20  | 0:03:20                                                      | 0:08:27 1                                                    | 0:52:20 2                                                    |                                                              |\n\n## T1 2022. 将一维数组转变成二维数组\n\n-   **通过的用户数**1673\n-   **尝试过的用户数**1718\n-   **用户总通过次数**1706\n-   **用户总提交次数**2629\n-   **题目难度** **Easy**\n\n给你一个下标从 **0** 开始的一维整数数组 `original` 和两个整数 `m` 和 `n` 。你需要使用 `original` 中 **所有** 元素创建一个 `m` 行 `n` 列的二维数组。\n\n`original` 中下标从 `0` 到 `n - 1` （都 **包含** ）的元素构成二维数组的第一行，下标从 `n` 到 `2 * n - 1` （都 **包含** ）的元素构成二维数组的第二行，依此类推。\n\n请你根据上述过程返回一个 `m x n` 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png)\n\n```\n输入：original = [1,2,3,4], m = 2, n = 2\n输出：[[1,2],[3,4]]\n解释：\n构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n```\n\n**示例 2：**\n\n```\n输入：original = [1,2,3], m = 1, n = 3\n输出：[[1,2,3]]\n解释：\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n```\n\n**示例 3：**\n\n```\n输入：original = [1,2], m = 1, n = 1\n输出：[]\n解释：\noriginal 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n```\n\n**示例 4：**\n\n```\n输入：original = [3], m = 1, n = 2\n输出：[]\n解释：\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n```\n\n**提示：**\n\n-   `1 <= original.length <= 5 * 104`\n-   `1 <= original[i] <= 105`\n-   `1 <= m, n <= 4 * 104`\n\n**我的提交：**\n\n>   应该有 api 可以直接用，但是比赛懒得查了\n\n```rust\nimpl Solution {\n    pub fn construct2_d_array(original: Vec<i32>, m: i32, n: i32) -> Vec<Vec<i32>> {\n        if m * n != original.len() as i32 {\n            vec![]\n        } else {\n            let mut ret = Vec::with_capacity(m as usize);\n            let mut tmp = Vec::with_capacity(n as usize);\n            for i in 0..original.len() {\n                if tmp.len() == n as usize {\n                    ret.push(tmp.clone());\n                    tmp.clear();\n                }\n                tmp.push(original[i]);\n            }\n            ret.push(tmp);\n            ret\n        }\n    }\n}\n```\n\n\n\n## T2 2023. 连接后等于目标字符串的字符串对\n\n-   **通过的用户数**1623\n-   **尝试过的用户数**1654\n-   **用户总通过次数**1647\n-   **用户总提交次数**2202\n-   **题目难度** **Medium**\n\n给你一个 **数字** 字符串数组 `nums` 和一个 **数字** 字符串 `target` ，请你返回 `nums[i] + nums[j]` （两个字符串连接）结果等于 `target` 的下标 `(i, j)` （需满足 `i != j`）的数目。\n\n\n\n**示例 1：**\n\n```\n输入：nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\n输出：4\n解释：符合要求的下标对包括：\n- (0, 1)：\"777\" + \"7\"\n- (1, 0)：\"7\" + \"777\"\n- (2, 3)：\"77\" + \"77\"\n- (3, 2)：\"77\" + \"77\"\n```\n\n**示例 2：**\n\n```\n输入：nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\n输出：2\n解释：符合要求的下标对包括\n- (0, 1)：\"123\" + \"4\"\n- (2, 3)：\"12\" + \"34\"\n```\n\n**示例 3：**\n\n```\n输入：nums = [\"1\",\"1\",\"1\"], target = \"11\"\n输出：6\n解释：符合要求的下标对包括\n- (0, 1)：\"1\" + \"1\"\n- (1, 0)：\"1\" + \"1\"\n- (0, 2)：\"1\" + \"1\"\n- (2, 0)：\"1\" + \"1\"\n- (1, 2)：\"1\" + \"1\"\n- (2, 1)：\"1\" + \"1\"\n```\n\n\n\n**提示：**\n\n-   `2 <= nums.length <= 100`\n-   `1 <= nums[i].length <= 100`\n-   `2 <= target.length <= 100`\n-   `nums[i]` 和 `target` 只包含数字。\n-   `nums[i]` 和 `target` 不含有任何前导 0 。\n\n**我的提交：**\n\n>   一开始想写 dfs，看了眼数据量果断模拟。同一场周赛出现两道模拟送分题还真是少见。\n\n```rust\nimpl Solution {\n    pub fn num_of_pairs(nums: Vec<String>, target: String) -> i32 {\n        let mut cnt = 0;\n        for i in 0..nums.len() {\n            for j in 0..nums.len() {\n                if i == j  {\n                    continue;\n                }\n                let cat = nums[i].clone() + &nums[j];\n                if cat == target {\n                    cnt += 1;\n                }\n            }\n        }\n        cnt\n    }\n}\n```\n\n\n\n## T3 2024. 考试的最大困扰度\n\n-   **通过的用户数**861\n-   **尝试过的用户数**1139\n-   **用户总通过次数**889\n-   **用户总提交次数**2307\n-   **题目难度** **Medium**\n\n一位老师正在出一场由 `n` 道判断题构成的考试，每道题的答案为 true （用 `'T'` 表示）或者 false （用 `'F'` 表示）。老师想增加学生对自己做出答案的不确定性，方法是 **最大化** 有 **连续相同** 结果的题数。（也就是连续出现 true 或者连续出现 false）。\n\n给你一个字符串 `answerKey` ，其中 `answerKey[i]` 是第 `i` 个问题的正确结果。除此以外，还给你一个整数 `k` ，表示你能进行以下操作的最多次数：\n\n-   每次操作中，将问题的正确答案改为 `'T'` 或者 `'F'` （也就是将 `answerKey[i]` 改为 `'T'` 或者 `'F'` ）。\n\n请你返回在不超过 `k` 次操作的情况下，**最大** 连续 `'T'` 或者 `'F'` 的数目。\n\n \n\n**示例 1：**\n\n```\n输入：answerKey = \"TTFF\", k = 2\n输出：4\n解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = \"TTTT\" 。\n总共有四个连续的 'T' 。\n```\n\n**示例 2：**\n\n```\n输入：answerKey = \"TFFT\", k = 1\n输出：3\n解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = \"FFFT\" 。\n或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = \"TFFF\" 。\n两种情况下，都有三个连续的 'F' 。\n```\n\n**示例 3：**\n\n```\n输入：answerKey = \"TTFTTFTT\", k = 1\n输出：5\n解释：我们可以将第一个 'F' 换成 'T' ，得到 answerKey = \"TTTTTFTT\" 。\n或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = \"TTFTTTTT\" 。\n两种情况下，都有五个连续的 'T' 。\n```\n\n \n\n**提示：**\n\n-   `n == answerKey.length`\n-   `1 <= n <= 5 * 104`\n-   `answerKey[i]` 要么是 `'T'` ，要么是 `'F'`\n-   `1 <= k <= n`\n\n**我的提交：**\n\n>   参考 [LC487](https://leetcode-cn.com/problems/max-consecutive-ones-ii/) 和 [LC1004](https://leetcode-cn.com/problems/max-consecutive-ones-iii) 。该题的最佳解法为滑动窗口，周赛的时候写了一个次优的二分。\n\n```rust\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::rc::Rc;\nuse std::ops::Bound;\n\nimpl Solution {\n    pub fn max_consecutive_answers(answer_key: String, k: i32) -> i32 {\n        let mut ans = 0;\n        let len = answer_key.len();\n        let answer_key = answer_key.as_bytes();\n        let ts = answer_key\n            .iter()\n            .map(|&c| if c == b'T' { 1 } else { 0 })\n            .fold(vec![0], |mut vec, i| {\n                vec.push(vec.last().unwrap() + i);\n                vec\n            });\n        let fs = answer_key\n            .iter()\n            .map(|&c| if c == b'F' { 1 } else { 0 })\n            .fold(vec![0], |mut vec, i| {\n                vec.push(vec.last().unwrap() + i);\n                vec\n            });\n        // T 和 F 各算一遍算逑\n        fn lower_bound(val: &Vec<i32>, tar: i32) -> usize {\n            let (mut l, mut r) = (0, val.len());\n            while l < r {\n                let m = (l + r) >> 1;\n                if val[m] < tar {\n                    l = m + 1;\n                } else {\n                    r = m;\n                }\n            }\n            l\n        }\n        for r in 1..ts.len() {\n            let l = lower_bound(&ts, ts[r] - k);\n            ans = ans.max(r - l);\n        }\n        for r in 1..fs.len() {\n            let l = lower_bound(&fs, fs[r] - k);\n            ans = ans.max(r - l);\n        }\n        ans as i32\n    }\n}\n```\n\n\n\n## T4 2025. 分割数组的最多方案数\n\n-   **通过的用户数**267\n-   **尝试过的用户数**641\n-   **用户总通过次数**296\n-   **用户总提交次数**1955\n-   **题目难度** **Hard**\n\n给你一个下标从 **0** 开始且长度为 `n` 的整数数组 `nums` 。**分割** 数组 `nums` 的方案数定义为符合以下两个条件的 `pivot` 数目：\n\n-   `1 <= pivot < n`\n-   `nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]`\n\n同时给你一个整数 `k` 。你可以将 `nums` 中 **一个** 元素变为 `k` 或 **不改变** 数组。\n\n请你返回在 **至多** 改变一个元素的前提下，**最多** 有多少种方法 **分割** `nums` 使得上述两个条件都满足。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,-1,2], k = 3\n输出：1\n解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。\n有一种方法分割数组：\n- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,0], k = 1\n输出：2\n解释：一个最优的方案是不改动数组。\n有两种方法分割数组：\n- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。\n- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\n输出：4\n解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。\n有四种方法分割数组。\n```\n\n \n\n**提示：**\n\n-   `n == nums.length`\n-   `2 <= n <= 105`\n-   `-105 <= k, nums[i] <= 105`\n","source":"_posts/biweekly-contest-62.md","raw":"---\ntitle: LeetCode 双周赛 62\ndate: 2021-10-06 11:51:36\ntags: LeetCode 周赛总结\n---\n---\n\n# LeetCode 双周赛 62\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 715 / 2619 | MiracleSNeko | 12   | 1:07:20  | 0:03:20                                                      | 0:08:27 1                                                    | 0:52:20 2                                                    |                                                              |\n\n## T1 2022. 将一维数组转变成二维数组\n\n-   **通过的用户数**1673\n-   **尝试过的用户数**1718\n-   **用户总通过次数**1706\n-   **用户总提交次数**2629\n-   **题目难度** **Easy**\n\n给你一个下标从 **0** 开始的一维整数数组 `original` 和两个整数 `m` 和 `n` 。你需要使用 `original` 中 **所有** 元素创建一个 `m` 行 `n` 列的二维数组。\n\n`original` 中下标从 `0` 到 `n - 1` （都 **包含** ）的元素构成二维数组的第一行，下标从 `n` 到 `2 * n - 1` （都 **包含** ）的元素构成二维数组的第二行，依此类推。\n\n请你根据上述过程返回一个 `m x n` 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png)\n\n```\n输入：original = [1,2,3,4], m = 2, n = 2\n输出：[[1,2],[3,4]]\n解释：\n构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n```\n\n**示例 2：**\n\n```\n输入：original = [1,2,3], m = 1, n = 3\n输出：[[1,2,3]]\n解释：\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n```\n\n**示例 3：**\n\n```\n输入：original = [1,2], m = 1, n = 1\n输出：[]\n解释：\noriginal 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n```\n\n**示例 4：**\n\n```\n输入：original = [3], m = 1, n = 2\n输出：[]\n解释：\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n```\n\n**提示：**\n\n-   `1 <= original.length <= 5 * 104`\n-   `1 <= original[i] <= 105`\n-   `1 <= m, n <= 4 * 104`\n\n**我的提交：**\n\n>   应该有 api 可以直接用，但是比赛懒得查了\n\n```rust\nimpl Solution {\n    pub fn construct2_d_array(original: Vec<i32>, m: i32, n: i32) -> Vec<Vec<i32>> {\n        if m * n != original.len() as i32 {\n            vec![]\n        } else {\n            let mut ret = Vec::with_capacity(m as usize);\n            let mut tmp = Vec::with_capacity(n as usize);\n            for i in 0..original.len() {\n                if tmp.len() == n as usize {\n                    ret.push(tmp.clone());\n                    tmp.clear();\n                }\n                tmp.push(original[i]);\n            }\n            ret.push(tmp);\n            ret\n        }\n    }\n}\n```\n\n\n\n## T2 2023. 连接后等于目标字符串的字符串对\n\n-   **通过的用户数**1623\n-   **尝试过的用户数**1654\n-   **用户总通过次数**1647\n-   **用户总提交次数**2202\n-   **题目难度** **Medium**\n\n给你一个 **数字** 字符串数组 `nums` 和一个 **数字** 字符串 `target` ，请你返回 `nums[i] + nums[j]` （两个字符串连接）结果等于 `target` 的下标 `(i, j)` （需满足 `i != j`）的数目。\n\n\n\n**示例 1：**\n\n```\n输入：nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\n输出：4\n解释：符合要求的下标对包括：\n- (0, 1)：\"777\" + \"7\"\n- (1, 0)：\"7\" + \"777\"\n- (2, 3)：\"77\" + \"77\"\n- (3, 2)：\"77\" + \"77\"\n```\n\n**示例 2：**\n\n```\n输入：nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\n输出：2\n解释：符合要求的下标对包括\n- (0, 1)：\"123\" + \"4\"\n- (2, 3)：\"12\" + \"34\"\n```\n\n**示例 3：**\n\n```\n输入：nums = [\"1\",\"1\",\"1\"], target = \"11\"\n输出：6\n解释：符合要求的下标对包括\n- (0, 1)：\"1\" + \"1\"\n- (1, 0)：\"1\" + \"1\"\n- (0, 2)：\"1\" + \"1\"\n- (2, 0)：\"1\" + \"1\"\n- (1, 2)：\"1\" + \"1\"\n- (2, 1)：\"1\" + \"1\"\n```\n\n\n\n**提示：**\n\n-   `2 <= nums.length <= 100`\n-   `1 <= nums[i].length <= 100`\n-   `2 <= target.length <= 100`\n-   `nums[i]` 和 `target` 只包含数字。\n-   `nums[i]` 和 `target` 不含有任何前导 0 。\n\n**我的提交：**\n\n>   一开始想写 dfs，看了眼数据量果断模拟。同一场周赛出现两道模拟送分题还真是少见。\n\n```rust\nimpl Solution {\n    pub fn num_of_pairs(nums: Vec<String>, target: String) -> i32 {\n        let mut cnt = 0;\n        for i in 0..nums.len() {\n            for j in 0..nums.len() {\n                if i == j  {\n                    continue;\n                }\n                let cat = nums[i].clone() + &nums[j];\n                if cat == target {\n                    cnt += 1;\n                }\n            }\n        }\n        cnt\n    }\n}\n```\n\n\n\n## T3 2024. 考试的最大困扰度\n\n-   **通过的用户数**861\n-   **尝试过的用户数**1139\n-   **用户总通过次数**889\n-   **用户总提交次数**2307\n-   **题目难度** **Medium**\n\n一位老师正在出一场由 `n` 道判断题构成的考试，每道题的答案为 true （用 `'T'` 表示）或者 false （用 `'F'` 表示）。老师想增加学生对自己做出答案的不确定性，方法是 **最大化** 有 **连续相同** 结果的题数。（也就是连续出现 true 或者连续出现 false）。\n\n给你一个字符串 `answerKey` ，其中 `answerKey[i]` 是第 `i` 个问题的正确结果。除此以外，还给你一个整数 `k` ，表示你能进行以下操作的最多次数：\n\n-   每次操作中，将问题的正确答案改为 `'T'` 或者 `'F'` （也就是将 `answerKey[i]` 改为 `'T'` 或者 `'F'` ）。\n\n请你返回在不超过 `k` 次操作的情况下，**最大** 连续 `'T'` 或者 `'F'` 的数目。\n\n \n\n**示例 1：**\n\n```\n输入：answerKey = \"TTFF\", k = 2\n输出：4\n解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = \"TTTT\" 。\n总共有四个连续的 'T' 。\n```\n\n**示例 2：**\n\n```\n输入：answerKey = \"TFFT\", k = 1\n输出：3\n解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = \"FFFT\" 。\n或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = \"TFFF\" 。\n两种情况下，都有三个连续的 'F' 。\n```\n\n**示例 3：**\n\n```\n输入：answerKey = \"TTFTTFTT\", k = 1\n输出：5\n解释：我们可以将第一个 'F' 换成 'T' ，得到 answerKey = \"TTTTTFTT\" 。\n或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = \"TTFTTTTT\" 。\n两种情况下，都有五个连续的 'T' 。\n```\n\n \n\n**提示：**\n\n-   `n == answerKey.length`\n-   `1 <= n <= 5 * 104`\n-   `answerKey[i]` 要么是 `'T'` ，要么是 `'F'`\n-   `1 <= k <= n`\n\n**我的提交：**\n\n>   参考 [LC487](https://leetcode-cn.com/problems/max-consecutive-ones-ii/) 和 [LC1004](https://leetcode-cn.com/problems/max-consecutive-ones-iii) 。该题的最佳解法为滑动窗口，周赛的时候写了一个次优的二分。\n\n```rust\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::rc::Rc;\nuse std::ops::Bound;\n\nimpl Solution {\n    pub fn max_consecutive_answers(answer_key: String, k: i32) -> i32 {\n        let mut ans = 0;\n        let len = answer_key.len();\n        let answer_key = answer_key.as_bytes();\n        let ts = answer_key\n            .iter()\n            .map(|&c| if c == b'T' { 1 } else { 0 })\n            .fold(vec![0], |mut vec, i| {\n                vec.push(vec.last().unwrap() + i);\n                vec\n            });\n        let fs = answer_key\n            .iter()\n            .map(|&c| if c == b'F' { 1 } else { 0 })\n            .fold(vec![0], |mut vec, i| {\n                vec.push(vec.last().unwrap() + i);\n                vec\n            });\n        // T 和 F 各算一遍算逑\n        fn lower_bound(val: &Vec<i32>, tar: i32) -> usize {\n            let (mut l, mut r) = (0, val.len());\n            while l < r {\n                let m = (l + r) >> 1;\n                if val[m] < tar {\n                    l = m + 1;\n                } else {\n                    r = m;\n                }\n            }\n            l\n        }\n        for r in 1..ts.len() {\n            let l = lower_bound(&ts, ts[r] - k);\n            ans = ans.max(r - l);\n        }\n        for r in 1..fs.len() {\n            let l = lower_bound(&fs, fs[r] - k);\n            ans = ans.max(r - l);\n        }\n        ans as i32\n    }\n}\n```\n\n\n\n## T4 2025. 分割数组的最多方案数\n\n-   **通过的用户数**267\n-   **尝试过的用户数**641\n-   **用户总通过次数**296\n-   **用户总提交次数**1955\n-   **题目难度** **Hard**\n\n给你一个下标从 **0** 开始且长度为 `n` 的整数数组 `nums` 。**分割** 数组 `nums` 的方案数定义为符合以下两个条件的 `pivot` 数目：\n\n-   `1 <= pivot < n`\n-   `nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]`\n\n同时给你一个整数 `k` 。你可以将 `nums` 中 **一个** 元素变为 `k` 或 **不改变** 数组。\n\n请你返回在 **至多** 改变一个元素的前提下，**最多** 有多少种方法 **分割** `nums` 使得上述两个条件都满足。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,-1,2], k = 3\n输出：1\n解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。\n有一种方法分割数组：\n- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,0], k = 1\n输出：2\n解释：一个最优的方案是不改动数组。\n有两种方法分割数组：\n- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。\n- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\n输出：4\n解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。\n有四种方法分割数组。\n```\n\n \n\n**提示：**\n\n-   `n == nums.length`\n-   `2 <= n <= 105`\n-   `-105 <= k, nums[i] <= 105`\n","slug":"biweekly-contest-62","published":1,"updated":"2021-11-17T05:21:51.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8pv00041cy5div423in","content":"<hr>\n<h1 id=\"LeetCode-双周赛-62\"><a href=\"#LeetCode-双周赛-62\" class=\"headerlink\" title=\"LeetCode 双周赛 62\"></a>LeetCode 双周赛 62</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>715 / 2619</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:07:20</td>\n<td>0:03:20</td>\n<td>0:08:27 1</td>\n<td>0:52:20 2</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-2022-将一维数组转变成二维数组\"><a href=\"#T1-2022-将一维数组转变成二维数组\" class=\"headerlink\" title=\"T1 2022. 将一维数组转变成二维数组\"></a>T1 2022. 将一维数组转变成二维数组</h2><ul>\n<li>  <strong>通过的用户数</strong>1673</li>\n<li>  <strong>尝试过的用户数</strong>1718</li>\n<li>  <strong>用户总通过次数</strong>1706</li>\n<li>  <strong>用户总提交次数</strong>2629</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的一维整数数组 <code>original</code> 和两个整数 <code>m</code> 和 <code>n</code> 。你需要使用 <code>original</code> 中 <strong>所有</strong> 元素创建一个 <code>m</code> 行 <code>n</code> 列的二维数组。</p>\n<p><code>original</code> 中下标从 <code>0</code> 到 <code>n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code> 到 <code>2 * n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第二行，依此类推。</p>\n<p>请你根据上述过程返回一个 <code>m x n</code> 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2,3,4], m = 2, n = 2</span><br><span class=\"line\">输出：[[1,2],[3,4]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">构造出的二维数组应该包含 2 行 2 列。</span><br><span class=\"line\">original 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。</span><br><span class=\"line\">original 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2,3], m = 1, n = 3</span><br><span class=\"line\">输出：[[1,2,3]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">构造出的二维数组应该包含 1 行 3 列。</span><br><span class=\"line\">将 original 中所有三个元素放入第一行中，构成要求的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2], m = 1, n = 1</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">original 中有 2 个元素。</span><br><span class=\"line\">无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [3], m = 1, n = 2</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">original 中只有 1 个元素。</span><br><span class=\"line\">无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= original.length &lt;= 5 * 104</code></li>\n<li>  <code>1 &lt;= original[i] &lt;= 105</code></li>\n<li>  <code>1 &lt;= m, n &lt;= 4 * 104</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  应该有 api 可以直接用，但是比赛懒得查了</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">construct2_d_array</span></span>(original: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, m: <span class=\"built_in\">i32</span>, n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m * n != original.len() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vec!</span>[]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ret = <span class=\"built_in\">Vec</span>::with_capacity(m <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> tmp = <span class=\"built_in\">Vec</span>::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..original.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> tmp.len() == n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">                    ret.push(tmp.clone());</span><br><span class=\"line\">                    tmp.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tmp.push(original[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret.push(tmp);</span><br><span class=\"line\">            ret</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-2023-连接后等于目标字符串的字符串对\"><a href=\"#T2-2023-连接后等于目标字符串的字符串对\" class=\"headerlink\" title=\"T2 2023. 连接后等于目标字符串的字符串对\"></a>T2 2023. 连接后等于目标字符串的字符串对</h2><ul>\n<li>  <strong>通过的用户数</strong>1623</li>\n<li>  <strong>尝试过的用户数</strong>1654</li>\n<li>  <strong>用户总通过次数</strong>1647</li>\n<li>  <strong>用户总提交次数</strong>2202</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个 <strong>数字</strong> 字符串数组 <code>nums</code> 和一个 <strong>数字</strong> 字符串 <code>target</code> ，请你返回 <code>nums[i] + nums[j]</code> （两个字符串连接）结果等于 <code>target</code> 的下标 <code>(i, j)</code> （需满足 <code>i != j</code>）的数目。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;777&quot;,&quot;7&quot;,&quot;77&quot;,&quot;77&quot;], target = &quot;7777&quot;</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：符合要求的下标对包括：</span><br><span class=\"line\">- (0, 1)：&quot;777&quot; + &quot;7&quot;</span><br><span class=\"line\">- (1, 0)：&quot;7&quot; + &quot;777&quot;</span><br><span class=\"line\">- (2, 3)：&quot;77&quot; + &quot;77&quot;</span><br><span class=\"line\">- (3, 2)：&quot;77&quot; + &quot;77&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;123&quot;,&quot;4&quot;,&quot;12&quot;,&quot;34&quot;], target = &quot;1234&quot;</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：符合要求的下标对包括</span><br><span class=\"line\">- (0, 1)：&quot;123&quot; + &quot;4&quot;</span><br><span class=\"line\">- (2, 3)：&quot;12&quot; + &quot;34&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], target = &quot;11&quot;</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：符合要求的下标对包括</span><br><span class=\"line\">- (0, 1)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (1, 0)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (0, 2)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (2, 0)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (1, 2)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (2, 1)：&quot;1&quot; + &quot;1&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= nums.length &lt;= 100</code></li>\n<li>  <code>1 &lt;= nums[i].length &lt;= 100</code></li>\n<li>  <code>2 &lt;= target.length &lt;= 100</code></li>\n<li>  <code>nums[i]</code> 和 <code>target</code> 只包含数字。</li>\n<li>  <code>nums[i]</code> 和 <code>target</code> 不含有任何前导 0 。</li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  一开始想写 dfs，看了眼数据量果断模拟。同一场周赛出现两道模拟送分题还真是少见。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">num_of_pairs</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">String</span>&gt;, target: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..nums.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..nums.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == j  &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> cat = nums[i].clone() + &amp;nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cat == target &#123;</span><br><span class=\"line\">                    cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-2024-考试的最大困扰度\"><a href=\"#T3-2024-考试的最大困扰度\" class=\"headerlink\" title=\"T3 2024. 考试的最大困扰度\"></a>T3 2024. 考试的最大困扰度</h2><ul>\n<li>  <strong>通过的用户数</strong>861</li>\n<li>  <strong>尝试过的用户数</strong>1139</li>\n<li>  <strong>用户总通过次数</strong>889</li>\n<li>  <strong>用户总提交次数</strong>2307</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>一位老师正在出一场由 <code>n</code> 道判断题构成的考试，每道题的答案为 true （用 <code>&#39;T&#39;</code> 表示）或者 false （用 <code>&#39;F&#39;</code> 表示）。老师想增加学生对自己做出答案的不确定性，方法是 <strong>最大化</strong> 有 <strong>连续相同</strong> 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p>\n<p>给你一个字符串 <code>answerKey</code> ，其中 <code>answerKey[i]</code> 是第 <code>i</code> 个问题的正确结果。除此以外，还给你一个整数 <code>k</code> ，表示你能进行以下操作的最多次数：</p>\n<ul>\n<li>  每次操作中，将问题的正确答案改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> （也就是将 <code>answerKey[i]</code> 改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> ）。</li>\n</ul>\n<p>请你返回在不超过 <code>k</code> 次操作的情况下，<strong>最大</strong> 连续 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> 的数目。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TTFF&quot;, k = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：我们可以将两个 &#x27;F&#x27; 都变为 &#x27;T&#x27; ，得到 answerKey = &quot;TTTT&quot; 。</span><br><span class=\"line\">总共有四个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TFFT&quot;, k = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：我们可以将最前面的 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey = &quot;FFFT&quot; 。</span><br><span class=\"line\">或者，我们可以将第二个 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey = &quot;TFFF&quot; 。</span><br><span class=\"line\">两种情况下，都有三个连续的 &#x27;F&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TTFTTFTT&quot;, k = 1</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：我们可以将第一个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey = &quot;TTTTTFTT&quot; 。</span><br><span class=\"line\">或者我们可以将第二个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey = &quot;TTFTTTTT&quot; 。</span><br><span class=\"line\">两种情况下，都有五个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == answerKey.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 5 * 104</code></li>\n<li>  <code>answerKey[i]</code> 要么是 <code>&#39;T&#39;</code> ，要么是 <code>&#39;F&#39;</code></li>\n<li>  <code>1 &lt;= k &lt;= n</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  参考 <a href=\"https://leetcode-cn.com/problems/max-consecutive-ones-ii/\">LC487</a> 和 <a href=\"https://leetcode-cn.com/problems/max-consecutive-ones-iii\">LC1004</a> 。该题的最佳解法为滑动窗口，周赛的时候写了一个次优的二分。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::ops::Bound;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">max_consecutive_answers</span></span>(answer_key: <span class=\"built_in\">String</span>, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = answer_key.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> answer_key = answer_key.as_bytes();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ts = answer_key</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .map(|&amp;c| <span class=\"keyword\">if</span> c == <span class=\"string\">b&#x27;T&#x27;</span> &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">            .fold(<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>], |<span class=\"keyword\">mut</span> vec, i| &#123;</span><br><span class=\"line\">                vec.push(vec.last().unwrap() + i);</span><br><span class=\"line\">                vec</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fs = answer_key</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .map(|&amp;c| <span class=\"keyword\">if</span> c == <span class=\"string\">b&#x27;F&#x27;</span> &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">            .fold(<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>], |<span class=\"keyword\">mut</span> vec, i| &#123;</span><br><span class=\"line\">                vec.push(vec.last().unwrap() + i);</span><br><span class=\"line\">                vec</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// T 和 F 各算一遍算逑</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">lower_bound</span></span>(val: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, tar: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> l, <span class=\"keyword\">mut</span> r) = (<span class=\"number\">0</span>, val.len());</span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val[m] &lt; tar &#123;</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    r = m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"number\">1</span>..ts.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = lower_bound(&amp;ts, ts[r] - k);</span><br><span class=\"line\">            ans = ans.max(r - l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"number\">1</span>..fs.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = lower_bound(&amp;fs, fs[r] - k);</span><br><span class=\"line\">            ans = ans.max(r - l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-2025-分割数组的最多方案数\"><a href=\"#T4-2025-分割数组的最多方案数\" class=\"headerlink\" title=\"T4 2025. 分割数组的最多方案数\"></a>T4 2025. 分割数组的最多方案数</h2><ul>\n<li>  <strong>通过的用户数</strong>267</li>\n<li>  <strong>尝试过的用户数</strong>641</li>\n<li>  <strong>用户总通过次数</strong>296</li>\n<li>  <strong>用户总提交次数</strong>1955</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums</code> 。<strong>分割</strong> 数组 <code>nums</code> 的方案数定义为符合以下两个条件的 <code>pivot</code> 数目：</p>\n<ul>\n<li>  <code>1 &lt;= pivot &lt; n</code></li>\n<li>  <code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>\n</ul>\n<p>同时给你一个整数 <code>k</code> 。你可以将 <code>nums</code> 中 <strong>一个</strong> 元素变为 <code>k</code> 或 <strong>不改变</strong> 数组。</p>\n<p>请你返回在 <strong>至多</strong> 改变一个元素的前提下，<strong>最多</strong> 有多少种方法 <strong>分割</strong> <code>nums</code> 使得上述两个条件都满足。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,2], k = 3</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。</span><br><span class=\"line\">有一种方法分割数组：</span><br><span class=\"line\">- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0,0], k = 1</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：一个最优的方案是不改动数组。</span><br><span class=\"line\">有两种方法分割数组：</span><br><span class=\"line\">- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。</span><br><span class=\"line\">- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。</span><br><span class=\"line\">有四种方法分割数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == nums.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  <code>-105 &lt;= k, nums[i] &lt;= 105</code></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-双周赛-62\"><a href=\"#LeetCode-双周赛-62\" class=\"headerlink\" title=\"LeetCode 双周赛 62\"></a>LeetCode 双周赛 62</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>715 / 2619</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:07:20</td>\n<td>0:03:20</td>\n<td>0:08:27 1</td>\n<td>0:52:20 2</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-2022-将一维数组转变成二维数组\"><a href=\"#T1-2022-将一维数组转变成二维数组\" class=\"headerlink\" title=\"T1 2022. 将一维数组转变成二维数组\"></a>T1 2022. 将一维数组转变成二维数组</h2><ul>\n<li>  <strong>通过的用户数</strong>1673</li>\n<li>  <strong>尝试过的用户数</strong>1718</li>\n<li>  <strong>用户总通过次数</strong>1706</li>\n<li>  <strong>用户总提交次数</strong>2629</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的一维整数数组 <code>original</code> 和两个整数 <code>m</code> 和 <code>n</code> 。你需要使用 <code>original</code> 中 <strong>所有</strong> 元素创建一个 <code>m</code> 行 <code>n</code> 列的二维数组。</p>\n<p><code>original</code> 中下标从 <code>0</code> 到 <code>n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code> 到 <code>2 * n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第二行，依此类推。</p>\n<p>请你根据上述过程返回一个 <code>m x n</code> 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2,3,4], m = 2, n = 2</span><br><span class=\"line\">输出：[[1,2],[3,4]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">构造出的二维数组应该包含 2 行 2 列。</span><br><span class=\"line\">original 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。</span><br><span class=\"line\">original 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2,3], m = 1, n = 3</span><br><span class=\"line\">输出：[[1,2,3]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">构造出的二维数组应该包含 1 行 3 列。</span><br><span class=\"line\">将 original 中所有三个元素放入第一行中，构成要求的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [1,2], m = 1, n = 1</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">original 中有 2 个元素。</span><br><span class=\"line\">无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：original = [3], m = 1, n = 2</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">original 中只有 1 个元素。</span><br><span class=\"line\">无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= original.length &lt;= 5 * 104</code></li>\n<li>  <code>1 &lt;= original[i] &lt;= 105</code></li>\n<li>  <code>1 &lt;= m, n &lt;= 4 * 104</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  应该有 api 可以直接用，但是比赛懒得查了</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">construct2_d_array</span></span>(original: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, m: <span class=\"built_in\">i32</span>, n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m * n != original.len() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vec!</span>[]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ret = <span class=\"built_in\">Vec</span>::with_capacity(m <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> tmp = <span class=\"built_in\">Vec</span>::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..original.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> tmp.len() == n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">                    ret.push(tmp.clone());</span><br><span class=\"line\">                    tmp.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tmp.push(original[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret.push(tmp);</span><br><span class=\"line\">            ret</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-2023-连接后等于目标字符串的字符串对\"><a href=\"#T2-2023-连接后等于目标字符串的字符串对\" class=\"headerlink\" title=\"T2 2023. 连接后等于目标字符串的字符串对\"></a>T2 2023. 连接后等于目标字符串的字符串对</h2><ul>\n<li>  <strong>通过的用户数</strong>1623</li>\n<li>  <strong>尝试过的用户数</strong>1654</li>\n<li>  <strong>用户总通过次数</strong>1647</li>\n<li>  <strong>用户总提交次数</strong>2202</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个 <strong>数字</strong> 字符串数组 <code>nums</code> 和一个 <strong>数字</strong> 字符串 <code>target</code> ，请你返回 <code>nums[i] + nums[j]</code> （两个字符串连接）结果等于 <code>target</code> 的下标 <code>(i, j)</code> （需满足 <code>i != j</code>）的数目。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;777&quot;,&quot;7&quot;,&quot;77&quot;,&quot;77&quot;], target = &quot;7777&quot;</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：符合要求的下标对包括：</span><br><span class=\"line\">- (0, 1)：&quot;777&quot; + &quot;7&quot;</span><br><span class=\"line\">- (1, 0)：&quot;7&quot; + &quot;777&quot;</span><br><span class=\"line\">- (2, 3)：&quot;77&quot; + &quot;77&quot;</span><br><span class=\"line\">- (3, 2)：&quot;77&quot; + &quot;77&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;123&quot;,&quot;4&quot;,&quot;12&quot;,&quot;34&quot;], target = &quot;1234&quot;</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：符合要求的下标对包括</span><br><span class=\"line\">- (0, 1)：&quot;123&quot; + &quot;4&quot;</span><br><span class=\"line\">- (2, 3)：&quot;12&quot; + &quot;34&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], target = &quot;11&quot;</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：符合要求的下标对包括</span><br><span class=\"line\">- (0, 1)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (1, 0)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (0, 2)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (2, 0)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (1, 2)：&quot;1&quot; + &quot;1&quot;</span><br><span class=\"line\">- (2, 1)：&quot;1&quot; + &quot;1&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= nums.length &lt;= 100</code></li>\n<li>  <code>1 &lt;= nums[i].length &lt;= 100</code></li>\n<li>  <code>2 &lt;= target.length &lt;= 100</code></li>\n<li>  <code>nums[i]</code> 和 <code>target</code> 只包含数字。</li>\n<li>  <code>nums[i]</code> 和 <code>target</code> 不含有任何前导 0 。</li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  一开始想写 dfs，看了眼数据量果断模拟。同一场周赛出现两道模拟送分题还真是少见。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">num_of_pairs</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">String</span>&gt;, target: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..nums.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..nums.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == j  &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> cat = nums[i].clone() + &amp;nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cat == target &#123;</span><br><span class=\"line\">                    cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-2024-考试的最大困扰度\"><a href=\"#T3-2024-考试的最大困扰度\" class=\"headerlink\" title=\"T3 2024. 考试的最大困扰度\"></a>T3 2024. 考试的最大困扰度</h2><ul>\n<li>  <strong>通过的用户数</strong>861</li>\n<li>  <strong>尝试过的用户数</strong>1139</li>\n<li>  <strong>用户总通过次数</strong>889</li>\n<li>  <strong>用户总提交次数</strong>2307</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>一位老师正在出一场由 <code>n</code> 道判断题构成的考试，每道题的答案为 true （用 <code>&#39;T&#39;</code> 表示）或者 false （用 <code>&#39;F&#39;</code> 表示）。老师想增加学生对自己做出答案的不确定性，方法是 <strong>最大化</strong> 有 <strong>连续相同</strong> 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p>\n<p>给你一个字符串 <code>answerKey</code> ，其中 <code>answerKey[i]</code> 是第 <code>i</code> 个问题的正确结果。除此以外，还给你一个整数 <code>k</code> ，表示你能进行以下操作的最多次数：</p>\n<ul>\n<li>  每次操作中，将问题的正确答案改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> （也就是将 <code>answerKey[i]</code> 改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> ）。</li>\n</ul>\n<p>请你返回在不超过 <code>k</code> 次操作的情况下，<strong>最大</strong> 连续 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> 的数目。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TTFF&quot;, k = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：我们可以将两个 &#x27;F&#x27; 都变为 &#x27;T&#x27; ，得到 answerKey = &quot;TTTT&quot; 。</span><br><span class=\"line\">总共有四个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TFFT&quot;, k = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：我们可以将最前面的 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey = &quot;FFFT&quot; 。</span><br><span class=\"line\">或者，我们可以将第二个 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey = &quot;TFFF&quot; 。</span><br><span class=\"line\">两种情况下，都有三个连续的 &#x27;F&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：answerKey = &quot;TTFTTFTT&quot;, k = 1</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：我们可以将第一个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey = &quot;TTTTTFTT&quot; 。</span><br><span class=\"line\">或者我们可以将第二个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey = &quot;TTFTTTTT&quot; 。</span><br><span class=\"line\">两种情况下，都有五个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == answerKey.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 5 * 104</code></li>\n<li>  <code>answerKey[i]</code> 要么是 <code>&#39;T&#39;</code> ，要么是 <code>&#39;F&#39;</code></li>\n<li>  <code>1 &lt;= k &lt;= n</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  参考 <a href=\"https://leetcode-cn.com/problems/max-consecutive-ones-ii/\">LC487</a> 和 <a href=\"https://leetcode-cn.com/problems/max-consecutive-ones-iii\">LC1004</a> 。该题的最佳解法为滑动窗口，周赛的时候写了一个次优的二分。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::ops::Bound;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">max_consecutive_answers</span></span>(answer_key: <span class=\"built_in\">String</span>, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = answer_key.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> answer_key = answer_key.as_bytes();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ts = answer_key</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .map(|&amp;c| <span class=\"keyword\">if</span> c == <span class=\"string\">b&#x27;T&#x27;</span> &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">            .fold(<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>], |<span class=\"keyword\">mut</span> vec, i| &#123;</span><br><span class=\"line\">                vec.push(vec.last().unwrap() + i);</span><br><span class=\"line\">                vec</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fs = answer_key</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .map(|&amp;c| <span class=\"keyword\">if</span> c == <span class=\"string\">b&#x27;F&#x27;</span> &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">            .fold(<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>], |<span class=\"keyword\">mut</span> vec, i| &#123;</span><br><span class=\"line\">                vec.push(vec.last().unwrap() + i);</span><br><span class=\"line\">                vec</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// T 和 F 各算一遍算逑</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">lower_bound</span></span>(val: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, tar: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> l, <span class=\"keyword\">mut</span> r) = (<span class=\"number\">0</span>, val.len());</span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val[m] &lt; tar &#123;</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    r = m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"number\">1</span>..ts.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = lower_bound(&amp;ts, ts[r] - k);</span><br><span class=\"line\">            ans = ans.max(r - l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"number\">1</span>..fs.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = lower_bound(&amp;fs, fs[r] - k);</span><br><span class=\"line\">            ans = ans.max(r - l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-2025-分割数组的最多方案数\"><a href=\"#T4-2025-分割数组的最多方案数\" class=\"headerlink\" title=\"T4 2025. 分割数组的最多方案数\"></a>T4 2025. 分割数组的最多方案数</h2><ul>\n<li>  <strong>通过的用户数</strong>267</li>\n<li>  <strong>尝试过的用户数</strong>641</li>\n<li>  <strong>用户总通过次数</strong>296</li>\n<li>  <strong>用户总提交次数</strong>1955</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums</code> 。<strong>分割</strong> 数组 <code>nums</code> 的方案数定义为符合以下两个条件的 <code>pivot</code> 数目：</p>\n<ul>\n<li>  <code>1 &lt;= pivot &lt; n</code></li>\n<li>  <code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>\n</ul>\n<p>同时给你一个整数 <code>k</code> 。你可以将 <code>nums</code> 中 <strong>一个</strong> 元素变为 <code>k</code> 或 <strong>不改变</strong> 数组。</p>\n<p>请你返回在 <strong>至多</strong> 改变一个元素的前提下，<strong>最多</strong> 有多少种方法 <strong>分割</strong> <code>nums</code> 使得上述两个条件都满足。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,2], k = 3</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：一个最优的方案是将 nums[0] 改为 k 。数组变为 [3,-1,2] 。</span><br><span class=\"line\">有一种方法分割数组：</span><br><span class=\"line\">- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0,0], k = 1</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：一个最优的方案是不改动数组。</span><br><span class=\"line\">有两种方法分割数组：</span><br><span class=\"line\">- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。</span><br><span class=\"line\">- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14] 。</span><br><span class=\"line\">有四种方法分割数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == nums.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  <code>-105 &lt;= k, nums[i] &lt;= 105</code></li>\n</ul>\n"},{"title":"saikr 2021秋季赛","date":"2021-10-25T14:50:08.000Z","_content":"\n------\n\n# Saikr 2021 秋季团体赛\n\n>   参赛队员：\t兔子在宁野爹一号\t兔子在读亲爹\t兔子在京野爹\n","source":"_posts/saikr-contest-2021autumn.md","raw":"---\ntitle: saikr 2021秋季赛\ndate: 2021-10-25 22:50:08\ntags: saikr\n---\n\n------\n\n# Saikr 2021 秋季团体赛\n\n>   参赛队员：\t兔子在宁野爹一号\t兔子在读亲爹\t兔子在京野爹\n","slug":"saikr-contest-2021autumn","published":1,"updated":"2021-11-17T05:21:51.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8pw00051cy53c51h0uz","content":"<hr>\n<h1 id=\"Saikr-2021-秋季团体赛\"><a href=\"#Saikr-2021-秋季团体赛\" class=\"headerlink\" title=\"Saikr 2021 秋季团体赛\"></a>Saikr 2021 秋季团体赛</h1><blockquote>\n<p>  参赛队员：    兔子在宁野爹一号    兔子在读亲爹    兔子在京野爹</p>\n</blockquote>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"Saikr-2021-秋季团体赛\"><a href=\"#Saikr-2021-秋季团体赛\" class=\"headerlink\" title=\"Saikr 2021 秋季团体赛\"></a>Saikr 2021 秋季团体赛</h1><blockquote>\n<p>  参赛队员：    兔子在宁野爹一号    兔子在读亲爹    兔子在京野爹</p>\n</blockquote>\n"},{"title":"LeetCode 虚拟周赛 103","date":"2021-11-15T15:39:59.000Z","_content":"\n-----\n\n# LeetCode 虚拟周赛 103\n\n>   人做麻了，被 T2 自己的傻逼想法卡死\n\n## T1 908. 最小差值 I\n\n-   **通过的用户数**257\n-   **尝试过的用户数**282\n-   **用户总通过次数**263\n-   **用户总提交次数**485\n-   **题目难度** **Easy**\n\n给你一个整数数组 `nums`，请你给数组中的每个元素 `nums[i]` 都加上一个任意数字 `x` （`-k <= x <= k`），从而得到一个新数组 `result` 。\n\n返回数组 `result` 的最大值和最小值之间可能存在的最小差值。\n\n**示例 1：**\n\n```\n输入：nums = [1], k = 0\n输出：0\n解释：result = [1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,10], k = 2\n输出：6\n解释：result = [2,8]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,3,6], k = 3\n输出：0\n解释：result = [3,3,3] or result = [4,4,4]\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 10000`\n-   `0 <= nums[i] <= 10000`\n-   `0 <= k <= 10000`\n\n**提交：**\n\n```Rust\nimpl Solution {\n    pub fn smallest_range_i(nums: Vec<i32>, k: i32) -> i32 {\n        let max = nums.iter().max().unwrap();\n        let min = nums.iter().min().unwrap();\n        (max-min-2*k).max(0)\n    }\n}\n```\n\n## T2 909. 蛇梯棋\n\n-   **通过的用户数**11\n-   **尝试过的用户数**57\n-   **用户总通过次数**11\n-   **用户总提交次数**177\n-   **题目难度** **Medium**\n\n给你一个大小为 `n x n` 的整数矩阵 `board` ，方格按从 `1` 到 `n2` 编号，编号遵循 [转行交替方式](https://baike.baidu.com/item/牛耕式转行书写法/17195786) ，**从左下角开始** （即，从 `board[n - 1][0]` 开始）每一行交替方向。\n\n玩家从棋盘上的方格 `1` （总是在最后一行、第一列）开始出发。\n\n每一回合，玩家需要从当前方格 `curr` 开始出发，按下述要求前进：\n\n-   选定目标方格 next ，目标方格的编号符合范围 [curr + 1, min(curr + 6, n^2)]\n\n    -   该选择模拟了掷 **六面体骰子** 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。\n\n-   传送玩家：如果目标方格 `next` 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 `next` 。 \n\n-   当玩家到达编号 `n^2` 的方格时，游戏结束。\n\n`r` 行 `c` 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 `board[r][c] != -1`，那个蛇或梯子的目的地将会是 `board[r][c]`。编号为 `1` 和 `n^2` 的方格上没有蛇或梯子。\n\n注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 **不能** 继续移动。\n\n-   举个例子，假设棋盘是 `[[-1,4],[-1,3]]` ，第一次移动，玩家的目标方格是 `2` 。那么这个玩家将会顺着梯子到达方格 `3` ，但 **不能** 顺着方格 `3` 上的梯子前往方格 `4` 。\n\n返回达到编号为 `n^2` 的方格所需的最少移动次数，如果不可能，则返回 `-1`。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2018/09/23/snakes.png)\n\n```\n输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\n输出：4\n解释：\n首先，从方格 1 [第 5 行，第 0 列] 开始。 \n先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。\n然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。\n接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 \n最后决定移动到方格 36 , 游戏结束。 \n可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 \n```\n\n**示例 2：**\n\n```\n输入：board = [[-1,-1],[-1,3]]\n输出：1\n```\n\n **提示：**\n\n-   `n == board.length == board[i].length`\n-   `2 <= n <= 20`\n-   `grid[i][j]` 的值是 `-1` 或在范围 `[1, n2]` 内\n-   编号为 `1` 和 `n2` 的方格上没有蛇或梯子\n\n**题解：**\n\n>   完全想复杂了，转图写了个 Dijk，还有个本质的 bug\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::convert::{From, Into, TryFrom, TryInto};\n// use std::io;\nuse std::marker::PhantomData;\nuse std::rc::Rc;\nuse std::slice::SliceIndex;\n\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\n\nstruct LinkedForwardStar {\n    to: Vec<usize>,\n    nxt: Vec<usize>,\n    wht: Vec<i32>,\n    hd: Vec<usize>,\n    tot: usize,\n}\n\nimpl LinkedForwardStar {\n    pub fn with_capacity(cap: usize) -> Self {\n        Self {\n            to: vec![usize::MAX; cap],\n            nxt: vec![usize::MAX; cap],\n            wht: vec![0; cap],\n            hd: vec![usize::MAX; cap],\n            tot: 0\n        }\n    }\n\n    pub fn add(&mut self, u: usize, v: usize, w: i32) {\n        self.tot += 1;\n        self.to[self.tot] = v;\n        self.nxt[self.tot] = self.hd[u];\n        self.wht[self.tot] = w;\n        self.hd[u] = self.tot;\n    }\n\n    pub fn dijkstra_solver(&self, src: usize, n: usize) -> i32 {\n        const INF: i32 = 0x3f3f3f3f;\n        let mut dist = vec![INF; n + 1];\n        let mut path = vec![0; n + 1];\n        let mut vis = vec![vec![0; 2]; n + 1];\n        dist[src] = 0;\n        let mut heap = BinaryHeap::new();\n        heap.push((dist[src], src, 0));\n        while let Some((_, u, flag)) = heap.pop() {\n            if vis[u][flag] != 0 {\n                continue;\n            }\n            vis[u][flag] = 1;\n            let mut e = self.hd[u];\n            while e != usize::MAX {\n                let v = self.to[e];\n                let w = self.wht[e];\n                if dist[v] > dist[u] + w.abs() && !(flag == 1 && w != 1) {\n                    dist[v] = dist[u] + w.abs();\n                    path[v] = u;\n                    if w != 1 {\n                        heap.push((dist[v], v, 1));\n                    } else {\n                        heap.push((dist[v], v, 0));\n                    }\n                }\n                e = self.nxt[e];\n            }\n        }\n        let mut ans = 1;\n        let mut prv = path[n];\n        let mut cur = path[n];\n        while cur != 0 {\n            // println!(\"{:#?}\", cur);\n            cur = path[cur];\n            if prv - cur > 6 {\n                prv = cur;\n                ans += 1;\n            }\n        }\n        ans\n    }\n}\n\nimpl Solution {\n    pub fn snakes_and_ladders(board: Vec<Vec<i32>>) -> i32 {\n        let n = board.len();\n        let mut lfs = LinkedForwardStar::with_capacity(200020);\n        for i in 0..n {\n            for j in 0..n {\n                let idx = Solution::to_index(i, j, n);\n                let i = n - i - 1;\n                if idx == n * n {\n                    break;\n                }\n                lfs.add(idx, idx + 1, 1);\n                if board[i][j] != -1 {\n                    // println!(\"{}->{}\", idx, board[i][j]);\n                    lfs.add(idx, board[i][j] as usize, -1);\n                }\n            }\n        }\n        lfs.dijkstra_solver(1, n * n)\n    }\n\n    pub fn to_index(x: usize, y: usize, n: usize) -> usize {\n        if ((x / n) & 1) == 0 {\n            x * n + y + 1\n        } else {\n            x * n + (n - y)\n        }\n    }\n}\n```\n\n>   然后挂在了如下测试点\n>\n>   ```\n>   input: [[-1,-1,-1],[-1,9,8],[-1,8,9]]\n>   output: 2\n>   answer: 1\n>   ```\n>\n>   最生气的是这题我 tm 还做过，BFS 的 AC 代码如下\n\n```go\nfunc init() {\n\tdebug.SetGCPercent(-1)\n}\n\nfunc updatePos(idx int, n int) (r int, c int) {\n\tr, c = (idx-1)/n, (idx-1)%n\n\tif r&1 == 1 {\n\t\tc = n - 1 - c\n\t}\n\tr = n - 1 - r\n\treturn\n}\n\ntype Pair struct {\n\tidx  int\n\tstep int\n}\n\nfunc snakesAndLadders(board [][]int) int {\n\tn := len(board)\n\tvis := make([]bool, n*n+1)\n\tq := []Pair{{1, 0}}\n\tfor len(q) > 0 {\n\t\tp := q[0]\n\t\tq = q[1:]\n\t\tfor i := 1; i <= 6; i++ {\n\t\t\tnxt := p.idx + i\n\t\t\tif nxt < 0 || nxt > n*n {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tr, c := updatePos(nxt, n)\n\t\t\t// 梯子或者蛇\n\t\t\tif board[r][c] != -1 {\n\t\t\t\tnxt = board[r][c]\n\t\t\t}\n\t\t\tif nxt == n*n {\n\t\t\t\treturn p.step + 1\n\t\t\t}\n\t\t\tif !vis[nxt] {\n\t\t\t\tvis[nxt] = true\n\t\t\t\tq = append(q, Pair{nxt, p.step + 1})\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n>   其实写到一半已经意识到这个图 tm 所有的边权都是 1，该转 BFS 了，但是还是头铁 md\n\n## L3 910. 最小差值 II\n\n-   **通过的用户数**7\n-   **尝试过的用户数**154\n-   **用户总通过次数**7\n-   **用户总提交次数**646\n-   **题目难度** **Medium**\n\n给你一个整数数组 `A`，对于每个整数 `A[i]`，可以选择 **`x = -K` 或是 `x = K`** （`**K**` 总是非负整数），并将 `x` 加到 `A[i]` 中。\n\n在此过程之后，得到数组 `B`。\n\n返回 `B` 的最大值和 `B` 的最小值之间可能存在的最小差值。\n\n**示例 1：**\n\n```\n输入：A = [1], K = 0\n输出：0\n解释：B = [1]\n```\n\n**示例 2：**\n\n```\n输入：A = [0,10], K = 2\n输出：6\n解释：B = [2,8]\n```\n\n**示例 3：**\n\n```\n输入：A = [1,3,6], K = 3\n输出：3\n解释：B = [4,6,3]\n```\n\n**提示：**\n\n-   `1 <= A.length <= 10000`\n-   `0 <= A[i] <= 10000`\n-   `0 <= K <= 10000`\n\n**题解：**\n\n>   [太难了，只能画图凭直觉 - 最小差值 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/smallest-range-ii/solution/tai-nan-liao-zhi-neng-hua-tu-ping-zhi-jue-by-user8/)\n>\n>   贪心思路。至于为什么是对的，证明可以参考官解。\n\n```rust\nimpl Solution {\n    pub fn smallest_range_ii(mut nums: Vec<i32>, k: i32) -> i32 {\n        nums.sort();\n        let n = nums.len();\n        let mut ans = nums[n - 1] - nums[0];\n        for i in 0..n-1 {\n            let max = (nums[i] + k).max(nums[n - 1] - k);\n            let min = (nums[0] + k).min(nums[i + 1] - k);\n            ans = ans.min(max - min);\n        }\n        ans\n    }\n}\n```\n\n## T4 911. 在线选举\n\n-   **通过的用户数**14\n-   **尝试过的用户数**35\n-   **用户总通过次数**14\n-   **用户总提交次数**94\n-   **题目难度** **Medium**\n\n在选举中，第 `i` 张票是在时间为 `times[i]` 时投给 `persons[i]` 的。\n\n现在，我们想要实现下面的查询函数： `TopVotedCandidate.q(int t)` 将返回在 `t` 时刻主导选举的候选人的编号。\n\n在 `t` 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。\n\n**示例：**\n\n```\n输入：[\"TopVotedCandidate\",\"q\",\"q\",\"q\",\"q\",\"q\",\"q\"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]\n输出：[null,0,1,1,0,0,1]\n解释：\n时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。\n时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。\n时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。\n在时间 15、24 和 8 处继续执行 3 个查询。\n```\n\n**提示：**\n\n1.  `1 <= persons.length = times.length <= 5000`\n2.  `0 <= persons[i] <= persons.length`\n3.  `times` 是严格递增的数组，所有元素都在 `[0, 10^9]` 范围中。\n4.  每个测试用例最多调用 `10000` 次 `TopVotedCandidate.q`。\n5.  `TopVotedCandidate.q(int t)` 被调用时总是满足 `t >= times[0]`。\n\n**题解：**\n\n>   离线查询。预处理每个选票到达时刻的结果，记录 (Time, Winner) 对，这可以通过维护一个 CurrMaxCnt 和 CurrWinner ，在每次插入选票的时候更新即可。之后对于每次查询，二分位置即可。\n\n```Java\nclass TopVotedCandidate {\n    List<Vote> A;\n    public TopVotedCandidate(int[] persons, int[] times) {\n        A = new ArrayList();\n        Map<Integer, Integer> count = new HashMap();\n        int leader = -1;  // current leader\n        int m = 0;  // current number of votes for leader\n\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i], t = times[i];\n            int c = count.getOrDefault(p, 0) + 1;\n            count.put(p, c);\n\n            if (c >= m) {\n                if (p != leader) {  // lead change\n                    leader = p;\n                    A.add(new Vote(leader, t));\n                }\n\n                if (c > m) m = c;\n            }\n        }\n    }\n\n    public int q(int t) {\n        int lo = 1, hi = A.size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(mi).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n\n        return A.get(lo - 1).person;\n    }\n}\n\nclass Vote {\n    int person, time;\n    Vote(int p, int t) {\n        person = p;\n        time = t;\n    }\n}\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/online-election/solution/zai-xian-xuan-ju-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","source":"_posts/virtual-contest-103.md","raw":"---\ntitle: LeetCode 虚拟周赛 103\ndate: 2021-11-15 23:39:59\ntags: LeetCode 周赛总结\n---\n\n-----\n\n# LeetCode 虚拟周赛 103\n\n>   人做麻了，被 T2 自己的傻逼想法卡死\n\n## T1 908. 最小差值 I\n\n-   **通过的用户数**257\n-   **尝试过的用户数**282\n-   **用户总通过次数**263\n-   **用户总提交次数**485\n-   **题目难度** **Easy**\n\n给你一个整数数组 `nums`，请你给数组中的每个元素 `nums[i]` 都加上一个任意数字 `x` （`-k <= x <= k`），从而得到一个新数组 `result` 。\n\n返回数组 `result` 的最大值和最小值之间可能存在的最小差值。\n\n**示例 1：**\n\n```\n输入：nums = [1], k = 0\n输出：0\n解释：result = [1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,10], k = 2\n输出：6\n解释：result = [2,8]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,3,6], k = 3\n输出：0\n解释：result = [3,3,3] or result = [4,4,4]\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 10000`\n-   `0 <= nums[i] <= 10000`\n-   `0 <= k <= 10000`\n\n**提交：**\n\n```Rust\nimpl Solution {\n    pub fn smallest_range_i(nums: Vec<i32>, k: i32) -> i32 {\n        let max = nums.iter().max().unwrap();\n        let min = nums.iter().min().unwrap();\n        (max-min-2*k).max(0)\n    }\n}\n```\n\n## T2 909. 蛇梯棋\n\n-   **通过的用户数**11\n-   **尝试过的用户数**57\n-   **用户总通过次数**11\n-   **用户总提交次数**177\n-   **题目难度** **Medium**\n\n给你一个大小为 `n x n` 的整数矩阵 `board` ，方格按从 `1` 到 `n2` 编号，编号遵循 [转行交替方式](https://baike.baidu.com/item/牛耕式转行书写法/17195786) ，**从左下角开始** （即，从 `board[n - 1][0]` 开始）每一行交替方向。\n\n玩家从棋盘上的方格 `1` （总是在最后一行、第一列）开始出发。\n\n每一回合，玩家需要从当前方格 `curr` 开始出发，按下述要求前进：\n\n-   选定目标方格 next ，目标方格的编号符合范围 [curr + 1, min(curr + 6, n^2)]\n\n    -   该选择模拟了掷 **六面体骰子** 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。\n\n-   传送玩家：如果目标方格 `next` 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 `next` 。 \n\n-   当玩家到达编号 `n^2` 的方格时，游戏结束。\n\n`r` 行 `c` 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 `board[r][c] != -1`，那个蛇或梯子的目的地将会是 `board[r][c]`。编号为 `1` 和 `n^2` 的方格上没有蛇或梯子。\n\n注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 **不能** 继续移动。\n\n-   举个例子，假设棋盘是 `[[-1,4],[-1,3]]` ，第一次移动，玩家的目标方格是 `2` 。那么这个玩家将会顺着梯子到达方格 `3` ，但 **不能** 顺着方格 `3` 上的梯子前往方格 `4` 。\n\n返回达到编号为 `n^2` 的方格所需的最少移动次数，如果不可能，则返回 `-1`。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2018/09/23/snakes.png)\n\n```\n输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\n输出：4\n解释：\n首先，从方格 1 [第 5 行，第 0 列] 开始。 \n先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。\n然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。\n接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 \n最后决定移动到方格 36 , 游戏结束。 \n可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 \n```\n\n**示例 2：**\n\n```\n输入：board = [[-1,-1],[-1,3]]\n输出：1\n```\n\n **提示：**\n\n-   `n == board.length == board[i].length`\n-   `2 <= n <= 20`\n-   `grid[i][j]` 的值是 `-1` 或在范围 `[1, n2]` 内\n-   编号为 `1` 和 `n2` 的方格上没有蛇或梯子\n\n**题解：**\n\n>   完全想复杂了，转图写了个 Dijk，还有个本质的 bug\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::convert::{From, Into, TryFrom, TryInto};\n// use std::io;\nuse std::marker::PhantomData;\nuse std::rc::Rc;\nuse std::slice::SliceIndex;\n\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\n\nstruct LinkedForwardStar {\n    to: Vec<usize>,\n    nxt: Vec<usize>,\n    wht: Vec<i32>,\n    hd: Vec<usize>,\n    tot: usize,\n}\n\nimpl LinkedForwardStar {\n    pub fn with_capacity(cap: usize) -> Self {\n        Self {\n            to: vec![usize::MAX; cap],\n            nxt: vec![usize::MAX; cap],\n            wht: vec![0; cap],\n            hd: vec![usize::MAX; cap],\n            tot: 0\n        }\n    }\n\n    pub fn add(&mut self, u: usize, v: usize, w: i32) {\n        self.tot += 1;\n        self.to[self.tot] = v;\n        self.nxt[self.tot] = self.hd[u];\n        self.wht[self.tot] = w;\n        self.hd[u] = self.tot;\n    }\n\n    pub fn dijkstra_solver(&self, src: usize, n: usize) -> i32 {\n        const INF: i32 = 0x3f3f3f3f;\n        let mut dist = vec![INF; n + 1];\n        let mut path = vec![0; n + 1];\n        let mut vis = vec![vec![0; 2]; n + 1];\n        dist[src] = 0;\n        let mut heap = BinaryHeap::new();\n        heap.push((dist[src], src, 0));\n        while let Some((_, u, flag)) = heap.pop() {\n            if vis[u][flag] != 0 {\n                continue;\n            }\n            vis[u][flag] = 1;\n            let mut e = self.hd[u];\n            while e != usize::MAX {\n                let v = self.to[e];\n                let w = self.wht[e];\n                if dist[v] > dist[u] + w.abs() && !(flag == 1 && w != 1) {\n                    dist[v] = dist[u] + w.abs();\n                    path[v] = u;\n                    if w != 1 {\n                        heap.push((dist[v], v, 1));\n                    } else {\n                        heap.push((dist[v], v, 0));\n                    }\n                }\n                e = self.nxt[e];\n            }\n        }\n        let mut ans = 1;\n        let mut prv = path[n];\n        let mut cur = path[n];\n        while cur != 0 {\n            // println!(\"{:#?}\", cur);\n            cur = path[cur];\n            if prv - cur > 6 {\n                prv = cur;\n                ans += 1;\n            }\n        }\n        ans\n    }\n}\n\nimpl Solution {\n    pub fn snakes_and_ladders(board: Vec<Vec<i32>>) -> i32 {\n        let n = board.len();\n        let mut lfs = LinkedForwardStar::with_capacity(200020);\n        for i in 0..n {\n            for j in 0..n {\n                let idx = Solution::to_index(i, j, n);\n                let i = n - i - 1;\n                if idx == n * n {\n                    break;\n                }\n                lfs.add(idx, idx + 1, 1);\n                if board[i][j] != -1 {\n                    // println!(\"{}->{}\", idx, board[i][j]);\n                    lfs.add(idx, board[i][j] as usize, -1);\n                }\n            }\n        }\n        lfs.dijkstra_solver(1, n * n)\n    }\n\n    pub fn to_index(x: usize, y: usize, n: usize) -> usize {\n        if ((x / n) & 1) == 0 {\n            x * n + y + 1\n        } else {\n            x * n + (n - y)\n        }\n    }\n}\n```\n\n>   然后挂在了如下测试点\n>\n>   ```\n>   input: [[-1,-1,-1],[-1,9,8],[-1,8,9]]\n>   output: 2\n>   answer: 1\n>   ```\n>\n>   最生气的是这题我 tm 还做过，BFS 的 AC 代码如下\n\n```go\nfunc init() {\n\tdebug.SetGCPercent(-1)\n}\n\nfunc updatePos(idx int, n int) (r int, c int) {\n\tr, c = (idx-1)/n, (idx-1)%n\n\tif r&1 == 1 {\n\t\tc = n - 1 - c\n\t}\n\tr = n - 1 - r\n\treturn\n}\n\ntype Pair struct {\n\tidx  int\n\tstep int\n}\n\nfunc snakesAndLadders(board [][]int) int {\n\tn := len(board)\n\tvis := make([]bool, n*n+1)\n\tq := []Pair{{1, 0}}\n\tfor len(q) > 0 {\n\t\tp := q[0]\n\t\tq = q[1:]\n\t\tfor i := 1; i <= 6; i++ {\n\t\t\tnxt := p.idx + i\n\t\t\tif nxt < 0 || nxt > n*n {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tr, c := updatePos(nxt, n)\n\t\t\t// 梯子或者蛇\n\t\t\tif board[r][c] != -1 {\n\t\t\t\tnxt = board[r][c]\n\t\t\t}\n\t\t\tif nxt == n*n {\n\t\t\t\treturn p.step + 1\n\t\t\t}\n\t\t\tif !vis[nxt] {\n\t\t\t\tvis[nxt] = true\n\t\t\t\tq = append(q, Pair{nxt, p.step + 1})\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n>   其实写到一半已经意识到这个图 tm 所有的边权都是 1，该转 BFS 了，但是还是头铁 md\n\n## L3 910. 最小差值 II\n\n-   **通过的用户数**7\n-   **尝试过的用户数**154\n-   **用户总通过次数**7\n-   **用户总提交次数**646\n-   **题目难度** **Medium**\n\n给你一个整数数组 `A`，对于每个整数 `A[i]`，可以选择 **`x = -K` 或是 `x = K`** （`**K**` 总是非负整数），并将 `x` 加到 `A[i]` 中。\n\n在此过程之后，得到数组 `B`。\n\n返回 `B` 的最大值和 `B` 的最小值之间可能存在的最小差值。\n\n**示例 1：**\n\n```\n输入：A = [1], K = 0\n输出：0\n解释：B = [1]\n```\n\n**示例 2：**\n\n```\n输入：A = [0,10], K = 2\n输出：6\n解释：B = [2,8]\n```\n\n**示例 3：**\n\n```\n输入：A = [1,3,6], K = 3\n输出：3\n解释：B = [4,6,3]\n```\n\n**提示：**\n\n-   `1 <= A.length <= 10000`\n-   `0 <= A[i] <= 10000`\n-   `0 <= K <= 10000`\n\n**题解：**\n\n>   [太难了，只能画图凭直觉 - 最小差值 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/smallest-range-ii/solution/tai-nan-liao-zhi-neng-hua-tu-ping-zhi-jue-by-user8/)\n>\n>   贪心思路。至于为什么是对的，证明可以参考官解。\n\n```rust\nimpl Solution {\n    pub fn smallest_range_ii(mut nums: Vec<i32>, k: i32) -> i32 {\n        nums.sort();\n        let n = nums.len();\n        let mut ans = nums[n - 1] - nums[0];\n        for i in 0..n-1 {\n            let max = (nums[i] + k).max(nums[n - 1] - k);\n            let min = (nums[0] + k).min(nums[i + 1] - k);\n            ans = ans.min(max - min);\n        }\n        ans\n    }\n}\n```\n\n## T4 911. 在线选举\n\n-   **通过的用户数**14\n-   **尝试过的用户数**35\n-   **用户总通过次数**14\n-   **用户总提交次数**94\n-   **题目难度** **Medium**\n\n在选举中，第 `i` 张票是在时间为 `times[i]` 时投给 `persons[i]` 的。\n\n现在，我们想要实现下面的查询函数： `TopVotedCandidate.q(int t)` 将返回在 `t` 时刻主导选举的候选人的编号。\n\n在 `t` 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。\n\n**示例：**\n\n```\n输入：[\"TopVotedCandidate\",\"q\",\"q\",\"q\",\"q\",\"q\",\"q\"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]\n输出：[null,0,1,1,0,0,1]\n解释：\n时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。\n时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。\n时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。\n在时间 15、24 和 8 处继续执行 3 个查询。\n```\n\n**提示：**\n\n1.  `1 <= persons.length = times.length <= 5000`\n2.  `0 <= persons[i] <= persons.length`\n3.  `times` 是严格递增的数组，所有元素都在 `[0, 10^9]` 范围中。\n4.  每个测试用例最多调用 `10000` 次 `TopVotedCandidate.q`。\n5.  `TopVotedCandidate.q(int t)` 被调用时总是满足 `t >= times[0]`。\n\n**题解：**\n\n>   离线查询。预处理每个选票到达时刻的结果，记录 (Time, Winner) 对，这可以通过维护一个 CurrMaxCnt 和 CurrWinner ，在每次插入选票的时候更新即可。之后对于每次查询，二分位置即可。\n\n```Java\nclass TopVotedCandidate {\n    List<Vote> A;\n    public TopVotedCandidate(int[] persons, int[] times) {\n        A = new ArrayList();\n        Map<Integer, Integer> count = new HashMap();\n        int leader = -1;  // current leader\n        int m = 0;  // current number of votes for leader\n\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i], t = times[i];\n            int c = count.getOrDefault(p, 0) + 1;\n            count.put(p, c);\n\n            if (c >= m) {\n                if (p != leader) {  // lead change\n                    leader = p;\n                    A.add(new Vote(leader, t));\n                }\n\n                if (c > m) m = c;\n            }\n        }\n    }\n\n    public int q(int t) {\n        int lo = 1, hi = A.size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(mi).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n\n        return A.get(lo - 1).person;\n    }\n}\n\nclass Vote {\n    int person, time;\n    Vote(int p, int t) {\n        person = p;\n        time = t;\n    }\n}\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/online-election/solution/zai-xian-xuan-ju-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","slug":"virtual-contest-103","published":1,"updated":"2021-11-17T15:16:56.273Z","_id":"ckw3kx8px00061cy5g3zydb1s","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h1 id=\"LeetCode-虚拟周赛-103\"><a href=\"#LeetCode-虚拟周赛-103\" class=\"headerlink\" title=\"LeetCode 虚拟周赛 103\"></a>LeetCode 虚拟周赛 103</h1><blockquote>\n<p>  人做麻了，被 T2 自己的傻逼想法卡死</p>\n</blockquote>\n<h2 id=\"T1-908-最小差值-I\"><a href=\"#T1-908-最小差值-I\" class=\"headerlink\" title=\"T1 908. 最小差值 I\"></a>T1 908. 最小差值 I</h2><ul>\n<li>  <strong>通过的用户数</strong>257</li>\n<li>  <strong>尝试过的用户数</strong>282</li>\n<li>  <strong>用户总通过次数</strong>263</li>\n<li>  <strong>用户总提交次数</strong>485</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code>，请你给数组中的每个元素 <code>nums[i]</code> 都加上一个任意数字 <code>x</code> （<code>-k &lt;= x &lt;= k</code>），从而得到一个新数组 <code>result</code> 。</p>\n<p>返回数组 <code>result</code> 的最大值和最小值之间可能存在的最小差值。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1], k = 0</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：result = [1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,10], k = 2</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：result = [2,8]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,6], k = 3</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：result = [3,3,3] or result = [4,4,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 10000</code></li>\n<li>  <code>0 &lt;= nums[i] &lt;= 10000</code></li>\n<li>  <code>0 &lt;= k &lt;= 10000</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">smallest_range_i</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> max = nums.iter().max().unwrap();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> min = nums.iter().min().unwrap();</span><br><span class=\"line\">        (max-min-<span class=\"number\">2</span>*k).max(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-909-蛇梯棋\"><a href=\"#T2-909-蛇梯棋\" class=\"headerlink\" title=\"T2 909. 蛇梯棋\"></a>T2 909. 蛇梯棋</h2><ul>\n<li>  <strong>通过的用户数</strong>11</li>\n<li>  <strong>尝试过的用户数</strong>57</li>\n<li>  <strong>用户总通过次数</strong>11</li>\n<li>  <strong>用户总提交次数</strong>177</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code> ，方格按从 <code>1</code> 到 <code>n2</code> 编号，编号遵循 <a href=\"https://baike.baidu.com/item/%E7%89%9B%E8%80%95%E5%BC%8F%E8%BD%AC%E8%A1%8C%E4%B9%A6%E5%86%99%E6%B3%95/17195786\">转行交替方式</a> ，<strong>从左下角开始</strong> （即，从 <code>board[n - 1][0]</code> 开始）每一行交替方向。</p>\n<p>玩家从棋盘上的方格 <code>1</code> （总是在最后一行、第一列）开始出发。</p>\n<p>每一回合，玩家需要从当前方格 <code>curr</code> 开始出发，按下述要求前进：</p>\n<ul>\n<li><p>选定目标方格 next ，目标方格的编号符合范围 [curr + 1, min(curr + 6, n^2)]</p>\n<ul>\n<li>  该选择模拟了掷 <strong>六面体骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li>\n</ul>\n</li>\n<li><p>  传送玩家：如果目标方格 <code>next</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>next</code> 。 </p>\n</li>\n<li><p>  当玩家到达编号 <code>n^2</code> 的方格时，游戏结束。</p>\n</li>\n</ul>\n<p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。编号为 <code>1</code> 和 <code>n^2</code> 的方格上没有蛇或梯子。</p>\n<p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 <strong>不能</strong> 继续移动。</p>\n<ul>\n<li>  举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code> ，第一次移动，玩家的目标方格是 <code>2</code> 。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但 <strong>不能</strong> 顺着方格 <code>3</code> 上的梯子前往方格 <code>4</code> 。</li>\n</ul>\n<p>返回达到编号为 <code>n^2</code> 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/09/23/snakes.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">首先，从方格 1 [第 5 行，第 0 列] 开始。 </span><br><span class=\"line\">先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。</span><br><span class=\"line\">然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。</span><br><span class=\"line\">接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 </span><br><span class=\"line\">最后决定移动到方格 36 , 游戏结束。 </span><br><span class=\"line\">可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 </span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[-1,-1],[-1,3]]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p> <strong>提示：</strong></p>\n<ul>\n<li>  <code>n == board.length == board[i].length</code></li>\n<li>  <code>2 &lt;= n &lt;= 20</code></li>\n<li>  <code>grid[i][j]</code> 的值是 <code>-1</code> 或在范围 <code>[1, n2]</code> 内</li>\n<li>  编号为 <code>1</code> 和 <code>n2</code> 的方格上没有蛇或梯子</li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  完全想复杂了，转图写了个 Dijk，还有个本质的 bug</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::convert::&#123;<span class=\"built_in\">From</span>, <span class=\"built_in\">Into</span>, TryFrom, TryInto&#125;;</span><br><span class=\"line\"><span class=\"comment\">// use std::io;</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::slice::SliceIndex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">    to: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    nxt: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    wht: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;,</span><br><span class=\"line\">    hd: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            to: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            nxt: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            wht: <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; cap],</span><br><span class=\"line\">            hd: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            tot: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, u: <span class=\"built_in\">usize</span>, v: <span class=\"built_in\">usize</span>, w: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.to[<span class=\"keyword\">self</span>.tot] = v;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.nxt[<span class=\"keyword\">self</span>.tot] = <span class=\"keyword\">self</span>.hd[u];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.wht[<span class=\"keyword\">self</span>.tot] = w;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.hd[u] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(&amp;<span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, n: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> INF: <span class=\"built_in\">i32</span> = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[INF; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> path = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">2</span>]; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> heap = BinaryHeap::new();</span><br><span class=\"line\">        heap.push((dist[src], src, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>((_, u, flag)) = heap.pop() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> vis[u][flag] != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            vis[u][flag] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> e = <span class=\"keyword\">self</span>.hd[u];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> e != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> v = <span class=\"keyword\">self</span>.to[e];</span><br><span class=\"line\">                <span class=\"keyword\">let</span> w = <span class=\"keyword\">self</span>.wht[e];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[v] &gt; dist[u] + w.abs() &amp;&amp; !(flag == <span class=\"number\">1</span> &amp;&amp; w != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    dist[v] = dist[u] + w.abs();</span><br><span class=\"line\">                    path[v] = u;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> w != <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                        heap.push((dist[v], v, <span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        heap.push((dist[v], v, <span class=\"number\">0</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                e = <span class=\"keyword\">self</span>.nxt[e];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> prv = path[n];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cur = path[n];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// println!(&quot;&#123;:#?&#125;&quot;, cur);</span></span><br><span class=\"line\">            cur = path[cur];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> prv - cur &gt; <span class=\"number\">6</span> &#123;</span><br><span class=\"line\">                prv = cur;</span><br><span class=\"line\">                ans += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">snakes_and_ladders</span></span>(board: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = board.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(<span class=\"number\">200020</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..n &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..n &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> idx = Solution::to_index(i, j, n);</span><br><span class=\"line\">                <span class=\"keyword\">let</span> i = n - i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> idx == n * n &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lfs.add(idx, idx + <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> board[i][j] != -<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// println!(&quot;&#123;&#125;-&gt;&#123;&#125;&quot;, idx, board[i][j]);</span></span><br><span class=\"line\">                    lfs.add(idx, board[i][j] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lfs.dijkstra_solver(<span class=\"number\">1</span>, n * n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_index</span></span>(x: <span class=\"built_in\">usize</span>, y: <span class=\"built_in\">usize</span>, n: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((x / n) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            x * n + y + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            x * n + (n - y)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  然后挂在了如下测试点</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input: [[-1,-1,-1],[-1,9,8],[-1,8,9]]</span><br><span class=\"line\">output: 2</span><br><span class=\"line\">answer: 1</span><br></pre></td></tr></table></figure>\n\n<p>  最生气的是这题我 tm 还做过，BFS 的 AC 代码如下</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tdebug.SetGCPercent(<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updatePos</span><span class=\"params\">(idx <span class=\"keyword\">int</span>, n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(r <span class=\"keyword\">int</span>, c <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tr, c = (idx<span class=\"number\">-1</span>)/n, (idx<span class=\"number\">-1</span>)%n</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r&amp;<span class=\"number\">1</span> == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\tc = n - <span class=\"number\">1</span> - c</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr = n - <span class=\"number\">1</span> - r</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pair <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tidx  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tstep <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">snakesAndLadders</span><span class=\"params\">(board [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(board)</span><br><span class=\"line\">\tvis := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n*n+<span class=\"number\">1</span>)</span><br><span class=\"line\">\tq := []Pair&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(q) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tp := q[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tq = q[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span>; i++ &#123;</span><br><span class=\"line\">\t\t\tnxt := p.idx + i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> nxt &lt; <span class=\"number\">0</span> || nxt &gt; n*n &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tr, c := updatePos(nxt, n)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 梯子或者蛇</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> board[r][c] != <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\t\tnxt = board[r][c]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> nxt == n*n &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> p.step + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !vis[nxt] &#123;</span><br><span class=\"line\">\t\t\t\tvis[nxt] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\tq = <span class=\"built_in\">append</span>(q, Pair&#123;nxt, p.step + <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  其实写到一半已经意识到这个图 tm 所有的边权都是 1，该转 BFS 了，但是还是头铁 md</p>\n</blockquote>\n<h2 id=\"L3-910-最小差值-II\"><a href=\"#L3-910-最小差值-II\" class=\"headerlink\" title=\"L3 910. 最小差值 II\"></a>L3 910. 最小差值 II</h2><ul>\n<li>  <strong>通过的用户数</strong>7</li>\n<li>  <strong>尝试过的用户数</strong>154</li>\n<li>  <strong>用户总通过次数</strong>7</li>\n<li>  <strong>用户总提交次数</strong>646</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个整数数组 <code>A</code>，对于每个整数 <code>A[i]</code>，可以选择 <strong><code>x = -K</code> 或是 <code>x = K</code></strong> （<code>**K**</code> 总是非负整数），并将 <code>x</code> 加到 <code>A[i]</code> 中。</p>\n<p>在此过程之后，得到数组 <code>B</code>。</p>\n<p>返回 <code>B</code> 的最大值和 <code>B</code> 的最小值之间可能存在的最小差值。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：A = [1], K = 0</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：B = [1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：A = [0,10], K = 2</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：B = [2,8]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：A = [1,3,6], K = 3</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：B = [4,6,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= A.length &lt;= 10000</code></li>\n<li>  <code>0 &lt;= A[i] &lt;= 10000</code></li>\n<li>  <code>0 &lt;= K &lt;= 10000</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  <a href=\"https://leetcode-cn.com/problems/smallest-range-ii/solution/tai-nan-liao-zhi-neng-hua-tu-ping-zhi-jue-by-user8/\">太难了，只能画图凭直觉 - 最小差值 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>  贪心思路。至于为什么是对的，证明可以参考官解。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">smallest_range_ii</span></span>(<span class=\"keyword\">mut</span> nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        nums.sort();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = nums.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = nums[n - <span class=\"number\">1</span>] - nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..n-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> max = (nums[i] + k).max(nums[n - <span class=\"number\">1</span>] - k);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> min = (nums[<span class=\"number\">0</span>] + k).min(nums[i + <span class=\"number\">1</span>] - k);</span><br><span class=\"line\">            ans = ans.min(max - min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-911-在线选举\"><a href=\"#T4-911-在线选举\" class=\"headerlink\" title=\"T4 911. 在线选举\"></a>T4 911. 在线选举</h2><ul>\n<li>  <strong>通过的用户数</strong>14</li>\n<li>  <strong>尝试过的用户数</strong>35</li>\n<li>  <strong>用户总通过次数</strong>14</li>\n<li>  <strong>用户总提交次数</strong>94</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>在选举中，第 <code>i</code> 张票是在时间为 <code>times[i]</code> 时投给 <code>persons[i]</code> 的。</p>\n<p>现在，我们想要实现下面的查询函数： <code>TopVotedCandidate.q(int t)</code> 将返回在 <code>t</code> 时刻主导选举的候选人的编号。</p>\n<p>在 <code>t</code> 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[&quot;TopVotedCandidate&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]</span><br><span class=\"line\">输出：[null,0,1,1,0,0,1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。</span><br><span class=\"line\">时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。</span><br><span class=\"line\">时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。</span><br><span class=\"line\">在时间 15、24 和 8 处继续执行 3 个查询。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li> <code>1 &lt;= persons.length = times.length &lt;= 5000</code></li>\n<li> <code>0 &lt;= persons[i] &lt;= persons.length</code></li>\n<li> <code>times</code> 是严格递增的数组，所有元素都在 <code>[0, 10^9]</code> 范围中。</li>\n<li> 每个测试用例最多调用 <code>10000</code> 次 <code>TopVotedCandidate.q</code>。</li>\n<li> <code>TopVotedCandidate.q(int t)</code> 被调用时总是满足 <code>t &gt;= times[0]</code>。</li>\n</ol>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  离线查询。预处理每个选票到达时刻的结果，记录 (Time, Winner) 对，这可以通过维护一个 CurrMaxCnt 和 CurrWinner ，在每次插入选票的时候更新即可。之后对于每次查询，二分位置即可。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopVotedCandidate</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Vote&gt; A;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TopVotedCandidate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] persons, <span class=\"keyword\">int</span>[] times)</span> </span>&#123;</span><br><span class=\"line\">        A = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; count = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leader = -<span class=\"number\">1</span>;  <span class=\"comment\">// current leader</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">0</span>;  <span class=\"comment\">// current number of votes for leader</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; persons.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = persons[i], t = times[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = count.getOrDefault(p, <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            count.put(p, c);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c &gt;= m) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p != leader) &#123;  <span class=\"comment\">// lead change</span></span><br><span class=\"line\">                    leader = p;</span><br><span class=\"line\">                    A.add(<span class=\"keyword\">new</span> Vote(leader, t));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c &gt; m) m = c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">q</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">1</span>, hi = A.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mi = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A.get(mi).time &lt;= t)</span><br><span class=\"line\">                lo = mi + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                hi = mi;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> A.get(lo - <span class=\"number\">1</span>).person;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vote</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> person, time;</span><br><span class=\"line\">    Vote(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> t) &#123;</span><br><span class=\"line\">        person = p;</span><br><span class=\"line\">        time = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/online-election/solution/zai-xian-xuan-ju-by-leetcode/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-虚拟周赛-103\"><a href=\"#LeetCode-虚拟周赛-103\" class=\"headerlink\" title=\"LeetCode 虚拟周赛 103\"></a>LeetCode 虚拟周赛 103</h1><blockquote>\n<p>  人做麻了，被 T2 自己的傻逼想法卡死</p>\n</blockquote>\n<h2 id=\"T1-908-最小差值-I\"><a href=\"#T1-908-最小差值-I\" class=\"headerlink\" title=\"T1 908. 最小差值 I\"></a>T1 908. 最小差值 I</h2><ul>\n<li>  <strong>通过的用户数</strong>257</li>\n<li>  <strong>尝试过的用户数</strong>282</li>\n<li>  <strong>用户总通过次数</strong>263</li>\n<li>  <strong>用户总提交次数</strong>485</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code>，请你给数组中的每个元素 <code>nums[i]</code> 都加上一个任意数字 <code>x</code> （<code>-k &lt;= x &lt;= k</code>），从而得到一个新数组 <code>result</code> 。</p>\n<p>返回数组 <code>result</code> 的最大值和最小值之间可能存在的最小差值。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1], k = 0</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：result = [1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,10], k = 2</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：result = [2,8]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,6], k = 3</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：result = [3,3,3] or result = [4,4,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 10000</code></li>\n<li>  <code>0 &lt;= nums[i] &lt;= 10000</code></li>\n<li>  <code>0 &lt;= k &lt;= 10000</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">smallest_range_i</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> max = nums.iter().max().unwrap();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> min = nums.iter().min().unwrap();</span><br><span class=\"line\">        (max-min-<span class=\"number\">2</span>*k).max(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-909-蛇梯棋\"><a href=\"#T2-909-蛇梯棋\" class=\"headerlink\" title=\"T2 909. 蛇梯棋\"></a>T2 909. 蛇梯棋</h2><ul>\n<li>  <strong>通过的用户数</strong>11</li>\n<li>  <strong>尝试过的用户数</strong>57</li>\n<li>  <strong>用户总通过次数</strong>11</li>\n<li>  <strong>用户总提交次数</strong>177</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code> ，方格按从 <code>1</code> 到 <code>n2</code> 编号，编号遵循 <a href=\"https://baike.baidu.com/item/%E7%89%9B%E8%80%95%E5%BC%8F%E8%BD%AC%E8%A1%8C%E4%B9%A6%E5%86%99%E6%B3%95/17195786\">转行交替方式</a> ，<strong>从左下角开始</strong> （即，从 <code>board[n - 1][0]</code> 开始）每一行交替方向。</p>\n<p>玩家从棋盘上的方格 <code>1</code> （总是在最后一行、第一列）开始出发。</p>\n<p>每一回合，玩家需要从当前方格 <code>curr</code> 开始出发，按下述要求前进：</p>\n<ul>\n<li><p>选定目标方格 next ，目标方格的编号符合范围 [curr + 1, min(curr + 6, n^2)]</p>\n<ul>\n<li>  该选择模拟了掷 <strong>六面体骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li>\n</ul>\n</li>\n<li><p>  传送玩家：如果目标方格 <code>next</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>next</code> 。 </p>\n</li>\n<li><p>  当玩家到达编号 <code>n^2</code> 的方格时，游戏结束。</p>\n</li>\n</ul>\n<p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。编号为 <code>1</code> 和 <code>n^2</code> 的方格上没有蛇或梯子。</p>\n<p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 <strong>不能</strong> 继续移动。</p>\n<ul>\n<li>  举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code> ，第一次移动，玩家的目标方格是 <code>2</code> 。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但 <strong>不能</strong> 顺着方格 <code>3</code> 上的梯子前往方格 <code>4</code> 。</li>\n</ul>\n<p>返回达到编号为 <code>n^2</code> 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/09/23/snakes.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">首先，从方格 1 [第 5 行，第 0 列] 开始。 </span><br><span class=\"line\">先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。</span><br><span class=\"line\">然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。</span><br><span class=\"line\">接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 </span><br><span class=\"line\">最后决定移动到方格 36 , 游戏结束。 </span><br><span class=\"line\">可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 </span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[-1,-1],[-1,3]]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p> <strong>提示：</strong></p>\n<ul>\n<li>  <code>n == board.length == board[i].length</code></li>\n<li>  <code>2 &lt;= n &lt;= 20</code></li>\n<li>  <code>grid[i][j]</code> 的值是 <code>-1</code> 或在范围 <code>[1, n2]</code> 内</li>\n<li>  编号为 <code>1</code> 和 <code>n2</code> 的方格上没有蛇或梯子</li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  完全想复杂了，转图写了个 Dijk，还有个本质的 bug</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::convert::&#123;<span class=\"built_in\">From</span>, <span class=\"built_in\">Into</span>, TryFrom, TryInto&#125;;</span><br><span class=\"line\"><span class=\"comment\">// use std::io;</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::slice::SliceIndex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">    to: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    nxt: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    wht: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;,</span><br><span class=\"line\">    hd: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            to: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            nxt: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            wht: <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; cap],</span><br><span class=\"line\">            hd: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            tot: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, u: <span class=\"built_in\">usize</span>, v: <span class=\"built_in\">usize</span>, w: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.to[<span class=\"keyword\">self</span>.tot] = v;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.nxt[<span class=\"keyword\">self</span>.tot] = <span class=\"keyword\">self</span>.hd[u];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.wht[<span class=\"keyword\">self</span>.tot] = w;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.hd[u] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(&amp;<span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, n: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> INF: <span class=\"built_in\">i32</span> = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[INF; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> path = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">2</span>]; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> heap = BinaryHeap::new();</span><br><span class=\"line\">        heap.push((dist[src], src, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>((_, u, flag)) = heap.pop() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> vis[u][flag] != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            vis[u][flag] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> e = <span class=\"keyword\">self</span>.hd[u];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> e != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> v = <span class=\"keyword\">self</span>.to[e];</span><br><span class=\"line\">                <span class=\"keyword\">let</span> w = <span class=\"keyword\">self</span>.wht[e];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[v] &gt; dist[u] + w.abs() &amp;&amp; !(flag == <span class=\"number\">1</span> &amp;&amp; w != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    dist[v] = dist[u] + w.abs();</span><br><span class=\"line\">                    path[v] = u;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> w != <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                        heap.push((dist[v], v, <span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        heap.push((dist[v], v, <span class=\"number\">0</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                e = <span class=\"keyword\">self</span>.nxt[e];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> prv = path[n];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cur = path[n];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// println!(&quot;&#123;:#?&#125;&quot;, cur);</span></span><br><span class=\"line\">            cur = path[cur];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> prv - cur &gt; <span class=\"number\">6</span> &#123;</span><br><span class=\"line\">                prv = cur;</span><br><span class=\"line\">                ans += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">snakes_and_ladders</span></span>(board: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = board.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(<span class=\"number\">200020</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..n &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..n &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> idx = Solution::to_index(i, j, n);</span><br><span class=\"line\">                <span class=\"keyword\">let</span> i = n - i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> idx == n * n &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lfs.add(idx, idx + <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> board[i][j] != -<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// println!(&quot;&#123;&#125;-&gt;&#123;&#125;&quot;, idx, board[i][j]);</span></span><br><span class=\"line\">                    lfs.add(idx, board[i][j] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lfs.dijkstra_solver(<span class=\"number\">1</span>, n * n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_index</span></span>(x: <span class=\"built_in\">usize</span>, y: <span class=\"built_in\">usize</span>, n: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((x / n) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            x * n + y + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            x * n + (n - y)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  然后挂在了如下测试点</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input: [[-1,-1,-1],[-1,9,8],[-1,8,9]]</span><br><span class=\"line\">output: 2</span><br><span class=\"line\">answer: 1</span><br></pre></td></tr></table></figure>\n\n<p>  最生气的是这题我 tm 还做过，BFS 的 AC 代码如下</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tdebug.SetGCPercent(<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updatePos</span><span class=\"params\">(idx <span class=\"keyword\">int</span>, n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(r <span class=\"keyword\">int</span>, c <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tr, c = (idx<span class=\"number\">-1</span>)/n, (idx<span class=\"number\">-1</span>)%n</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r&amp;<span class=\"number\">1</span> == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\tc = n - <span class=\"number\">1</span> - c</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr = n - <span class=\"number\">1</span> - r</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pair <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tidx  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tstep <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">snakesAndLadders</span><span class=\"params\">(board [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(board)</span><br><span class=\"line\">\tvis := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n*n+<span class=\"number\">1</span>)</span><br><span class=\"line\">\tq := []Pair&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(q) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tp := q[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tq = q[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span>; i++ &#123;</span><br><span class=\"line\">\t\t\tnxt := p.idx + i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> nxt &lt; <span class=\"number\">0</span> || nxt &gt; n*n &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tr, c := updatePos(nxt, n)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 梯子或者蛇</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> board[r][c] != <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\t\tnxt = board[r][c]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> nxt == n*n &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> p.step + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !vis[nxt] &#123;</span><br><span class=\"line\">\t\t\t\tvis[nxt] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\tq = <span class=\"built_in\">append</span>(q, Pair&#123;nxt, p.step + <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  其实写到一半已经意识到这个图 tm 所有的边权都是 1，该转 BFS 了，但是还是头铁 md</p>\n</blockquote>\n<h2 id=\"L3-910-最小差值-II\"><a href=\"#L3-910-最小差值-II\" class=\"headerlink\" title=\"L3 910. 最小差值 II\"></a>L3 910. 最小差值 II</h2><ul>\n<li>  <strong>通过的用户数</strong>7</li>\n<li>  <strong>尝试过的用户数</strong>154</li>\n<li>  <strong>用户总通过次数</strong>7</li>\n<li>  <strong>用户总提交次数</strong>646</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个整数数组 <code>A</code>，对于每个整数 <code>A[i]</code>，可以选择 <strong><code>x = -K</code> 或是 <code>x = K</code></strong> （<code>**K**</code> 总是非负整数），并将 <code>x</code> 加到 <code>A[i]</code> 中。</p>\n<p>在此过程之后，得到数组 <code>B</code>。</p>\n<p>返回 <code>B</code> 的最大值和 <code>B</code> 的最小值之间可能存在的最小差值。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：A = [1], K = 0</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：B = [1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：A = [0,10], K = 2</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：B = [2,8]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：A = [1,3,6], K = 3</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：B = [4,6,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= A.length &lt;= 10000</code></li>\n<li>  <code>0 &lt;= A[i] &lt;= 10000</code></li>\n<li>  <code>0 &lt;= K &lt;= 10000</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  <a href=\"https://leetcode-cn.com/problems/smallest-range-ii/solution/tai-nan-liao-zhi-neng-hua-tu-ping-zhi-jue-by-user8/\">太难了，只能画图凭直觉 - 最小差值 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>  贪心思路。至于为什么是对的，证明可以参考官解。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">smallest_range_ii</span></span>(<span class=\"keyword\">mut</span> nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        nums.sort();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = nums.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = nums[n - <span class=\"number\">1</span>] - nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..n-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> max = (nums[i] + k).max(nums[n - <span class=\"number\">1</span>] - k);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> min = (nums[<span class=\"number\">0</span>] + k).min(nums[i + <span class=\"number\">1</span>] - k);</span><br><span class=\"line\">            ans = ans.min(max - min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-911-在线选举\"><a href=\"#T4-911-在线选举\" class=\"headerlink\" title=\"T4 911. 在线选举\"></a>T4 911. 在线选举</h2><ul>\n<li>  <strong>通过的用户数</strong>14</li>\n<li>  <strong>尝试过的用户数</strong>35</li>\n<li>  <strong>用户总通过次数</strong>14</li>\n<li>  <strong>用户总提交次数</strong>94</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>在选举中，第 <code>i</code> 张票是在时间为 <code>times[i]</code> 时投给 <code>persons[i]</code> 的。</p>\n<p>现在，我们想要实现下面的查询函数： <code>TopVotedCandidate.q(int t)</code> 将返回在 <code>t</code> 时刻主导选举的候选人的编号。</p>\n<p>在 <code>t</code> 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[&quot;TopVotedCandidate&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]</span><br><span class=\"line\">输出：[null,0,1,1,0,0,1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。</span><br><span class=\"line\">时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。</span><br><span class=\"line\">时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。</span><br><span class=\"line\">在时间 15、24 和 8 处继续执行 3 个查询。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li> <code>1 &lt;= persons.length = times.length &lt;= 5000</code></li>\n<li> <code>0 &lt;= persons[i] &lt;= persons.length</code></li>\n<li> <code>times</code> 是严格递增的数组，所有元素都在 <code>[0, 10^9]</code> 范围中。</li>\n<li> 每个测试用例最多调用 <code>10000</code> 次 <code>TopVotedCandidate.q</code>。</li>\n<li> <code>TopVotedCandidate.q(int t)</code> 被调用时总是满足 <code>t &gt;= times[0]</code>。</li>\n</ol>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  离线查询。预处理每个选票到达时刻的结果，记录 (Time, Winner) 对，这可以通过维护一个 CurrMaxCnt 和 CurrWinner ，在每次插入选票的时候更新即可。之后对于每次查询，二分位置即可。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopVotedCandidate</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Vote&gt; A;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TopVotedCandidate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] persons, <span class=\"keyword\">int</span>[] times)</span> </span>&#123;</span><br><span class=\"line\">        A = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; count = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leader = -<span class=\"number\">1</span>;  <span class=\"comment\">// current leader</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">0</span>;  <span class=\"comment\">// current number of votes for leader</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; persons.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = persons[i], t = times[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = count.getOrDefault(p, <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            count.put(p, c);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c &gt;= m) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p != leader) &#123;  <span class=\"comment\">// lead change</span></span><br><span class=\"line\">                    leader = p;</span><br><span class=\"line\">                    A.add(<span class=\"keyword\">new</span> Vote(leader, t));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c &gt; m) m = c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">q</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">1</span>, hi = A.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mi = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A.get(mi).time &lt;= t)</span><br><span class=\"line\">                lo = mi + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                hi = mi;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> A.get(lo - <span class=\"number\">1</span>).person;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vote</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> person, time;</span><br><span class=\"line\">    Vote(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> t) &#123;</span><br><span class=\"line\">        person = p;</span><br><span class=\"line\">        time = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/online-election/solution/zai-xian-xuan-ju-by-leetcode/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LeetCode 周赛 259","date":"2021-09-19T06:55:49.000Z","_content":"\n---\n\n# LeetCode 周赛 259\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-259/problems/final-value-of-variable-after-performing-operations/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-259/problems/sum-of-beauty-in-the-array/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-259/problems/detect-squares/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-259/problems/longest-subsequence-repeated-k-times/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1091 / 3774 | MiracleSNeko | 7    | 0:15:15  | 0:01:25                                                      | 0:15:15                                                      |                                                              |                                                              |\n\n\n\n## T1 5875. 执行操作后的变量值\n\n-   **通过的用户数**2937\n-   **尝试过的用户数**2956\n-   **用户总通过次数**2960\n-   **用户总提交次数**3107\n-   **题目难度** **Easy**\n\n存在一种仅支持 4 种操作和 1 个变量 `X` 的编程语言：\n\n-   `++X` 和 `X++` 使变量 `X` 的值 **加** `1`\n-   `--X` 和 `X--` 使变量 `X` 的值 **减** `1`\n\n最初，`X` 的值是 `0`\n\n给你一个字符串数组 `operations` ，这是由操作组成的一个列表，返回执行所有操作后， `X` 的 **最终值** 。\n\n**示例 1：**\n\n```\n输入：operations = [\"--X\",\"X++\",\"X++\"]\n输出：1\n解释：操作按下述步骤执行：\n最初，X = 0\n--X：X 减 1 ，X =  0 - 1 = -1\nX++：X 加 1 ，X = -1 + 1 =  0\nX++：X 加 1 ，X =  0 + 1 =  1\n```\n\n**示例 2：**\n\n```\n输入：operations = [\"++X\",\"++X\",\"X++\"]\n输出：3\n解释：操作按下述步骤执行： \n最初，X = 0\n++X：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\nX++：X 加 1 ，X = 2 + 1 = 3\n```\n\n**示例 3：**\n\n```\n输入：operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\n输出：0\n解释：操作按下述步骤执行：\n最初，X = 0\nX++：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\n--X：X 减 1 ，X = 2 - 1 = 1\nX--：X 减 1 ，X = 1 - 1 = 0\n```\n\n**提示：**\n\n-   `1 <= operations.length <= 100`\n-   `operations[i]` 将会是 `\"++X\"`、`\"X++\"`、`\"--X\"` 或 `\"X--\"`\n\n**我的提交：**\n\n```c++\nclass Solution\n{\npublic:\n    int finalValueAfterOperations(Vec<str> &operations)\n    {\n        auto ans = 0;\n        for(auto op: operations)\n        {\n            if (op == \"++X\" || op == \"X++\") ans++;\n            else ans--;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T2 5876. 数组美丽值求和\n\n-   **通过的用户数**2050\n-   **尝试过的用户数**2749\n-   **用户总通过次数**2088\n-   **用户总提交次数**6951\n-   **题目难度** **Medium**\n\n给你一个下标从 **0** 开始的整数数组 `nums` 。对于每个下标 `i`（`1 <= i <= nums.length - 2`），`nums[i]` 的 **美丽值** 等于：\n\n-   `2`，对于所有 `0 <= j < i` 且 `i < k <= nums.length - 1` ，满足 `nums[j] < nums[i] < nums[k]`\n-   `1`，如果满足 `nums[i - 1] < nums[i] < nums[i + 1]` ，且不满足前面的条件\n-   `0`，如果上述条件全部不满足\n\n返回符合 `1 <= i <= nums.length - 2` 的所有 `nums[i]` 的 **美丽值的总和** 。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：2\n解释：对于每个符合范围 1 <= i <= 1 的下标 i :\n- nums[1] 的美丽值等于 2\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,4,6,4]\n输出：1\n解释：对于每个符合范围 1 <= i <= 2 的下标 i :\n- nums[1] 的美丽值等于 1\n- nums[2] 的美丽值等于 0\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1]\n输出：0\n解释：对于每个符合范围 1 <= i <= 1 的下标 i :\n- nums[1] 的美丽值等于 0\n```\n\n**提示：**\n\n-   `3 <= nums.length <= 105`\n-   `1 <= nums[i] <= 105`\n\n**我的提交：**\n\n>   预处理前后最值\n\n```c++\nclass Solution\n{\npublic:\n    int sumOfBeauties(Veci &nums)\n    {\n        auto len = nums.size();\n        Veci leftmax(len, INT_MIN), rightmin(len, INT_MAX);\n        leftmax[1] = nums[0], rightmin[len - 2] = nums[len - 1];\n        FORINC(i, 2, len)\n        {\n            leftmax[i] = std::max(leftmax[i - 1], nums[i - 1]);\n            rightmin[len - i - 1] = std::min(rightmin[len - i], nums[len - i]);\n        }\n        auto ans = 0;\n        FORINC(i, 1, len - 1)\n        {\n            if (leftmax[i] < nums[i] && nums[i] < rightmin[i])\n                ans += 2;\n            else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1])\n                ans += 1;\n            else\n                continue;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T3 5877. 检测正方形\n\n-   **通过的用户数**952\n-   **尝试过的用户数**1535\n-   **用户总通过次数**988\n-   **用户总提交次数**4100\n-   **题目难度** **Medium**\n\n给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：\n\n-   **添加** 一个在数据流中的新点到某个数据结构中**。**可以添加 **重复** 的点，并会视作不同的点进行处理。\n-   给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 **面积为正** 的 **轴对齐正方形** ，**统计** 满足该要求的方案数目**。**\n\n**轴对齐正方形** 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。\n\n实现 `DetectSquares` 类：\n\n-   `DetectSquares()` 使用空数据结构初始化对象\n-   `void add(int[] point)` 向数据结构添加一个新的点 `point = [x, y]`\n-   `int count(int[] point)` 统计按上述方式与点 `point = [x, y]` 共同构造 **轴对齐正方形** 的方案数。\n\n**示例：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/01/image.png)\n\n```\n输入：\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n输出：\n[null, null, null, null, 1, 0, null, 2]\n\n解释：\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // 返回 1 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\ndetectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。\ndetectSquares.add([11, 2]);    // 允许添加重复的点。\ndetectSquares.count([11, 10]); // 返回 2 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\n                               //   - 第一个，第三个，和第四个点\n```\n\n**提示：**\n\n-   `point.length == 2`\n-   `0 <= x, y <= 1000`\n-   调用 `add` 和 `count` 的 **总次数** 最多为 `5000`\n\n**题解：**\n\n定位正方形时可通过枚举对角线进行，确定能否构成正方形只需要一个点。因为只有 `1000` 个点，所以可以直接开一个静态数组。\n\n>   周赛的时候写了一堆 `std::map` ，没想到静态数组和一点定正方形，跑去算了半天对角线长度，欢声笑语中打出 GG\n\n```c++\nclass DetectSquares\n{\npublic:\n    DetectSquares()\n    {\n        std::ios::sync_with_stdio(false);\n        memset(points, 0, sizeof(int) * 1001 * 1001);\n    }\n    void add(std::vector<int> point)\n    {\n        points[point[0]][point[1]] += 1;\n    }\n    int count(std::vector<int> point)\n    {\n        int x = point[0], y = point[1], ans = 0;\n        for (int ny = 0; ny < 1001; ++ny)\n        {\n            if (points[x][ny] == 0 || ny == y)\n                continue;\n            auto d = ny - y;\n            if ( x + d >= 0 && x + d < 1001)\n            {\n                ans += points[x + d][y] * points[x + d][ny] * points[x][ny];\n            }\n            if ( x - d >= 0 && x - d < 1001)\n            {\n                ans += points[x - d][y] * points[x - d][ny] * points[x][ny];\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    int points[1001][1001];\n};\n```\n\n\n\n## T4 5878. 重复 K 次的最长子序列\n\n-   **通过的用户数**111\n-   **尝试过的用户数**186\n-   **用户总通过次数**149\n-   **用户总提交次数**567\n-   **题目难度** **Hard**\n\n给你一个长度为 `n` 的字符串 `s` ，和一个整数 `k` 。请你找出字符串 `s` 中 **重复** `k` 次的 **最长子序列** 。\n\n**子序列** 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。\n\n如果 `seq * k` 是 `s` 的一个子序列，其中 `seq * k` 表示一个由 `seq` 串联 `k` 次构造的字符串，那么就称 `seq` 是字符串 `s` 中一个 **重复 `k` 次** 的子序列。\n\n-   举个例子，`\"bba\"` 是字符串 `\"bababcba\"` 中的一个重复 `2` 次的子序列，因为字符串 `\"bbabba\"` 是由 `\"bba\"` 串联 `2` 次构造的，而 `\"bbabba\"` 是字符串 `\"bababcba\"` 的一个子序列。\n\n返回字符串 `s` 中 **重复 k 次的最长子序列** 。如果存在多个满足的子序列，则返回 **字典序最大** 的那个。如果不存在这样的子序列，返回一个 **空** 字符串。\n\n**示例 1：**\n\n![example 1](https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png)\n\n```\n输入：s = \"letsleetcode\", k = 2\n输出：\"let\"\n解释：存在两个最长子序列重复 2 次：let\" 和 \"ete\" 。\n\"let\" 是其中字典序最大的一个。\n```\n\n**示例 2：**\n\n```\n输入：s = \"bb\", k = 2\n输出：\"b\"\n解释：重复 2 次的最长子序列是 \"b\" 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"ab\", k = 2\n输出：\"\"\n解释：不存在重复 2 次的最长子序列。返回空字符串。\n```\n\n**示例 4：**\n\n```\n输入：s = \"bbabbabbbbabaababab\", k = 3\n输出：\"bbbb\"\n解释：在 \"bbabbabbbbabaababab\" 中重复 3 次的最长子序列是 \"bbbb\" 。\n```\n\n**提示：**\n\n-   `n == s.length`\n-   `2 <= k <= 2000`\n-   `2 <= n < k * 8`\n-   `s` 由小写英文字母组成\n\n**题解：**\n\n题目所给数据实际上隐含了一条信息：子序列长度不会超过 8，所以对长度为 1 到 7 的全部子序列依次验证即可。\n\n>   纯暴力，C++ 似乎也可以通过全排列函数求解\n\n```c++\nbool check(string &a, string &b, int k){//检测b能否在a中出现k次\n    int cnt = 0;\n    for(int i = 0, j = 0; i < a.size(); i++){\n        if(a[i]==b[j]){\n            j++;\n            if(j==b.size()){\n                j = 0, cnt++;\n                if(cnt==k) return true; \n            }\n        }\n    }\n    return false;\n}\nstring longestSubsequenceRepeatedK(string s, int k) {\n    //易知：子序列长度最多为7 故而可以暴力找出长度为7以内的序列作为要找的子序列 依次验证即可\n    \n    //若对于长度为len的符合条件的子序列 则它一定是由长度为len-1的序列通过添加一个字母生成的\n    //故而递推生成所有可能的子序列即可 然后验证是否符合条件 加入答案数组 最后返回最大的即可\n    vector<string> ans[8];//ans[i]表示长度为i的符合条件的字符串\n    ans[0].push_back(\"\");\n    int i = 1;\n    for( ; i < 8; i++){\n        for(auto v : ans[i-1]){\n            for(char j = 'a'; j <= 'z'; j++){\n                string t = v + j;\n                if(check(s,t,k)) ans[i].push_back(t);\n            }\n        }\n        if(ans[i].empty()) break;\n    }\n    i--;\n    sort(ans[i].begin(),ans[i].end());\n    return ans[i].back();\n}\n\n作者：zeroac\n链接：https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/c-bao-li-mei-ju-chang-du-7yi-nei-xu-lie-febao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","source":"_posts/weekly-contest-259.md","raw":"---\ntitle: LeetCode 周赛 259\ndate: 2021-09-19 14:55:49\ntags: LeetCode 周赛总结\n---\n\n---\n\n# LeetCode 周赛 259\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-259/problems/final-value-of-variable-after-performing-operations/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-259/problems/sum-of-beauty-in-the-array/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-259/problems/detect-squares/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-259/problems/longest-subsequence-repeated-k-times/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1091 / 3774 | MiracleSNeko | 7    | 0:15:15  | 0:01:25                                                      | 0:15:15                                                      |                                                              |                                                              |\n\n\n\n## T1 5875. 执行操作后的变量值\n\n-   **通过的用户数**2937\n-   **尝试过的用户数**2956\n-   **用户总通过次数**2960\n-   **用户总提交次数**3107\n-   **题目难度** **Easy**\n\n存在一种仅支持 4 种操作和 1 个变量 `X` 的编程语言：\n\n-   `++X` 和 `X++` 使变量 `X` 的值 **加** `1`\n-   `--X` 和 `X--` 使变量 `X` 的值 **减** `1`\n\n最初，`X` 的值是 `0`\n\n给你一个字符串数组 `operations` ，这是由操作组成的一个列表，返回执行所有操作后， `X` 的 **最终值** 。\n\n**示例 1：**\n\n```\n输入：operations = [\"--X\",\"X++\",\"X++\"]\n输出：1\n解释：操作按下述步骤执行：\n最初，X = 0\n--X：X 减 1 ，X =  0 - 1 = -1\nX++：X 加 1 ，X = -1 + 1 =  0\nX++：X 加 1 ，X =  0 + 1 =  1\n```\n\n**示例 2：**\n\n```\n输入：operations = [\"++X\",\"++X\",\"X++\"]\n输出：3\n解释：操作按下述步骤执行： \n最初，X = 0\n++X：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\nX++：X 加 1 ，X = 2 + 1 = 3\n```\n\n**示例 3：**\n\n```\n输入：operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\n输出：0\n解释：操作按下述步骤执行：\n最初，X = 0\nX++：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\n--X：X 减 1 ，X = 2 - 1 = 1\nX--：X 减 1 ，X = 1 - 1 = 0\n```\n\n**提示：**\n\n-   `1 <= operations.length <= 100`\n-   `operations[i]` 将会是 `\"++X\"`、`\"X++\"`、`\"--X\"` 或 `\"X--\"`\n\n**我的提交：**\n\n```c++\nclass Solution\n{\npublic:\n    int finalValueAfterOperations(Vec<str> &operations)\n    {\n        auto ans = 0;\n        for(auto op: operations)\n        {\n            if (op == \"++X\" || op == \"X++\") ans++;\n            else ans--;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T2 5876. 数组美丽值求和\n\n-   **通过的用户数**2050\n-   **尝试过的用户数**2749\n-   **用户总通过次数**2088\n-   **用户总提交次数**6951\n-   **题目难度** **Medium**\n\n给你一个下标从 **0** 开始的整数数组 `nums` 。对于每个下标 `i`（`1 <= i <= nums.length - 2`），`nums[i]` 的 **美丽值** 等于：\n\n-   `2`，对于所有 `0 <= j < i` 且 `i < k <= nums.length - 1` ，满足 `nums[j] < nums[i] < nums[k]`\n-   `1`，如果满足 `nums[i - 1] < nums[i] < nums[i + 1]` ，且不满足前面的条件\n-   `0`，如果上述条件全部不满足\n\n返回符合 `1 <= i <= nums.length - 2` 的所有 `nums[i]` 的 **美丽值的总和** 。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：2\n解释：对于每个符合范围 1 <= i <= 1 的下标 i :\n- nums[1] 的美丽值等于 2\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,4,6,4]\n输出：1\n解释：对于每个符合范围 1 <= i <= 2 的下标 i :\n- nums[1] 的美丽值等于 1\n- nums[2] 的美丽值等于 0\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1]\n输出：0\n解释：对于每个符合范围 1 <= i <= 1 的下标 i :\n- nums[1] 的美丽值等于 0\n```\n\n**提示：**\n\n-   `3 <= nums.length <= 105`\n-   `1 <= nums[i] <= 105`\n\n**我的提交：**\n\n>   预处理前后最值\n\n```c++\nclass Solution\n{\npublic:\n    int sumOfBeauties(Veci &nums)\n    {\n        auto len = nums.size();\n        Veci leftmax(len, INT_MIN), rightmin(len, INT_MAX);\n        leftmax[1] = nums[0], rightmin[len - 2] = nums[len - 1];\n        FORINC(i, 2, len)\n        {\n            leftmax[i] = std::max(leftmax[i - 1], nums[i - 1]);\n            rightmin[len - i - 1] = std::min(rightmin[len - i], nums[len - i]);\n        }\n        auto ans = 0;\n        FORINC(i, 1, len - 1)\n        {\n            if (leftmax[i] < nums[i] && nums[i] < rightmin[i])\n                ans += 2;\n            else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1])\n                ans += 1;\n            else\n                continue;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## T3 5877. 检测正方形\n\n-   **通过的用户数**952\n-   **尝试过的用户数**1535\n-   **用户总通过次数**988\n-   **用户总提交次数**4100\n-   **题目难度** **Medium**\n\n给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：\n\n-   **添加** 一个在数据流中的新点到某个数据结构中**。**可以添加 **重复** 的点，并会视作不同的点进行处理。\n-   给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 **面积为正** 的 **轴对齐正方形** ，**统计** 满足该要求的方案数目**。**\n\n**轴对齐正方形** 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。\n\n实现 `DetectSquares` 类：\n\n-   `DetectSquares()` 使用空数据结构初始化对象\n-   `void add(int[] point)` 向数据结构添加一个新的点 `point = [x, y]`\n-   `int count(int[] point)` 统计按上述方式与点 `point = [x, y]` 共同构造 **轴对齐正方形** 的方案数。\n\n**示例：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/01/image.png)\n\n```\n输入：\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n输出：\n[null, null, null, null, 1, 0, null, 2]\n\n解释：\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // 返回 1 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\ndetectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。\ndetectSquares.add([11, 2]);    // 允许添加重复的点。\ndetectSquares.count([11, 10]); // 返回 2 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\n                               //   - 第一个，第三个，和第四个点\n```\n\n**提示：**\n\n-   `point.length == 2`\n-   `0 <= x, y <= 1000`\n-   调用 `add` 和 `count` 的 **总次数** 最多为 `5000`\n\n**题解：**\n\n定位正方形时可通过枚举对角线进行，确定能否构成正方形只需要一个点。因为只有 `1000` 个点，所以可以直接开一个静态数组。\n\n>   周赛的时候写了一堆 `std::map` ，没想到静态数组和一点定正方形，跑去算了半天对角线长度，欢声笑语中打出 GG\n\n```c++\nclass DetectSquares\n{\npublic:\n    DetectSquares()\n    {\n        std::ios::sync_with_stdio(false);\n        memset(points, 0, sizeof(int) * 1001 * 1001);\n    }\n    void add(std::vector<int> point)\n    {\n        points[point[0]][point[1]] += 1;\n    }\n    int count(std::vector<int> point)\n    {\n        int x = point[0], y = point[1], ans = 0;\n        for (int ny = 0; ny < 1001; ++ny)\n        {\n            if (points[x][ny] == 0 || ny == y)\n                continue;\n            auto d = ny - y;\n            if ( x + d >= 0 && x + d < 1001)\n            {\n                ans += points[x + d][y] * points[x + d][ny] * points[x][ny];\n            }\n            if ( x - d >= 0 && x - d < 1001)\n            {\n                ans += points[x - d][y] * points[x - d][ny] * points[x][ny];\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    int points[1001][1001];\n};\n```\n\n\n\n## T4 5878. 重复 K 次的最长子序列\n\n-   **通过的用户数**111\n-   **尝试过的用户数**186\n-   **用户总通过次数**149\n-   **用户总提交次数**567\n-   **题目难度** **Hard**\n\n给你一个长度为 `n` 的字符串 `s` ，和一个整数 `k` 。请你找出字符串 `s` 中 **重复** `k` 次的 **最长子序列** 。\n\n**子序列** 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。\n\n如果 `seq * k` 是 `s` 的一个子序列，其中 `seq * k` 表示一个由 `seq` 串联 `k` 次构造的字符串，那么就称 `seq` 是字符串 `s` 中一个 **重复 `k` 次** 的子序列。\n\n-   举个例子，`\"bba\"` 是字符串 `\"bababcba\"` 中的一个重复 `2` 次的子序列，因为字符串 `\"bbabba\"` 是由 `\"bba\"` 串联 `2` 次构造的，而 `\"bbabba\"` 是字符串 `\"bababcba\"` 的一个子序列。\n\n返回字符串 `s` 中 **重复 k 次的最长子序列** 。如果存在多个满足的子序列，则返回 **字典序最大** 的那个。如果不存在这样的子序列，返回一个 **空** 字符串。\n\n**示例 1：**\n\n![example 1](https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png)\n\n```\n输入：s = \"letsleetcode\", k = 2\n输出：\"let\"\n解释：存在两个最长子序列重复 2 次：let\" 和 \"ete\" 。\n\"let\" 是其中字典序最大的一个。\n```\n\n**示例 2：**\n\n```\n输入：s = \"bb\", k = 2\n输出：\"b\"\n解释：重复 2 次的最长子序列是 \"b\" 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"ab\", k = 2\n输出：\"\"\n解释：不存在重复 2 次的最长子序列。返回空字符串。\n```\n\n**示例 4：**\n\n```\n输入：s = \"bbabbabbbbabaababab\", k = 3\n输出：\"bbbb\"\n解释：在 \"bbabbabbbbabaababab\" 中重复 3 次的最长子序列是 \"bbbb\" 。\n```\n\n**提示：**\n\n-   `n == s.length`\n-   `2 <= k <= 2000`\n-   `2 <= n < k * 8`\n-   `s` 由小写英文字母组成\n\n**题解：**\n\n题目所给数据实际上隐含了一条信息：子序列长度不会超过 8，所以对长度为 1 到 7 的全部子序列依次验证即可。\n\n>   纯暴力，C++ 似乎也可以通过全排列函数求解\n\n```c++\nbool check(string &a, string &b, int k){//检测b能否在a中出现k次\n    int cnt = 0;\n    for(int i = 0, j = 0; i < a.size(); i++){\n        if(a[i]==b[j]){\n            j++;\n            if(j==b.size()){\n                j = 0, cnt++;\n                if(cnt==k) return true; \n            }\n        }\n    }\n    return false;\n}\nstring longestSubsequenceRepeatedK(string s, int k) {\n    //易知：子序列长度最多为7 故而可以暴力找出长度为7以内的序列作为要找的子序列 依次验证即可\n    \n    //若对于长度为len的符合条件的子序列 则它一定是由长度为len-1的序列通过添加一个字母生成的\n    //故而递推生成所有可能的子序列即可 然后验证是否符合条件 加入答案数组 最后返回最大的即可\n    vector<string> ans[8];//ans[i]表示长度为i的符合条件的字符串\n    ans[0].push_back(\"\");\n    int i = 1;\n    for( ; i < 8; i++){\n        for(auto v : ans[i-1]){\n            for(char j = 'a'; j <= 'z'; j++){\n                string t = v + j;\n                if(check(s,t,k)) ans[i].push_back(t);\n            }\n        }\n        if(ans[i].empty()) break;\n    }\n    i--;\n    sort(ans[i].begin(),ans[i].end());\n    return ans[i].back();\n}\n\n作者：zeroac\n链接：https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/c-bao-li-mei-ju-chang-du-7yi-nei-xu-lie-febao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","slug":"weekly-contest-259","published":1,"updated":"2021-11-17T05:21:51.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8px00091cy53hul3uy4","content":"<hr>\n<h1 id=\"LeetCode-周赛-259\"><a href=\"#LeetCode-周赛-259\" class=\"headerlink\" title=\"LeetCode 周赛 259\"></a>LeetCode 周赛 259</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/final-value-of-variable-after-performing-operations/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/sum-of-beauty-in-the-array/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/detect-squares/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/longest-subsequence-repeated-k-times/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1091 / 3774</td>\n<td>MiracleSNeko</td>\n<td>7</td>\n<td>0:15:15</td>\n<td>0:01:25</td>\n<td>0:15:15</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5875-执行操作后的变量值\"><a href=\"#T1-5875-执行操作后的变量值\" class=\"headerlink\" title=\"T1 5875. 执行操作后的变量值\"></a>T1 5875. 执行操作后的变量值</h2><ul>\n<li>  <strong>通过的用户数</strong>2937</li>\n<li>  <strong>尝试过的用户数</strong>2956</li>\n<li>  <strong>用户总通过次数</strong>2960</li>\n<li>  <strong>用户总提交次数</strong>3107</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>存在一种仅支持 4 种操作和 1 个变量 <code>X</code> 的编程语言：</p>\n<ul>\n<li>  <code>++X</code> 和 <code>X++</code> 使变量 <code>X</code> 的值 <strong>加</strong> <code>1</code></li>\n<li>  <code>--X</code> 和 <code>X--</code> 使变量 <code>X</code> 的值 <strong>减</strong> <code>1</code></li>\n</ul>\n<p>最初，<code>X</code> 的值是 <code>0</code></p>\n<p>给你一个字符串数组 <code>operations</code> ，这是由操作组成的一个列表，返回执行所有操作后， <code>X</code> 的 <strong>最终值</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;--X&quot;,&quot;X++&quot;,&quot;X++&quot;]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：操作按下述步骤执行：</span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">--X：X 减 1 ，X =  0 - 1 = -1</span><br><span class=\"line\">X++：X 加 1 ，X = -1 + 1 =  0</span><br><span class=\"line\">X++：X 加 1 ，X =  0 + 1 =  1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;++X&quot;,&quot;++X&quot;,&quot;X++&quot;]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：操作按下述步骤执行： </span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">++X：X 加 1 ，X = 0 + 1 = 1</span><br><span class=\"line\">++X：X 加 1 ，X = 1 + 1 = 2</span><br><span class=\"line\">X++：X 加 1 ，X = 2 + 1 = 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;X++&quot;,&quot;++X&quot;,&quot;--X&quot;,&quot;X--&quot;]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：操作按下述步骤执行：</span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">X++：X 加 1 ，X = 0 + 1 = 1</span><br><span class=\"line\">++X：X 加 1 ，X = 1 + 1 = 2</span><br><span class=\"line\">--X：X 减 1 ，X = 2 - 1 = 1</span><br><span class=\"line\">X--：X 减 1 ，X = 1 - 1 = 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= operations.length &lt;= 100</code></li>\n<li>  <code>operations[i]</code> 将会是 <code>&quot;++X&quot;</code>、<code>&quot;X++&quot;</code>、<code>&quot;--X&quot;</code> 或 <code>&quot;X--&quot;</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">finalValueAfterOperations</span><span class=\"params\">(Vec&lt;str&gt; &amp;operations)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op: operations)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (op == <span class=\"string\">&quot;++X&quot;</span> || op == <span class=\"string\">&quot;X++&quot;</span>) ans++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ans--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5876-数组美丽值求和\"><a href=\"#T2-5876-数组美丽值求和\" class=\"headerlink\" title=\"T2 5876. 数组美丽值求和\"></a>T2 5876. 数组美丽值求和</h2><ul>\n<li>  <strong>通过的用户数</strong>2050</li>\n<li>  <strong>尝试过的用户数</strong>2749</li>\n<li>  <strong>用户总通过次数</strong>2088</li>\n<li>  <strong>用户总提交次数</strong>6951</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。对于每个下标 <code>i</code>（<code>1 &lt;= i &lt;= nums.length - 2</code>），<code>nums[i]</code> 的 <strong>美丽值</strong> 等于：</p>\n<ul>\n<li>  <code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code> ，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li>\n<li>  <code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code> ，且不满足前面的条件</li>\n<li>  <code>0</code>，如果上述条件全部不满足</li>\n</ul>\n<p>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有 <code>nums[i]</code> 的 <strong>美丽值的总和</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,4,6,4]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 2 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 1</span><br><span class=\"line\">- nums[2] 的美丽值等于 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>3 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  预处理前后最值</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfBeauties</span><span class=\"params\">(Veci &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">Veci <span class=\"title\">leftmax</span><span class=\"params\">(len, INT_MIN)</span>, <span class=\"title\">rightmin</span><span class=\"params\">(len, INT_MAX)</span></span>;</span><br><span class=\"line\">        leftmax[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>], rightmin[len - <span class=\"number\">2</span>] = nums[len - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(i, <span class=\"number\">2</span>, len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            leftmax[i] = std::<span class=\"built_in\">max</span>(leftmax[i - <span class=\"number\">1</span>], nums[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            rightmin[len - i - <span class=\"number\">1</span>] = std::<span class=\"built_in\">min</span>(rightmin[len - i], nums[len - i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(i, <span class=\"number\">1</span>, len - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftmax[i] &lt; nums[i] &amp;&amp; nums[i] &lt; rightmin[i])</span><br><span class=\"line\">                ans += <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] &lt; nums[i] &amp;&amp; nums[i] &lt; nums[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">                ans += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-5877-检测正方形\"><a href=\"#T3-5877-检测正方形\" class=\"headerlink\" title=\"T3 5877. 检测正方形\"></a>T3 5877. 检测正方形</h2><ul>\n<li>  <strong>通过的用户数</strong>952</li>\n<li>  <strong>尝试过的用户数</strong>1535</li>\n<li>  <strong>用户总通过次数</strong>988</li>\n<li>  <strong>用户总提交次数</strong>4100</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：</p>\n<ul>\n<li>  <strong>添加</strong> 一个在数据流中的新点到某个数据结构中<strong>。</strong>可以添加 <strong>重复</strong> 的点，并会视作不同的点进行处理。</li>\n<li>  给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 <strong>面积为正</strong> 的 <strong>轴对齐正方形</strong> ，<strong>统计</strong> 满足该要求的方案数目<strong>。</strong></li>\n</ul>\n<p><strong>轴对齐正方形</strong> 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</p>\n<p>实现 <code>DetectSquares</code> 类：</p>\n<ul>\n<li>  <code>DetectSquares()</code> 使用空数据结构初始化对象</li>\n<li>  <code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]</code></li>\n<li>  <code>int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 <strong>轴对齐正方形</strong> 的方案数。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/01/image.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;DetectSquares&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]</span><br><span class=\"line\">[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, null, 1, 0, null, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">DetectSquares detectSquares = new DetectSquares();</span><br><span class=\"line\">detectSquares.add([3, 10]);</span><br><span class=\"line\">detectSquares.add([11, 2]);</span><br><span class=\"line\">detectSquares.add([3, 2]);</span><br><span class=\"line\">detectSquares.count([11, 10]); // 返回 1 。你可以选择：</span><br><span class=\"line\">                               //   - 第一个，第二个，和第三个点</span><br><span class=\"line\">detectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。</span><br><span class=\"line\">detectSquares.add([11, 2]);    // 允许添加重复的点。</span><br><span class=\"line\">detectSquares.count([11, 10]); // 返回 2 。你可以选择：</span><br><span class=\"line\">                               //   - 第一个，第二个，和第三个点</span><br><span class=\"line\">                               //   - 第一个，第三个，和第四个点</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>point.length == 2</code></li>\n<li>  <code>0 &lt;= x, y &lt;= 1000</code></li>\n<li>  调用 <code>add</code> 和 <code>count</code> 的 <strong>总次数</strong> 最多为 <code>5000</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>定位正方形时可通过枚举对角线进行，确定能否构成正方形只需要一个点。因为只有 <code>1000</code> 个点，所以可以直接开一个静态数组。</p>\n<blockquote>\n<p>  周赛的时候写了一堆 <code>std::map</code> ，没想到静态数组和一点定正方形，跑去算了半天对角线长度，欢声笑语中打出 GG</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DetectSquares</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">DetectSquares</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(points, <span class=\"number\">0</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>) * <span class=\"number\">1001</span> * <span class=\"number\">1001</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; point)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        points[point[<span class=\"number\">0</span>]][point[<span class=\"number\">1</span>]] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; point)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = point[<span class=\"number\">0</span>], y = point[<span class=\"number\">1</span>], ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> ny = <span class=\"number\">0</span>; ny &lt; <span class=\"number\">1001</span>; ++ny)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (points[x][ny] == <span class=\"number\">0</span> || ny == y)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> d = ny - y;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( x + d &gt;= <span class=\"number\">0</span> &amp;&amp; x + d &lt; <span class=\"number\">1001</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += points[x + d][y] * points[x + d][ny] * points[x][ny];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( x - d &gt;= <span class=\"number\">0</span> &amp;&amp; x - d &lt; <span class=\"number\">1001</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += points[x - d][y] * points[x - d][ny] * points[x][ny];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> points[<span class=\"number\">1001</span>][<span class=\"number\">1001</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5878-重复-K-次的最长子序列\"><a href=\"#T4-5878-重复-K-次的最长子序列\" class=\"headerlink\" title=\"T4 5878. 重复 K 次的最长子序列\"></a>T4 5878. 重复 K 次的最长子序列</h2><ul>\n<li>  <strong>通过的用户数</strong>111</li>\n<li>  <strong>尝试过的用户数</strong>186</li>\n<li>  <strong>用户总通过次数</strong>149</li>\n<li>  <strong>用户总提交次数</strong>567</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个长度为 <code>n</code> 的字符串 <code>s</code> ，和一个整数 <code>k</code> 。请你找出字符串 <code>s</code> 中 <strong>重复</strong> <code>k</code> 次的 <strong>最长子序列</strong> 。</p>\n<p><strong>子序列</strong> 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p>\n<p>如果 <code>seq * k</code> 是 <code>s</code> 的一个子序列，其中 <code>seq * k</code> 表示一个由 <code>seq</code> 串联 <code>k</code> 次构造的字符串，那么就称 <code>seq</code> 是字符串 <code>s</code> 中一个 <strong>重复 <code>k</code> 次</strong> 的子序列。</p>\n<ul>\n<li>  举个例子，<code>&quot;bba&quot;</code> 是字符串 <code>&quot;bababcba&quot;</code> 中的一个重复 <code>2</code> 次的子序列，因为字符串 <code>&quot;bbabba&quot;</code> 是由 <code>&quot;bba&quot;</code> 串联 <code>2</code> 次构造的，而 <code>&quot;bbabba&quot;</code> 是字符串 <code>&quot;bababcba&quot;</code> 的一个子序列。</li>\n</ul>\n<p>返回字符串 <code>s</code> 中 <strong>重复 k 次的最长子序列</strong> 。如果存在多个满足的子序列，则返回 <strong>字典序最大</strong> 的那个。如果不存在这样的子序列，返回一个 <strong>空</strong> 字符串。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png\" alt=\"example 1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;letsleetcode&quot;, k = 2</span><br><span class=\"line\">输出：&quot;let&quot;</span><br><span class=\"line\">解释：存在两个最长子序列重复 2 次：let&quot; 和 &quot;ete&quot; 。</span><br><span class=\"line\">&quot;let&quot; 是其中字典序最大的一个。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bb&quot;, k = 2</span><br><span class=\"line\">输出：&quot;b&quot;</span><br><span class=\"line\">解释：重复 2 次的最长子序列是 &quot;b&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ab&quot;, k = 2</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：不存在重复 2 次的最长子序列。返回空字符串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bbabbabbbbabaababab&quot;, k = 3</span><br><span class=\"line\">输出：&quot;bbbb&quot;</span><br><span class=\"line\">解释：在 &quot;bbabbabbbbabaababab&quot; 中重复 3 次的最长子序列是 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == s.length</code></li>\n<li>  <code>2 &lt;= k &lt;= 2000</code></li>\n<li>  <code>2 &lt;= n &lt; k * 8</code></li>\n<li>  <code>s</code> 由小写英文字母组成</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>题目所给数据实际上隐含了一条信息：子序列长度不会超过 8，所以对长度为 1 到 7 的全部子序列依次验证即可。</p>\n<blockquote>\n<p>  纯暴力，C++ 似乎也可以通过全排列函数求解</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(string &amp;a, string &amp;b, <span class=\"keyword\">int</span> k)</span></span>&#123;<span class=\"comment\">//检测b能否在a中出现k次</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; a.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]==b[j])&#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j==b.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>, cnt++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cnt==k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">longestSubsequenceRepeatedK</span><span class=\"params\">(string s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//易知：子序列长度最多为7 故而可以暴力找出长度为7以内的序列作为要找的子序列 依次验证即可</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//若对于长度为len的符合条件的子序列 则它一定是由长度为len-1的序列通过添加一个字母生成的</span></span><br><span class=\"line\">    <span class=\"comment\">//故而递推生成所有可能的子序列即可 然后验证是否符合条件 加入答案数组 最后返回最大的即可</span></span><br><span class=\"line\">    vector&lt;string&gt; ans[<span class=\"number\">8</span>];<span class=\"comment\">//ans[i]表示长度为i的符合条件的字符串</span></span><br><span class=\"line\">    ans[<span class=\"number\">0</span>].<span class=\"built_in\">push_back</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; i &lt; <span class=\"number\">8</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> v : ans[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> j = <span class=\"string\">&#x27;a&#x27;</span>; j &lt;= <span class=\"string\">&#x27;z&#x27;</span>; j++)&#123;</span><br><span class=\"line\">                string t = v + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(s,t,k)) ans[i].<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans[i].<span class=\"built_in\">empty</span>()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(ans[i].<span class=\"built_in\">begin</span>(),ans[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[i].<span class=\"built_in\">back</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：zeroac</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/c-bao-li-mei-ju-chang-du-7yi-nei-xu-lie-febao/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-259\"><a href=\"#LeetCode-周赛-259\" class=\"headerlink\" title=\"LeetCode 周赛 259\"></a>LeetCode 周赛 259</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/final-value-of-variable-after-performing-operations/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/sum-of-beauty-in-the-array/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/detect-squares/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-259/problems/longest-subsequence-repeated-k-times/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1091 / 3774</td>\n<td>MiracleSNeko</td>\n<td>7</td>\n<td>0:15:15</td>\n<td>0:01:25</td>\n<td>0:15:15</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5875-执行操作后的变量值\"><a href=\"#T1-5875-执行操作后的变量值\" class=\"headerlink\" title=\"T1 5875. 执行操作后的变量值\"></a>T1 5875. 执行操作后的变量值</h2><ul>\n<li>  <strong>通过的用户数</strong>2937</li>\n<li>  <strong>尝试过的用户数</strong>2956</li>\n<li>  <strong>用户总通过次数</strong>2960</li>\n<li>  <strong>用户总提交次数</strong>3107</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>存在一种仅支持 4 种操作和 1 个变量 <code>X</code> 的编程语言：</p>\n<ul>\n<li>  <code>++X</code> 和 <code>X++</code> 使变量 <code>X</code> 的值 <strong>加</strong> <code>1</code></li>\n<li>  <code>--X</code> 和 <code>X--</code> 使变量 <code>X</code> 的值 <strong>减</strong> <code>1</code></li>\n</ul>\n<p>最初，<code>X</code> 的值是 <code>0</code></p>\n<p>给你一个字符串数组 <code>operations</code> ，这是由操作组成的一个列表，返回执行所有操作后， <code>X</code> 的 <strong>最终值</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;--X&quot;,&quot;X++&quot;,&quot;X++&quot;]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：操作按下述步骤执行：</span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">--X：X 减 1 ，X =  0 - 1 = -1</span><br><span class=\"line\">X++：X 加 1 ，X = -1 + 1 =  0</span><br><span class=\"line\">X++：X 加 1 ，X =  0 + 1 =  1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;++X&quot;,&quot;++X&quot;,&quot;X++&quot;]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：操作按下述步骤执行： </span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">++X：X 加 1 ，X = 0 + 1 = 1</span><br><span class=\"line\">++X：X 加 1 ，X = 1 + 1 = 2</span><br><span class=\"line\">X++：X 加 1 ，X = 2 + 1 = 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：operations = [&quot;X++&quot;,&quot;++X&quot;,&quot;--X&quot;,&quot;X--&quot;]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：操作按下述步骤执行：</span><br><span class=\"line\">最初，X = 0</span><br><span class=\"line\">X++：X 加 1 ，X = 0 + 1 = 1</span><br><span class=\"line\">++X：X 加 1 ，X = 1 + 1 = 2</span><br><span class=\"line\">--X：X 减 1 ，X = 2 - 1 = 1</span><br><span class=\"line\">X--：X 减 1 ，X = 1 - 1 = 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= operations.length &lt;= 100</code></li>\n<li>  <code>operations[i]</code> 将会是 <code>&quot;++X&quot;</code>、<code>&quot;X++&quot;</code>、<code>&quot;--X&quot;</code> 或 <code>&quot;X--&quot;</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">finalValueAfterOperations</span><span class=\"params\">(Vec&lt;str&gt; &amp;operations)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op: operations)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (op == <span class=\"string\">&quot;++X&quot;</span> || op == <span class=\"string\">&quot;X++&quot;</span>) ans++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ans--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5876-数组美丽值求和\"><a href=\"#T2-5876-数组美丽值求和\" class=\"headerlink\" title=\"T2 5876. 数组美丽值求和\"></a>T2 5876. 数组美丽值求和</h2><ul>\n<li>  <strong>通过的用户数</strong>2050</li>\n<li>  <strong>尝试过的用户数</strong>2749</li>\n<li>  <strong>用户总通过次数</strong>2088</li>\n<li>  <strong>用户总提交次数</strong>6951</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。对于每个下标 <code>i</code>（<code>1 &lt;= i &lt;= nums.length - 2</code>），<code>nums[i]</code> 的 <strong>美丽值</strong> 等于：</p>\n<ul>\n<li>  <code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code> ，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li>\n<li>  <code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code> ，且不满足前面的条件</li>\n<li>  <code>0</code>，如果上述条件全部不满足</li>\n</ul>\n<p>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有 <code>nums[i]</code> 的 <strong>美丽值的总和</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,4,6,4]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 2 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 1</span><br><span class=\"line\">- nums[2] 的美丽值等于 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :</span><br><span class=\"line\">- nums[1] 的美丽值等于 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>3 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  预处理前后最值</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfBeauties</span><span class=\"params\">(Veci &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">Veci <span class=\"title\">leftmax</span><span class=\"params\">(len, INT_MIN)</span>, <span class=\"title\">rightmin</span><span class=\"params\">(len, INT_MAX)</span></span>;</span><br><span class=\"line\">        leftmax[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>], rightmin[len - <span class=\"number\">2</span>] = nums[len - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(i, <span class=\"number\">2</span>, len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            leftmax[i] = std::<span class=\"built_in\">max</span>(leftmax[i - <span class=\"number\">1</span>], nums[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            rightmin[len - i - <span class=\"number\">1</span>] = std::<span class=\"built_in\">min</span>(rightmin[len - i], nums[len - i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">FORINC</span>(i, <span class=\"number\">1</span>, len - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftmax[i] &lt; nums[i] &amp;&amp; nums[i] &lt; rightmin[i])</span><br><span class=\"line\">                ans += <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] &lt; nums[i] &amp;&amp; nums[i] &lt; nums[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">                ans += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-5877-检测正方形\"><a href=\"#T3-5877-检测正方形\" class=\"headerlink\" title=\"T3 5877. 检测正方形\"></a>T3 5877. 检测正方形</h2><ul>\n<li>  <strong>通过的用户数</strong>952</li>\n<li>  <strong>尝试过的用户数</strong>1535</li>\n<li>  <strong>用户总通过次数</strong>988</li>\n<li>  <strong>用户总提交次数</strong>4100</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：</p>\n<ul>\n<li>  <strong>添加</strong> 一个在数据流中的新点到某个数据结构中<strong>。</strong>可以添加 <strong>重复</strong> 的点，并会视作不同的点进行处理。</li>\n<li>  给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 <strong>面积为正</strong> 的 <strong>轴对齐正方形</strong> ，<strong>统计</strong> 满足该要求的方案数目<strong>。</strong></li>\n</ul>\n<p><strong>轴对齐正方形</strong> 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</p>\n<p>实现 <code>DetectSquares</code> 类：</p>\n<ul>\n<li>  <code>DetectSquares()</code> 使用空数据结构初始化对象</li>\n<li>  <code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]</code></li>\n<li>  <code>int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 <strong>轴对齐正方形</strong> 的方案数。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/01/image.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;DetectSquares&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]</span><br><span class=\"line\">[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, null, 1, 0, null, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">DetectSquares detectSquares = new DetectSquares();</span><br><span class=\"line\">detectSquares.add([3, 10]);</span><br><span class=\"line\">detectSquares.add([11, 2]);</span><br><span class=\"line\">detectSquares.add([3, 2]);</span><br><span class=\"line\">detectSquares.count([11, 10]); // 返回 1 。你可以选择：</span><br><span class=\"line\">                               //   - 第一个，第二个，和第三个点</span><br><span class=\"line\">detectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。</span><br><span class=\"line\">detectSquares.add([11, 2]);    // 允许添加重复的点。</span><br><span class=\"line\">detectSquares.count([11, 10]); // 返回 2 。你可以选择：</span><br><span class=\"line\">                               //   - 第一个，第二个，和第三个点</span><br><span class=\"line\">                               //   - 第一个，第三个，和第四个点</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>point.length == 2</code></li>\n<li>  <code>0 &lt;= x, y &lt;= 1000</code></li>\n<li>  调用 <code>add</code> 和 <code>count</code> 的 <strong>总次数</strong> 最多为 <code>5000</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>定位正方形时可通过枚举对角线进行，确定能否构成正方形只需要一个点。因为只有 <code>1000</code> 个点，所以可以直接开一个静态数组。</p>\n<blockquote>\n<p>  周赛的时候写了一堆 <code>std::map</code> ，没想到静态数组和一点定正方形，跑去算了半天对角线长度，欢声笑语中打出 GG</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DetectSquares</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">DetectSquares</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(points, <span class=\"number\">0</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>) * <span class=\"number\">1001</span> * <span class=\"number\">1001</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; point)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        points[point[<span class=\"number\">0</span>]][point[<span class=\"number\">1</span>]] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt; point)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = point[<span class=\"number\">0</span>], y = point[<span class=\"number\">1</span>], ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> ny = <span class=\"number\">0</span>; ny &lt; <span class=\"number\">1001</span>; ++ny)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (points[x][ny] == <span class=\"number\">0</span> || ny == y)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> d = ny - y;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( x + d &gt;= <span class=\"number\">0</span> &amp;&amp; x + d &lt; <span class=\"number\">1001</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += points[x + d][y] * points[x + d][ny] * points[x][ny];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( x - d &gt;= <span class=\"number\">0</span> &amp;&amp; x - d &lt; <span class=\"number\">1001</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += points[x - d][y] * points[x - d][ny] * points[x][ny];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> points[<span class=\"number\">1001</span>][<span class=\"number\">1001</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5878-重复-K-次的最长子序列\"><a href=\"#T4-5878-重复-K-次的最长子序列\" class=\"headerlink\" title=\"T4 5878. 重复 K 次的最长子序列\"></a>T4 5878. 重复 K 次的最长子序列</h2><ul>\n<li>  <strong>通过的用户数</strong>111</li>\n<li>  <strong>尝试过的用户数</strong>186</li>\n<li>  <strong>用户总通过次数</strong>149</li>\n<li>  <strong>用户总提交次数</strong>567</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个长度为 <code>n</code> 的字符串 <code>s</code> ，和一个整数 <code>k</code> 。请你找出字符串 <code>s</code> 中 <strong>重复</strong> <code>k</code> 次的 <strong>最长子序列</strong> 。</p>\n<p><strong>子序列</strong> 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p>\n<p>如果 <code>seq * k</code> 是 <code>s</code> 的一个子序列，其中 <code>seq * k</code> 表示一个由 <code>seq</code> 串联 <code>k</code> 次构造的字符串，那么就称 <code>seq</code> 是字符串 <code>s</code> 中一个 <strong>重复 <code>k</code> 次</strong> 的子序列。</p>\n<ul>\n<li>  举个例子，<code>&quot;bba&quot;</code> 是字符串 <code>&quot;bababcba&quot;</code> 中的一个重复 <code>2</code> 次的子序列，因为字符串 <code>&quot;bbabba&quot;</code> 是由 <code>&quot;bba&quot;</code> 串联 <code>2</code> 次构造的，而 <code>&quot;bbabba&quot;</code> 是字符串 <code>&quot;bababcba&quot;</code> 的一个子序列。</li>\n</ul>\n<p>返回字符串 <code>s</code> 中 <strong>重复 k 次的最长子序列</strong> 。如果存在多个满足的子序列，则返回 <strong>字典序最大</strong> 的那个。如果不存在这样的子序列，返回一个 <strong>空</strong> 字符串。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png\" alt=\"example 1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;letsleetcode&quot;, k = 2</span><br><span class=\"line\">输出：&quot;let&quot;</span><br><span class=\"line\">解释：存在两个最长子序列重复 2 次：let&quot; 和 &quot;ete&quot; 。</span><br><span class=\"line\">&quot;let&quot; 是其中字典序最大的一个。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bb&quot;, k = 2</span><br><span class=\"line\">输出：&quot;b&quot;</span><br><span class=\"line\">解释：重复 2 次的最长子序列是 &quot;b&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ab&quot;, k = 2</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：不存在重复 2 次的最长子序列。返回空字符串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bbabbabbbbabaababab&quot;, k = 3</span><br><span class=\"line\">输出：&quot;bbbb&quot;</span><br><span class=\"line\">解释：在 &quot;bbabbabbbbabaababab&quot; 中重复 3 次的最长子序列是 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == s.length</code></li>\n<li>  <code>2 &lt;= k &lt;= 2000</code></li>\n<li>  <code>2 &lt;= n &lt; k * 8</code></li>\n<li>  <code>s</code> 由小写英文字母组成</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>题目所给数据实际上隐含了一条信息：子序列长度不会超过 8，所以对长度为 1 到 7 的全部子序列依次验证即可。</p>\n<blockquote>\n<p>  纯暴力，C++ 似乎也可以通过全排列函数求解</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(string &amp;a, string &amp;b, <span class=\"keyword\">int</span> k)</span></span>&#123;<span class=\"comment\">//检测b能否在a中出现k次</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; a.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]==b[j])&#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j==b.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>, cnt++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cnt==k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">longestSubsequenceRepeatedK</span><span class=\"params\">(string s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//易知：子序列长度最多为7 故而可以暴力找出长度为7以内的序列作为要找的子序列 依次验证即可</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//若对于长度为len的符合条件的子序列 则它一定是由长度为len-1的序列通过添加一个字母生成的</span></span><br><span class=\"line\">    <span class=\"comment\">//故而递推生成所有可能的子序列即可 然后验证是否符合条件 加入答案数组 最后返回最大的即可</span></span><br><span class=\"line\">    vector&lt;string&gt; ans[<span class=\"number\">8</span>];<span class=\"comment\">//ans[i]表示长度为i的符合条件的字符串</span></span><br><span class=\"line\">    ans[<span class=\"number\">0</span>].<span class=\"built_in\">push_back</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; i &lt; <span class=\"number\">8</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> v : ans[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> j = <span class=\"string\">&#x27;a&#x27;</span>; j &lt;= <span class=\"string\">&#x27;z&#x27;</span>; j++)&#123;</span><br><span class=\"line\">                string t = v + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(s,t,k)) ans[i].<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans[i].<span class=\"built_in\">empty</span>()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(ans[i].<span class=\"built_in\">begin</span>(),ans[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[i].<span class=\"built_in\">back</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：zeroac</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/longest-subsequence-repeated-k-times/solution/c-bao-li-mei-ju-chang-du-7yi-nei-xu-lie-febao/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LeetCode 周赛 262","date":"2021-10-10T05:28:07.000Z","_content":"\n---------\n\n# LeetCode 周赛 262\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-262/problems/two-out-of-three/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-262/problems/minimum-operations-to-make-a-uni-value-grid/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-262/problems/stock-price-fluctuation/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-262/problems/partition-array-into-two-arrays-to-minimize-sum-difference/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 2378 / 4260 | MiracleSNeko | 3    | 0:21:15  | 0:16:15 1                                                    |                                                              |                                                              |                                                              |\n\n>大写的寄\n\n## T1 5894. 至少在两个数组中出现的值\n\n- **通过的用户数**3063\n- **尝试过的用户数**3147\n- **用户总通过次数**3114\n- **用户总提交次数**4627\n- **题目难度** **Easy**\n\n给你三个整数数组 `nums1`、`nums2` 和 `nums3` ，请你构造并返回一个 **不同** 数组，且由 **至少** 在 **两个** 数组中出现的所有值组成*。*数组中的元素可以按 **任意** 顺序排列。\n\n**示例 1：**\n\n```\n输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]\n输出：[3,2]\n解释：至少在两个数组中出现的所有值为：\n- 3 ，在全部三个数组中都出现过。\n- 2 ，在数组 nums1 和 nums2 中出现过。\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]\n输出：[2,3,1]\n解释：至少在两个数组中出现的所有值为：\n- 2 ，在数组 nums2 和 nums3 中出现过。\n- 3 ，在数组 nums1 和 nums2 中出现过。\n- 1 ，在数组 nums1 和 nums3 中出现过。\n```\n\n**示例 3：**\n\n```\n输入：nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]\n输出：[]\n解释：不存在至少在两个数组中出现的值。\n```\n\n**提示：**\n\n- `1 <= nums1.length, nums2.length, nums3.length <= 100`\n- `1 <= nums1[i], nums2[j], nums3[k] <= 100`\n\n**我的提交：**\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::rc::Rc;\n\nmacro_rules! init_cin {\n    () => {{\n        (io::stdin(), String::new())\n    }};\n}\nmacro_rules! scanf {\n    ($buf: expr, $div: expr, $($x:ty), +) => {{\n        let mut iter = $buf.split($div);\n        ($(iter.next().and_then(|token| token.parse::<$x>().ok()), ) *)\n    }};\n}\nmacro_rules! getline {\n    ($cin: expr, $buf: expr) => {{\n        $buf.clear();\n        $cin.read_line(&mut $buf)?;\n    }};\n}\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(mut v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\n\nimpl Solution {\n    pub fn two_out_of_three(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>) -> Vec<i32> {\n        let mut mp = HashMap::new();\n        for i in nums1 {\n            map_or_insert!(mp, i, |x: &mut i32| *x |= 1, 1);\n        }\n        for i in nums2 {\n            map_or_insert!(mp, i, |x: &mut i32| *x |= 2, 2);\n        }\n        for i in nums3 {\n            map_or_insert!(mp, i, |x: &mut i32| *x |= 4, 4);\n        }\n        mp.into_iter()\n            .filter(|&(_, v)| v == 3 || v == 5 || v == 6 || v == 7)\n            .map(|(k, _)| k)\n            .collect()\n    }\n}\n```\n\n\n\n## T2 5895. 获取单值网格的最小操作数\n\n- **通过的用户数**1442\n- **尝试过的用户数**2095\n- **用户总通过次数**1486\n- **用户总提交次数**5233\n- **题目难度** **Medium**\n\n给你一个大小为 `m x n` 的二维整数网格 `grid` 和一个整数 `x` 。每一次操作，你可以对 `grid` 中的任一元素 **加** `x` 或 **减** `x` 。\n\n**单值网格** 是全部元素都相等的网格。\n\n返回使网格化为单值网格所需的 **最小** 操作数。如果不能，返回 `-1` 。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png)\n\n```\n输入：grid = [[2,4],[6,8]], x = 2\n输出：4\n解释：可以执行下述操作使所有元素都等于 4 ： \n- 2 加 x 一次。\n- 6 减 x 一次。\n- 8 减 x 两次。\n共计 4 次操作。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png)\n\n```\n输入：grid = [[1,5],[2,3]], x = 1\n输出：5\n解释：可以使所有元素都等于 3 。\n```\n\n**示例 3：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png)\n\n```\n输入：grid = [[1,2],[3,4]], x = 2\n输出：-1\n解释：无法使所有元素相等。\n```\n\n**提示：**\n\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 105`\n- `1 <= m * n <= 105`\n- `1 <= x, grid[i][j] <= 104`\n\n**代码：**\n\n> [某道题](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)的原题改编。找到中位数即可。至于为什么找中位数：\n>\n> 因为可以证明 $f(x) = |x - x_1| + ... + |x - x_n|$ 在中位数处取得最小值。\n\n```rust\nimpl Solution {\n    pub fn min_operations(grid: Vec<Vec<i32>>, x: i32) -> i32 {\n        let mut flat = vec![];\n        grid.iter()\n            .for_each(|v| v.iter().for_each(|&i| flat.push(i)));\n        flat.sort();\n        let mid = flat[flat.len() / 2];\n        let ans = 0;\n        for i in flat {\n            let diff = (i - mid).abs();\n            if diff % x != 0 {\n                return -1;\n            }\n            ans += diff / x;\n        }\n        ans\n    }\n}\n```\n\n\n\n## T3 5896. 股票价格波动\n\n- **通过的用户数**853\n- **尝试过的用户数**1843\n- **用户总通过次数**878\n- **用户总提交次数**4663\n- **题目难度** **Medium**\n\n给你一支股票价格的数据流。数据流中每一条记录包含一个 **时间戳** 和该时间点股票对应的 **价格** 。\n\n不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 **更正** 前一条错误的记录。\n\n请你设计一个算法，实现：\n\n- **更新** 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 **更正** 之前的错误价格。\n- 找到当前记录里 **最新股票价格** 。**最新股票价格** 定义为时间戳最晚的股票价格。\n- 找到当前记录里股票的 **最高价格** 。\n- 找到当前记录里股票的 **最低价格** 。\n\n请你实现 `StockPrice` 类：\n\n- `StockPrice()` 初始化对象，当前无股票价格记录。\n- `void update(int timestamp, int price)` 在时间点 `timestamp` 更新股票价格为 `price` 。\n- `int current()` 返回股票 **最新价格** 。\n- `int maximum()` 返回股票 **最高价格** 。\n- `int minimum()` 返回股票 **最低价格** 。\n\n**示例 1：**\n\n```\n输入：\n[\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n输出：\n[null, null, null, 5, 10, null, 5, null, 2]\n\n解释：\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。\nstockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。\nstockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。\nstockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。\nstockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。\n                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。\nstockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。\nstockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。\nstockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。\n```\n\n**提示：**\n\n- `1 <= timestamp, price <= 109`\n- `update`，`current`，`maximum` 和 `minimum` **总** 调用次数不超过 `105` 。\n- `current`，`maximum` 和 `minimum` 被调用时，`update` 操作 **至少** 已经被调用过 **一次** 。\n\n**题解：**\n\n> 对 C++ 来说是个简单题，对 Rust 来说，坐牢（\n\n```c++\nclass StockPrice {\npublic:\n    StockPrice() {\n        lastTime = 0;\n    }\n    \n    void update(int timestamp, int price) {\n        //更新某一时间戳价格时\n        if(f.count(timestamp)){\n            int x = p.count(f[timestamp]);\n            //erase会删除所有值为f[timestamp]的数据\n            p.erase(f[timestamp]);\n            //只删去一个,多删的补回来\n            for(int i=0; i<x-1; i++) p.insert(f[timestamp]);\n        }\n        //更新价格\n        f[timestamp] = price;\n        //记录最新时间戳\n        if(timestamp > lastTime) lastTime = timestamp;\n        //插入价格\n        p.insert(price);\n    }\n    \n    int current() {\n        return f[lastTime];\n    }\n    \n    int maximum() {\n        return *p.rbegin();\n    }\n    \n    int minimum() {\n        return *p.begin();\n        \n    }\nprivate:.\n    //从大到小排序的股票价格\n    multiset<int> p;\n    //时间戳对应的股票价格\n    unordered_map<int,int> f;\n    //最新时间戳\n    int lastTime;\n};\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice* obj = new StockPrice();\n * obj->update(timestamp,price);\n * int param_2 = obj->current();\n * int param_3 = obj->maximum();\n * int param_4 = obj->minimum();\n */\n\n作者：foreversun\n链接：https://leetcode-cn.com/problems/stock-price-fluctuation/solution/5896-gu-piao-jie-ge-bo-dong-by-foreversu-28c2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T4 5897. 将数组分成两个数组并最小化数组和的差\n\n- **通过的用户数**140\n- **尝试过的用户数**653\n- **用户总通过次数**160\n- **用户总提交次数**1707\n- **题目难度** **Hard**\n\n给你一个长度为 `2 * n` 的整数数组。你需要将 `nums` 分成 **两个** 长度为 `n` 的数组，分别求出两个数组的和，并 **最小化** 两个数组和之 **差的绝对值** 。`nums` 中每个元素都需要放入两个数组之一。\n\n请你返回 **最小** 的数组和之差。\n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/10/02/ex1.png)\n\n```\n输入：nums = [3,9,7,3]\n输出：2\n解释：最优分组方案是分成 [3,9] 和 [7,3] 。\n数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [-36,36]\n输出：72\n解释：最优分组方案是分成 [-36] 和 [36] 。\n数组和之差的绝对值为 abs((-36) - (36)) = 72 。\n```\n\n**示例 3：**\n\n![example-3](https://assets.leetcode.com/uploads/2021/10/02/ex3.png)\n\n```\n输入：nums = [2,-1,0,4,-2,-9]\n输出：0\n解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。\n数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。\n```\n\n**提示：**\n\n- `1 <= n <= 15`\n- `nums.length == 2 * n`\n- `-107 <= nums[i] <= 107`\n\n**代码：**\n\n> 参考 1755. 最接近目标值的子序列和。$2^{30}$ 的大小是 $10^9$ 级别，直接枚举必定超时。\n>\n> 所以要将这 $2n$ 长度的数组拆分为左右两部分，重点考虑到左右都取了元素的情况\n\n>   详情参考折半搜索相关内容\n\n```java\nclass Solution {\n\n    public int minimumDifference(int[] nums) {\n        // 前 n 个元素元素组合情况存储在left 中, 后 n 个元素组合请情况存储在 right 中\n        // Map<元素个数, Set<key个元素的总和>>\n        Map<Integer, TreeSet<Integer>> left = new HashMap<>();\n        Map<Integer, TreeSet<Integer>> right = new HashMap<>();\n\n        int min = Integer.MAX_VALUE;\n        int total = 0;\n\n        int n = nums.length / 2;\n        for(int i=0;i < 2 * n;i++){\n            total += nums[i];\n\n            if(i < n){\n                left.put(i+1, new TreeSet<>());\n            }else{\n                right.put(i - n + 1, new TreeSet<>());\n            }\n        }\n\n        dfs(nums, 0, 0, 0, n, left);\n        dfs(nums, 0, 0, n, 2*n, right);\n\n        // 情况一, 一部分元素在左侧，一部分元素在右侧\n        for(int i=1;i<n;i++){\n            TreeSet<Integer> set = left.get(i);\n            for(int leftSum : set){\n                // 前 i 个元素在  left 中, 后  n - i 个元素在 right 中\n                // 最佳情况是分成两侧相等即  total / 2, 寻找最佳组合最近的组合\n                Integer rightSum = right.get(n-i).ceiling(total / 2 - leftSum);\n                if(null != rightSum){\n                    int sum = leftSum + rightSum;\n                    min = Math.min(min, Math.abs(sum - (total - sum)));\n                }\n\n                rightSum = right.get(n-i).floor(total / 2 - leftSum);\n                if(null != rightSum){\n                    int sum = leftSum + rightSum;\n                    min = Math.min(min, Math.abs(sum - (total - sum)));\n                }\n\n                if(min == 0){\n                    return 0;\n                }\n            }\n        }\n\n        // 情况二,  所有元素都来源与一侧\n        TreeSet<Integer> set = left.get(n);\n        for(int sum : set){\n            min = Math.min(min, Math.abs(sum - (total - sum)));\n        }\n\n        return min;\n    }\n\n    /**\n     * 递归枚举所有的元素组合,将元素组合情况存 Map<元素个数, Set<key个元素的总和>> 中\n     *\n     * @param nums\n     * @param sum   已选数组和\n     * @param count 已选数个数\n     * @param idx   当前索引\n     * @param limit   索引边界\n     * @param visited\n     */\n    public void dfs(int[] nums, int sum, int count, int idx, int limit, Map<Integer, TreeSet<Integer>> visited){\n        if(visited.containsKey(count)){\n            visited.get(count).add(sum);\n        }\n\n        if(idx >= limit) return ;\n\n        // 选择当前元素\n        dfs(nums, sum + nums[idx], count+1, idx+1, limit, visited);\n\n        // 不选当前元素\n        dfs(nums, sum, count, idx+1, limit, visited);\n    }\n}\n\n作者：smqk\n链接：https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution/fen-zu-mei-ju-shuang-100-by-smqk-wnpe/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n>   单纯的折半查找，会 TLE 在第 175 个测试点\n\n```rust\nuse std::collections::HashMap;\n\nmacro_rules! lowbit {\n    ($x: expr) => {{\n        $x & (!$x + 1)\n    }};\n}\n\nimpl Solution {\n    pub fn minimum_difference(mut left: Vec<i32>) -> i32 {\n        let n = left.len() / 2;\n        let sum = left.iter().sum::<i32>();\n        let right = left.split_off(n);\n        let (left, right) = (Solution::to_count(&left), Solution::to_count(&right));\n        left.iter().flat_map(|lhs| right.iter().map(move |rhs| (lhs, rhs)))\n            .filter(|(lhs, rhs)| lhs.0 + rhs.0 == n as i32)    \n            .fold(i32::MAX, |ans, (lhs, rhs)| {\n                lhs.1.iter().flat_map(|l| rhs.1.iter().map(move |r| (l, r)))\n                    .fold(ans, |ans, (l, r) | {\n                        i32::min(ans, (2 * l + 2 * r - sum).abs())\n                    })\n            })\n    }\n\n    fn to_count(vals: &Vec<i32>) -> HashMap<i32, Vec<i32>> {\n        let n = vals.len();\n        let mut map = HashMap::new();\n        for mask in 0..(1 << n) {\n            let key = Solution::count_mask(mask);\n            let val = Solution::sum_mask(vals, mask);\n            (*map.entry(key).or_insert(vec![])).push(val);\n        }\n        map\n    }\n\n    #[inline]\n    fn count_mask(mut mask: usize) -> i32 {\n        let mut cnt = 0;\n        while mask > 0 {\n            cnt += 1;\n            mask -= lowbit!(mask);\n        }\n        cnt\n    }\n\n    #[inline]\n    fn sum_mask(vals: &Vec<i32>, mask: usize) -> i32 {\n        let mut sum = 0;\n        for i in 0..vals.len() {\n            if mask & (1 << i) != 0 {\n                sum += vals[i];\n            }\n        }\n        sum\n    }\n}\n```\n\n>   实际上可以二分降低复杂度。对于匹配的左侧右侧状态，如果要使得 $|lsum + rsum|$ 最小，显然是取两者符号相反，且 $|lsum|$ 和 $|rsum|$ 最接近的一组数。对于给定的 $rsum$ ，在所有 $lsum$ 里找到第一个不小于 $-rsum$ 的 $lsum$，则此时的 $lsum + rsum$ 是当前的最小值。遍历所有 $rsum$ 即可得到答案。\n\n```rust\nuse std::collections::HashMap;\n\nmacro_rules! lowbit {\n    ($x: expr) => {{\n        $x & (!$x + 1)\n    }}\n}\n\nimpl Solution {\n    pub fn minimum_difference(mut left: Vec<i32>) -> i32 {\n        let n = left.len() / 2;\n        let right = left.split_off(n);\n        let (left, right) = (Solution::to_count(&left), Solution::to_count(&right));\n        left.iter().flat_map(|lhs| right.iter().map(move |rhs| (lhs, rhs)))\n            .filter(|(lhs, rhs)| lhs.0 + rhs.0 == n as i32)    \n            .fold(i32::MAX, |ans, (lhs, rhs)| {\n                rhs.1.iter().fold(ans, |ans, r| {\n                    let pos = lhs.1.binary_search(&-r).unwrap_or_else(|err| err);\n                    if pos != lhs.1.len() { i32::min(ans, r + lhs.1[pos]) } else {ans}\n                })\n            })\n    }\n\n    fn to_count(vals: &Vec<i32>) -> HashMap<i32, Vec<i32>> {\n        let n = vals.len();\n        let mut map = HashMap::new();\n        for mask in 0..(1 << n) {\n            let key = Solution::count_mask(mask);\n            let val = Solution::sum_mask(vals, mask);\n            (*map.entry(key).or_insert(vec![])).push(val);\n        }\n        map.iter_mut().for_each(|(_, v)| v.sort());\n        map\n    }\n\n    #[inline]\n    fn count_mask(mut mask: usize) -> i32 {\n        let mut cnt = 0;\n        while mask > 0 {\n            cnt += 1;\n            mask -= lowbit!(mask);\n        }\n        cnt\n    }\n\n    #[inline]\n    fn sum_mask(vals: &Vec<i32>, mask: usize) -> i32 {\n        let mut sum = 0;\n        for i in 0..vals.len() {\n            if mask & (1 << i) != 0 {\n                sum += vals[i];\n            } else {\n                sum -= vals[i];\n            }\n        }\n        sum\n    }\n}\n```\n\n\n\n不一定对的复杂度分析：\n\n-   不使用二分，直接折半遍历\n    -   预处理阶段，左右各自遍历 $2^n$ 个 $mask$ 构造哈希表\n    -   遍历左侧的 $n$ 种情况，右侧的情况与之对应。设左侧取 $i$ 个数，右侧取 $n - i$ 个，则需要计算 $C_n^i C_n^{n - i}$ 次\n    -   总复杂度 $O(2^{n}) + O(\\sum_{i = 0}^n C_n^i C_n^{n - i})$ = $O(2^{n+1}) + O(\\frac{4^n\\Gamma(n + \\frac{1}{2})}{\\sqrt{\\pi} n!})$ ~~，$\\lim_{n \\to \\infty} \\frac{\\Gamma(n + \\frac{1}{2})}{\\sqrt{\\pi} n! \\sqrt n} = 0.56419$，因此该解法的复杂度比不折半低一个$O(\\sqrt n)$？~~\n    -   用 Wolfram Alpha 计算 $n = 30$ 时后半部分的求和是 $1e9$ 的 $1e8$ 倍\n-   使用二分\n    -   预处理阶段，左右各遍历 $2^n$ 个 $mask$ 构造哈希表\n    -   遍历哈希表，每一侧取 $i$ 个数时的 $C_n^i$ 种情况需要排序，合计 $2 \\sum_{i = 0}^n C_n^i\\log{C_n^i}$\n    -   遍历左侧的 $n$ 种情况，设左侧取 $i$ 个数，二分查找右侧位置，需要计算 $C_n^i\\log{C_n^{n-i}}$ 次\n    -   总复杂度 $O(2^{n}) + O(\\sum_{i = 0}^n C_n^i\\log{C_n^i})$ \n    -   用 Wolfram Alpha 计算 $n = 30$ 时后两者的比值，结果为 $4.15e6$，后半部分是 $1e9$ 的约 28 倍\n\n","source":"_posts/weekly-contest-262.md","raw":"---\ntitle: LeetCode 周赛 262\ndate: 2021-10-10 13:28:07\ntags: LeetCode 周赛总结\n---\n\n---------\n\n# LeetCode 周赛 262\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-262/problems/two-out-of-three/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-262/problems/minimum-operations-to-make-a-uni-value-grid/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-262/problems/stock-price-fluctuation/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-262/problems/partition-array-into-two-arrays-to-minimize-sum-difference/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 2378 / 4260 | MiracleSNeko | 3    | 0:21:15  | 0:16:15 1                                                    |                                                              |                                                              |                                                              |\n\n>大写的寄\n\n## T1 5894. 至少在两个数组中出现的值\n\n- **通过的用户数**3063\n- **尝试过的用户数**3147\n- **用户总通过次数**3114\n- **用户总提交次数**4627\n- **题目难度** **Easy**\n\n给你三个整数数组 `nums1`、`nums2` 和 `nums3` ，请你构造并返回一个 **不同** 数组，且由 **至少** 在 **两个** 数组中出现的所有值组成*。*数组中的元素可以按 **任意** 顺序排列。\n\n**示例 1：**\n\n```\n输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]\n输出：[3,2]\n解释：至少在两个数组中出现的所有值为：\n- 3 ，在全部三个数组中都出现过。\n- 2 ，在数组 nums1 和 nums2 中出现过。\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]\n输出：[2,3,1]\n解释：至少在两个数组中出现的所有值为：\n- 2 ，在数组 nums2 和 nums3 中出现过。\n- 3 ，在数组 nums1 和 nums2 中出现过。\n- 1 ，在数组 nums1 和 nums3 中出现过。\n```\n\n**示例 3：**\n\n```\n输入：nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]\n输出：[]\n解释：不存在至少在两个数组中出现的值。\n```\n\n**提示：**\n\n- `1 <= nums1.length, nums2.length, nums3.length <= 100`\n- `1 <= nums1[i], nums2[j], nums3[k] <= 100`\n\n**我的提交：**\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::rc::Rc;\n\nmacro_rules! init_cin {\n    () => {{\n        (io::stdin(), String::new())\n    }};\n}\nmacro_rules! scanf {\n    ($buf: expr, $div: expr, $($x:ty), +) => {{\n        let mut iter = $buf.split($div);\n        ($(iter.next().and_then(|token| token.parse::<$x>().ok()), ) *)\n    }};\n}\nmacro_rules! getline {\n    ($cin: expr, $buf: expr) => {{\n        $buf.clear();\n        $cin.read_line(&mut $buf)?;\n    }};\n}\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(mut v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\n\nimpl Solution {\n    pub fn two_out_of_three(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>) -> Vec<i32> {\n        let mut mp = HashMap::new();\n        for i in nums1 {\n            map_or_insert!(mp, i, |x: &mut i32| *x |= 1, 1);\n        }\n        for i in nums2 {\n            map_or_insert!(mp, i, |x: &mut i32| *x |= 2, 2);\n        }\n        for i in nums3 {\n            map_or_insert!(mp, i, |x: &mut i32| *x |= 4, 4);\n        }\n        mp.into_iter()\n            .filter(|&(_, v)| v == 3 || v == 5 || v == 6 || v == 7)\n            .map(|(k, _)| k)\n            .collect()\n    }\n}\n```\n\n\n\n## T2 5895. 获取单值网格的最小操作数\n\n- **通过的用户数**1442\n- **尝试过的用户数**2095\n- **用户总通过次数**1486\n- **用户总提交次数**5233\n- **题目难度** **Medium**\n\n给你一个大小为 `m x n` 的二维整数网格 `grid` 和一个整数 `x` 。每一次操作，你可以对 `grid` 中的任一元素 **加** `x` 或 **减** `x` 。\n\n**单值网格** 是全部元素都相等的网格。\n\n返回使网格化为单值网格所需的 **最小** 操作数。如果不能，返回 `-1` 。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png)\n\n```\n输入：grid = [[2,4],[6,8]], x = 2\n输出：4\n解释：可以执行下述操作使所有元素都等于 4 ： \n- 2 加 x 一次。\n- 6 减 x 一次。\n- 8 减 x 两次。\n共计 4 次操作。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png)\n\n```\n输入：grid = [[1,5],[2,3]], x = 1\n输出：5\n解释：可以使所有元素都等于 3 。\n```\n\n**示例 3：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png)\n\n```\n输入：grid = [[1,2],[3,4]], x = 2\n输出：-1\n解释：无法使所有元素相等。\n```\n\n**提示：**\n\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 105`\n- `1 <= m * n <= 105`\n- `1 <= x, grid[i][j] <= 104`\n\n**代码：**\n\n> [某道题](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)的原题改编。找到中位数即可。至于为什么找中位数：\n>\n> 因为可以证明 $f(x) = |x - x_1| + ... + |x - x_n|$ 在中位数处取得最小值。\n\n```rust\nimpl Solution {\n    pub fn min_operations(grid: Vec<Vec<i32>>, x: i32) -> i32 {\n        let mut flat = vec![];\n        grid.iter()\n            .for_each(|v| v.iter().for_each(|&i| flat.push(i)));\n        flat.sort();\n        let mid = flat[flat.len() / 2];\n        let ans = 0;\n        for i in flat {\n            let diff = (i - mid).abs();\n            if diff % x != 0 {\n                return -1;\n            }\n            ans += diff / x;\n        }\n        ans\n    }\n}\n```\n\n\n\n## T3 5896. 股票价格波动\n\n- **通过的用户数**853\n- **尝试过的用户数**1843\n- **用户总通过次数**878\n- **用户总提交次数**4663\n- **题目难度** **Medium**\n\n给你一支股票价格的数据流。数据流中每一条记录包含一个 **时间戳** 和该时间点股票对应的 **价格** 。\n\n不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 **更正** 前一条错误的记录。\n\n请你设计一个算法，实现：\n\n- **更新** 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 **更正** 之前的错误价格。\n- 找到当前记录里 **最新股票价格** 。**最新股票价格** 定义为时间戳最晚的股票价格。\n- 找到当前记录里股票的 **最高价格** 。\n- 找到当前记录里股票的 **最低价格** 。\n\n请你实现 `StockPrice` 类：\n\n- `StockPrice()` 初始化对象，当前无股票价格记录。\n- `void update(int timestamp, int price)` 在时间点 `timestamp` 更新股票价格为 `price` 。\n- `int current()` 返回股票 **最新价格** 。\n- `int maximum()` 返回股票 **最高价格** 。\n- `int minimum()` 返回股票 **最低价格** 。\n\n**示例 1：**\n\n```\n输入：\n[\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n输出：\n[null, null, null, 5, 10, null, 5, null, 2]\n\n解释：\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。\nstockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。\nstockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。\nstockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。\nstockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。\n                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。\nstockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。\nstockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。\nstockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。\n```\n\n**提示：**\n\n- `1 <= timestamp, price <= 109`\n- `update`，`current`，`maximum` 和 `minimum` **总** 调用次数不超过 `105` 。\n- `current`，`maximum` 和 `minimum` 被调用时，`update` 操作 **至少** 已经被调用过 **一次** 。\n\n**题解：**\n\n> 对 C++ 来说是个简单题，对 Rust 来说，坐牢（\n\n```c++\nclass StockPrice {\npublic:\n    StockPrice() {\n        lastTime = 0;\n    }\n    \n    void update(int timestamp, int price) {\n        //更新某一时间戳价格时\n        if(f.count(timestamp)){\n            int x = p.count(f[timestamp]);\n            //erase会删除所有值为f[timestamp]的数据\n            p.erase(f[timestamp]);\n            //只删去一个,多删的补回来\n            for(int i=0; i<x-1; i++) p.insert(f[timestamp]);\n        }\n        //更新价格\n        f[timestamp] = price;\n        //记录最新时间戳\n        if(timestamp > lastTime) lastTime = timestamp;\n        //插入价格\n        p.insert(price);\n    }\n    \n    int current() {\n        return f[lastTime];\n    }\n    \n    int maximum() {\n        return *p.rbegin();\n    }\n    \n    int minimum() {\n        return *p.begin();\n        \n    }\nprivate:.\n    //从大到小排序的股票价格\n    multiset<int> p;\n    //时间戳对应的股票价格\n    unordered_map<int,int> f;\n    //最新时间戳\n    int lastTime;\n};\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice* obj = new StockPrice();\n * obj->update(timestamp,price);\n * int param_2 = obj->current();\n * int param_3 = obj->maximum();\n * int param_4 = obj->minimum();\n */\n\n作者：foreversun\n链接：https://leetcode-cn.com/problems/stock-price-fluctuation/solution/5896-gu-piao-jie-ge-bo-dong-by-foreversu-28c2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T4 5897. 将数组分成两个数组并最小化数组和的差\n\n- **通过的用户数**140\n- **尝试过的用户数**653\n- **用户总通过次数**160\n- **用户总提交次数**1707\n- **题目难度** **Hard**\n\n给你一个长度为 `2 * n` 的整数数组。你需要将 `nums` 分成 **两个** 长度为 `n` 的数组，分别求出两个数组的和，并 **最小化** 两个数组和之 **差的绝对值** 。`nums` 中每个元素都需要放入两个数组之一。\n\n请你返回 **最小** 的数组和之差。\n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/10/02/ex1.png)\n\n```\n输入：nums = [3,9,7,3]\n输出：2\n解释：最优分组方案是分成 [3,9] 和 [7,3] 。\n数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [-36,36]\n输出：72\n解释：最优分组方案是分成 [-36] 和 [36] 。\n数组和之差的绝对值为 abs((-36) - (36)) = 72 。\n```\n\n**示例 3：**\n\n![example-3](https://assets.leetcode.com/uploads/2021/10/02/ex3.png)\n\n```\n输入：nums = [2,-1,0,4,-2,-9]\n输出：0\n解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。\n数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。\n```\n\n**提示：**\n\n- `1 <= n <= 15`\n- `nums.length == 2 * n`\n- `-107 <= nums[i] <= 107`\n\n**代码：**\n\n> 参考 1755. 最接近目标值的子序列和。$2^{30}$ 的大小是 $10^9$ 级别，直接枚举必定超时。\n>\n> 所以要将这 $2n$ 长度的数组拆分为左右两部分，重点考虑到左右都取了元素的情况\n\n>   详情参考折半搜索相关内容\n\n```java\nclass Solution {\n\n    public int minimumDifference(int[] nums) {\n        // 前 n 个元素元素组合情况存储在left 中, 后 n 个元素组合请情况存储在 right 中\n        // Map<元素个数, Set<key个元素的总和>>\n        Map<Integer, TreeSet<Integer>> left = new HashMap<>();\n        Map<Integer, TreeSet<Integer>> right = new HashMap<>();\n\n        int min = Integer.MAX_VALUE;\n        int total = 0;\n\n        int n = nums.length / 2;\n        for(int i=0;i < 2 * n;i++){\n            total += nums[i];\n\n            if(i < n){\n                left.put(i+1, new TreeSet<>());\n            }else{\n                right.put(i - n + 1, new TreeSet<>());\n            }\n        }\n\n        dfs(nums, 0, 0, 0, n, left);\n        dfs(nums, 0, 0, n, 2*n, right);\n\n        // 情况一, 一部分元素在左侧，一部分元素在右侧\n        for(int i=1;i<n;i++){\n            TreeSet<Integer> set = left.get(i);\n            for(int leftSum : set){\n                // 前 i 个元素在  left 中, 后  n - i 个元素在 right 中\n                // 最佳情况是分成两侧相等即  total / 2, 寻找最佳组合最近的组合\n                Integer rightSum = right.get(n-i).ceiling(total / 2 - leftSum);\n                if(null != rightSum){\n                    int sum = leftSum + rightSum;\n                    min = Math.min(min, Math.abs(sum - (total - sum)));\n                }\n\n                rightSum = right.get(n-i).floor(total / 2 - leftSum);\n                if(null != rightSum){\n                    int sum = leftSum + rightSum;\n                    min = Math.min(min, Math.abs(sum - (total - sum)));\n                }\n\n                if(min == 0){\n                    return 0;\n                }\n            }\n        }\n\n        // 情况二,  所有元素都来源与一侧\n        TreeSet<Integer> set = left.get(n);\n        for(int sum : set){\n            min = Math.min(min, Math.abs(sum - (total - sum)));\n        }\n\n        return min;\n    }\n\n    /**\n     * 递归枚举所有的元素组合,将元素组合情况存 Map<元素个数, Set<key个元素的总和>> 中\n     *\n     * @param nums\n     * @param sum   已选数组和\n     * @param count 已选数个数\n     * @param idx   当前索引\n     * @param limit   索引边界\n     * @param visited\n     */\n    public void dfs(int[] nums, int sum, int count, int idx, int limit, Map<Integer, TreeSet<Integer>> visited){\n        if(visited.containsKey(count)){\n            visited.get(count).add(sum);\n        }\n\n        if(idx >= limit) return ;\n\n        // 选择当前元素\n        dfs(nums, sum + nums[idx], count+1, idx+1, limit, visited);\n\n        // 不选当前元素\n        dfs(nums, sum, count, idx+1, limit, visited);\n    }\n}\n\n作者：smqk\n链接：https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution/fen-zu-mei-ju-shuang-100-by-smqk-wnpe/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n>   单纯的折半查找，会 TLE 在第 175 个测试点\n\n```rust\nuse std::collections::HashMap;\n\nmacro_rules! lowbit {\n    ($x: expr) => {{\n        $x & (!$x + 1)\n    }};\n}\n\nimpl Solution {\n    pub fn minimum_difference(mut left: Vec<i32>) -> i32 {\n        let n = left.len() / 2;\n        let sum = left.iter().sum::<i32>();\n        let right = left.split_off(n);\n        let (left, right) = (Solution::to_count(&left), Solution::to_count(&right));\n        left.iter().flat_map(|lhs| right.iter().map(move |rhs| (lhs, rhs)))\n            .filter(|(lhs, rhs)| lhs.0 + rhs.0 == n as i32)    \n            .fold(i32::MAX, |ans, (lhs, rhs)| {\n                lhs.1.iter().flat_map(|l| rhs.1.iter().map(move |r| (l, r)))\n                    .fold(ans, |ans, (l, r) | {\n                        i32::min(ans, (2 * l + 2 * r - sum).abs())\n                    })\n            })\n    }\n\n    fn to_count(vals: &Vec<i32>) -> HashMap<i32, Vec<i32>> {\n        let n = vals.len();\n        let mut map = HashMap::new();\n        for mask in 0..(1 << n) {\n            let key = Solution::count_mask(mask);\n            let val = Solution::sum_mask(vals, mask);\n            (*map.entry(key).or_insert(vec![])).push(val);\n        }\n        map\n    }\n\n    #[inline]\n    fn count_mask(mut mask: usize) -> i32 {\n        let mut cnt = 0;\n        while mask > 0 {\n            cnt += 1;\n            mask -= lowbit!(mask);\n        }\n        cnt\n    }\n\n    #[inline]\n    fn sum_mask(vals: &Vec<i32>, mask: usize) -> i32 {\n        let mut sum = 0;\n        for i in 0..vals.len() {\n            if mask & (1 << i) != 0 {\n                sum += vals[i];\n            }\n        }\n        sum\n    }\n}\n```\n\n>   实际上可以二分降低复杂度。对于匹配的左侧右侧状态，如果要使得 $|lsum + rsum|$ 最小，显然是取两者符号相反，且 $|lsum|$ 和 $|rsum|$ 最接近的一组数。对于给定的 $rsum$ ，在所有 $lsum$ 里找到第一个不小于 $-rsum$ 的 $lsum$，则此时的 $lsum + rsum$ 是当前的最小值。遍历所有 $rsum$ 即可得到答案。\n\n```rust\nuse std::collections::HashMap;\n\nmacro_rules! lowbit {\n    ($x: expr) => {{\n        $x & (!$x + 1)\n    }}\n}\n\nimpl Solution {\n    pub fn minimum_difference(mut left: Vec<i32>) -> i32 {\n        let n = left.len() / 2;\n        let right = left.split_off(n);\n        let (left, right) = (Solution::to_count(&left), Solution::to_count(&right));\n        left.iter().flat_map(|lhs| right.iter().map(move |rhs| (lhs, rhs)))\n            .filter(|(lhs, rhs)| lhs.0 + rhs.0 == n as i32)    \n            .fold(i32::MAX, |ans, (lhs, rhs)| {\n                rhs.1.iter().fold(ans, |ans, r| {\n                    let pos = lhs.1.binary_search(&-r).unwrap_or_else(|err| err);\n                    if pos != lhs.1.len() { i32::min(ans, r + lhs.1[pos]) } else {ans}\n                })\n            })\n    }\n\n    fn to_count(vals: &Vec<i32>) -> HashMap<i32, Vec<i32>> {\n        let n = vals.len();\n        let mut map = HashMap::new();\n        for mask in 0..(1 << n) {\n            let key = Solution::count_mask(mask);\n            let val = Solution::sum_mask(vals, mask);\n            (*map.entry(key).or_insert(vec![])).push(val);\n        }\n        map.iter_mut().for_each(|(_, v)| v.sort());\n        map\n    }\n\n    #[inline]\n    fn count_mask(mut mask: usize) -> i32 {\n        let mut cnt = 0;\n        while mask > 0 {\n            cnt += 1;\n            mask -= lowbit!(mask);\n        }\n        cnt\n    }\n\n    #[inline]\n    fn sum_mask(vals: &Vec<i32>, mask: usize) -> i32 {\n        let mut sum = 0;\n        for i in 0..vals.len() {\n            if mask & (1 << i) != 0 {\n                sum += vals[i];\n            } else {\n                sum -= vals[i];\n            }\n        }\n        sum\n    }\n}\n```\n\n\n\n不一定对的复杂度分析：\n\n-   不使用二分，直接折半遍历\n    -   预处理阶段，左右各自遍历 $2^n$ 个 $mask$ 构造哈希表\n    -   遍历左侧的 $n$ 种情况，右侧的情况与之对应。设左侧取 $i$ 个数，右侧取 $n - i$ 个，则需要计算 $C_n^i C_n^{n - i}$ 次\n    -   总复杂度 $O(2^{n}) + O(\\sum_{i = 0}^n C_n^i C_n^{n - i})$ = $O(2^{n+1}) + O(\\frac{4^n\\Gamma(n + \\frac{1}{2})}{\\sqrt{\\pi} n!})$ ~~，$\\lim_{n \\to \\infty} \\frac{\\Gamma(n + \\frac{1}{2})}{\\sqrt{\\pi} n! \\sqrt n} = 0.56419$，因此该解法的复杂度比不折半低一个$O(\\sqrt n)$？~~\n    -   用 Wolfram Alpha 计算 $n = 30$ 时后半部分的求和是 $1e9$ 的 $1e8$ 倍\n-   使用二分\n    -   预处理阶段，左右各遍历 $2^n$ 个 $mask$ 构造哈希表\n    -   遍历哈希表，每一侧取 $i$ 个数时的 $C_n^i$ 种情况需要排序，合计 $2 \\sum_{i = 0}^n C_n^i\\log{C_n^i}$\n    -   遍历左侧的 $n$ 种情况，设左侧取 $i$ 个数，二分查找右侧位置，需要计算 $C_n^i\\log{C_n^{n-i}}$ 次\n    -   总复杂度 $O(2^{n}) + O(\\sum_{i = 0}^n C_n^i\\log{C_n^i})$ \n    -   用 Wolfram Alpha 计算 $n = 30$ 时后两者的比值，结果为 $4.15e6$，后半部分是 $1e9$ 的约 28 倍\n\n","slug":"weekly-contest-262","published":1,"updated":"2021-11-25T17:02:45.891Z","_id":"ckw3kx8py000a1cy565xg8vl1","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h1 id=\"LeetCode-周赛-262\"><a href=\"#LeetCode-周赛-262\" class=\"headerlink\" title=\"LeetCode 周赛 262\"></a>LeetCode 周赛 262</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-262/problems/two-out-of-three/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-262/problems/minimum-operations-to-make-a-uni-value-grid/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-262/problems/stock-price-fluctuation/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-262/problems/partition-array-into-two-arrays-to-minimize-sum-difference/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2378 / 4260</td>\n<td>MiracleSNeko</td>\n<td>3</td>\n<td>0:21:15</td>\n<td>0:16:15 1</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>大写的寄</p>\n</blockquote>\n<h2 id=\"T1-5894-至少在两个数组中出现的值\"><a href=\"#T1-5894-至少在两个数组中出现的值\" class=\"headerlink\" title=\"T1 5894. 至少在两个数组中出现的值\"></a>T1 5894. 至少在两个数组中出现的值</h2><ul>\n<li><strong>通过的用户数</strong>3063</li>\n<li><strong>尝试过的用户数</strong>3147</li>\n<li><strong>用户总通过次数</strong>3114</li>\n<li><strong>用户总提交次数</strong>4627</li>\n<li><strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 <strong>不同</strong> 数组，且由 <strong>至少</strong> 在 <strong>两个</strong> 数组中出现的所有值组成<em>。</em>数组中的元素可以按 <strong>任意</strong> 顺序排列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]</span><br><span class=\"line\">输出：[3,2]</span><br><span class=\"line\">解释：至少在两个数组中出现的所有值为：</span><br><span class=\"line\">- 3 ，在全部三个数组中都出现过。</span><br><span class=\"line\">- 2 ，在数组 nums1 和 nums2 中出现过。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]</span><br><span class=\"line\">输出：[2,3,1]</span><br><span class=\"line\">解释：至少在两个数组中出现的所有值为：</span><br><span class=\"line\">- 2 ，在数组 nums2 和 nums3 中出现过。</span><br><span class=\"line\">- 3 ，在数组 nums1 和 nums2 中出现过。</span><br><span class=\"line\">- 1 ，在数组 nums1 和 nums3 中出现过。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：不存在至少在两个数组中出现的值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li>\n<li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> init_cin &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#123;</span><br><span class=\"line\">        (io::stdin(), <span class=\"built_in\">String</span>::new())</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> scanf &#123;</span><br><span class=\"line\">    ($buf: expr, $div: expr, $($x:ty), +) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> iter = $buf.split($div);</span><br><span class=\"line\">        ($(iter.next().and_then(|token| token.parse::&lt;$x&gt;().ok()), ) *)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> getline &#123;</span><br><span class=\"line\">    ($cin: expr, $buf: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $buf.clear();</span><br><span class=\"line\">        $cin.read_line(&amp;<span class=\"keyword\">mut</span> $buf)?;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">two_out_of_three</span></span>(nums1: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, nums2: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, nums3: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mp = HashMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums1 &#123;</span><br><span class=\"line\">            map_or_insert!(mp, i, |x: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>| *x |= <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums2 &#123;</span><br><span class=\"line\">            map_or_insert!(mp, i, |x: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>| *x |= <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums3 &#123;</span><br><span class=\"line\">            map_or_insert!(mp, i, |x: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>| *x |= <span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mp.into_iter()</span><br><span class=\"line\">            .filter(|&amp;(_, v)| v == <span class=\"number\">3</span> || v == <span class=\"number\">5</span> || v == <span class=\"number\">6</span> || v == <span class=\"number\">7</span>)</span><br><span class=\"line\">            .map(|(k, _)| k)</span><br><span class=\"line\">            .collect()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5895-获取单值网格的最小操作数\"><a href=\"#T2-5895-获取单值网格的最小操作数\" class=\"headerlink\" title=\"T2 5895. 获取单值网格的最小操作数\"></a>T2 5895. 获取单值网格的最小操作数</h2><ul>\n<li><strong>通过的用户数</strong>1442</li>\n<li><strong>尝试过的用户数</strong>2095</li>\n<li><strong>用户总通过次数</strong>1486</li>\n<li><strong>用户总提交次数</strong>5233</li>\n<li><strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个大小为 <code>m x n</code> 的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 <strong>加</strong> <code>x</code> 或 <strong>减</strong> <code>x</code> 。</p>\n<p><strong>单值网格</strong> 是全部元素都相等的网格。</p>\n<p>返回使网格化为单值网格所需的 <strong>最小</strong> 操作数。如果不能，返回 <code>-1</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：grid = [[2,4],[6,8]], x = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：可以执行下述操作使所有元素都等于 4 ： </span><br><span class=\"line\">- 2 加 x 一次。</span><br><span class=\"line\">- 6 减 x 一次。</span><br><span class=\"line\">- 8 减 x 两次。</span><br><span class=\"line\">共计 4 次操作。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：grid = [[1,5],[2,3]], x = 1</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：可以使所有元素都等于 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：grid = [[1,2],[3,4]], x = 2</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：无法使所有元素相等。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == grid.length</code></li>\n<li><code>n == grid[i].length</code></li>\n<li><code>1 &lt;= m, n &lt;= 105</code></li>\n<li><code>1 &lt;= m * n &lt;= 105</code></li>\n<li><code>1 &lt;= x, grid[i][j] &lt;= 104</code></li>\n</ul>\n<p><strong>代码：</strong></p>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/\">某道题</a>的原题改编。找到中位数即可。至于为什么找中位数：</p>\n<p>因为可以证明 $f(x) = |x - x_1| + … + |x - x_n|$ 在中位数处取得最小值。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">min_operations</span></span>(grid: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;, x: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> flat = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">        grid.iter()</span><br><span class=\"line\">            .for_each(|v| v.iter().for_each(|&amp;i| flat.push(i)));</span><br><span class=\"line\">        flat.sort();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mid = flat[flat.len() / <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> flat &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> diff = (i - mid).abs();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> diff % x != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += diff / x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-5896-股票价格波动\"><a href=\"#T3-5896-股票价格波动\" class=\"headerlink\" title=\"T3 5896. 股票价格波动\"></a>T3 5896. 股票价格波动</h2><ul>\n<li><strong>通过的用户数</strong>853</li>\n<li><strong>尝试过的用户数</strong>1843</li>\n<li><strong>用户总通过次数</strong>878</li>\n<li><strong>用户总提交次数</strong>4663</li>\n<li><strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一支股票价格的数据流。数据流中每一条记录包含一个 <strong>时间戳</strong> 和该时间点股票对应的 <strong>价格</strong> 。</p>\n<p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 <strong>更正</strong> 前一条错误的记录。</p>\n<p>请你设计一个算法，实现：</p>\n<ul>\n<li><strong>更新</strong> 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 <strong>更正</strong> 之前的错误价格。</li>\n<li>找到当前记录里 <strong>最新股票价格</strong> 。<strong>最新股票价格</strong> 定义为时间戳最晚的股票价格。</li>\n<li>找到当前记录里股票的 <strong>最高价格</strong> 。</li>\n<li>找到当前记录里股票的 <strong>最低价格</strong> 。</li>\n</ul>\n<p>请你实现 <code>StockPrice</code> 类：</p>\n<ul>\n<li><code>StockPrice()</code> 初始化对象，当前无股票价格记录。</li>\n<li><code>void update(int timestamp, int price)</code> 在时间点 <code>timestamp</code> 更新股票价格为 <code>price</code> 。</li>\n<li><code>int current()</code> 返回股票 <strong>最新价格</strong> 。</li>\n<li><code>int maximum()</code> 返回股票 <strong>最高价格</strong> 。</li>\n<li><code>int minimum()</code> 返回股票 <strong>最低价格</strong> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;StockPrice&quot;, &quot;update&quot;, &quot;update&quot;, &quot;current&quot;, &quot;maximum&quot;, &quot;update&quot;, &quot;maximum&quot;, &quot;update&quot;, &quot;minimum&quot;]</span><br><span class=\"line\">[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, 5, 10, null, 5, null, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">StockPrice stockPrice = new StockPrice();</span><br><span class=\"line\">stockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。</span><br><span class=\"line\">stockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。</span><br><span class=\"line\">stockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。</span><br><span class=\"line\">stockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。</span><br><span class=\"line\">stockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。</span><br><span class=\"line\">                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。</span><br><span class=\"line\">stockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。</span><br><span class=\"line\">stockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。</span><br><span class=\"line\">stockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= timestamp, price &lt;= 109</code></li>\n<li><code>update</code>，<code>current</code>，<code>maximum</code> 和 <code>minimum</code> <strong>总</strong> 调用次数不超过 <code>105</code> 。</li>\n<li><code>current</code>，<code>maximum</code> 和 <code>minimum</code> 被调用时，<code>update</code> 操作 <strong>至少</strong> 已经被调用过 <strong>一次</strong> 。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>对 C++ 来说是个简单题，对 Rust 来说，坐牢（</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StockPrice</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">StockPrice</span>() &#123;</span><br><span class=\"line\">        lastTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> timestamp, <span class=\"keyword\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//更新某一时间戳价格时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f.<span class=\"built_in\">count</span>(timestamp))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = p.<span class=\"built_in\">count</span>(f[timestamp]);</span><br><span class=\"line\">            <span class=\"comment\">//erase会删除所有值为f[timestamp]的数据</span></span><br><span class=\"line\">            p.<span class=\"built_in\">erase</span>(f[timestamp]);</span><br><span class=\"line\">            <span class=\"comment\">//只删去一个,多删的补回来</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;x<span class=\"number\">-1</span>; i++) p.<span class=\"built_in\">insert</span>(f[timestamp]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新价格</span></span><br><span class=\"line\">        f[timestamp] = price;</span><br><span class=\"line\">        <span class=\"comment\">//记录最新时间戳</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timestamp &gt; lastTime) lastTime = timestamp;</span><br><span class=\"line\">        <span class=\"comment\">//插入价格</span></span><br><span class=\"line\">        p.<span class=\"built_in\">insert</span>(price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">current</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[lastTime];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *p.<span class=\"built_in\">rbegin</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minimum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *p.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:.</span><br><span class=\"line\">    <span class=\"comment\">//从大到小排序的股票价格</span></span><br><span class=\"line\">    multiset&lt;<span class=\"keyword\">int</span>&gt; p;</span><br><span class=\"line\">    <span class=\"comment\">//时间戳对应的股票价格</span></span><br><span class=\"line\">    unordered_map&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; f;</span><br><span class=\"line\">    <span class=\"comment\">//最新时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastTime;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your StockPrice object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * StockPrice* obj = new StockPrice();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj-&gt;update(timestamp,price);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj-&gt;current();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj-&gt;maximum();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj-&gt;minimum();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">作者：foreversun</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/stock-price-fluctuation/solution/5896-gu-piao-jie-ge-bo-dong-by-foreversu-28c2/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5897-将数组分成两个数组并最小化数组和的差\"><a href=\"#T4-5897-将数组分成两个数组并最小化数组和的差\" class=\"headerlink\" title=\"T4 5897. 将数组分成两个数组并最小化数组和的差\"></a>T4 5897. 将数组分成两个数组并最小化数组和的差</h2><ul>\n<li><strong>通过的用户数</strong>140</li>\n<li><strong>尝试过的用户数</strong>653</li>\n<li><strong>用户总通过次数</strong>160</li>\n<li><strong>用户总提交次数</strong>1707</li>\n<li><strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 <strong>两个</strong> 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 <strong>最小化</strong> 两个数组和之 <strong>差的绝对值</strong> 。<code>nums</code> 中每个元素都需要放入两个数组之一。</p>\n<p>请你返回 <strong>最小</strong> 的数组和之差。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/02/ex1.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,9,7,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：最优分组方案是分成 [3,9] 和 [7,3] 。</span><br><span class=\"line\">数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-36,36]</span><br><span class=\"line\">输出：72</span><br><span class=\"line\">解释：最优分组方案是分成 [-36] 和 [36] 。</span><br><span class=\"line\">数组和之差的绝对值为 abs((-36) - (36)) = 72 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/02/ex3.png\" alt=\"example-3\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,0,4,-2,-9]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。</span><br><span class=\"line\">数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 15</code></li>\n<li><code>nums.length == 2 * n</code></li>\n<li><code>-107 &lt;= nums[i] &lt;= 107</code></li>\n</ul>\n<p><strong>代码：</strong></p>\n<blockquote>\n<p>参考 1755. 最接近目标值的子序列和。$2^{30}$ 的大小是 $10^9$ 级别，直接枚举必定超时。</p>\n<p>所以要将这 $2n$ 长度的数组拆分为左右两部分，重点考虑到左右都取了元素的情况</p>\n</blockquote>\n<blockquote>\n<p>  详情参考折半搜索相关内容</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minimumDifference</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前 n 个元素元素组合情况存储在left 中, 后 n 个元素组合请情况存储在 right 中</span></span><br><span class=\"line\">        <span class=\"comment\">// Map&lt;元素个数, Set&lt;key个元素的总和&gt;&gt;</span></span><br><span class=\"line\">        Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; left = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; right = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i &lt; <span class=\"number\">2</span> * n;i++)&#123;</span><br><span class=\"line\">            total += nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &lt; n)&#123;</span><br><span class=\"line\">                left.put(i+<span class=\"number\">1</span>, <span class=\"keyword\">new</span> TreeSet&lt;&gt;());</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                right.put(i - n + <span class=\"number\">1</span>, <span class=\"keyword\">new</span> TreeSet&lt;&gt;());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dfs(nums, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n, left);</span><br><span class=\"line\">        dfs(nums, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n, <span class=\"number\">2</span>*n, right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 情况一, 一部分元素在左侧，一部分元素在右侧</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            TreeSet&lt;Integer&gt; set = left.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> leftSum : set)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 前 i 个元素在  left 中, 后  n - i 个元素在 right 中</span></span><br><span class=\"line\">                <span class=\"comment\">// 最佳情况是分成两侧相等即  total / 2, 寻找最佳组合最近的组合</span></span><br><span class=\"line\">                Integer rightSum = right.get(n-i).ceiling(total / <span class=\"number\">2</span> - leftSum);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != rightSum)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = leftSum + rightSum;</span><br><span class=\"line\">                    min = Math.min(min, Math.abs(sum - (total - sum)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                rightSum = right.get(n-i).floor(total / <span class=\"number\">2</span> - leftSum);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != rightSum)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = leftSum + rightSum;</span><br><span class=\"line\">                    min = Math.min(min, Math.abs(sum - (total - sum)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(min == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 情况二,  所有元素都来源与一侧</span></span><br><span class=\"line\">        TreeSet&lt;Integer&gt; set = left.get(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> sum : set)&#123;</span><br><span class=\"line\">            min = Math.min(min, Math.abs(sum - (total - sum)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归枚举所有的元素组合,将元素组合情况存 Map&lt;元素个数, Set&lt;key个元素的总和&gt;&gt; 中</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nums</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> sum   已选数组和</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count 已选数个数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> idx   当前索引</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> limit   索引边界</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> visited</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> count, <span class=\"keyword\">int</span> idx, <span class=\"keyword\">int</span> limit, Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; visited)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(visited.containsKey(count))&#123;</span><br><span class=\"line\">            visited.get(count).add(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx &gt;= limit) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 选择当前元素</span></span><br><span class=\"line\">        dfs(nums, sum + nums[idx], count+<span class=\"number\">1</span>, idx+<span class=\"number\">1</span>, limit, visited);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 不选当前元素</span></span><br><span class=\"line\">        dfs(nums, sum, count, idx+<span class=\"number\">1</span>, limit, visited);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：smqk</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution/fen-zu-mei-ju-shuang-100-by-smqk-wnpe/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  单纯的折半查找，会 TLE 在第 175 个测试点</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> lowbit &#123;</span><br><span class=\"line\">    ($x: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $x &amp; (!$x + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">minimum_difference</span></span>(<span class=\"keyword\">mut</span> left: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = left.len() / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sum = left.iter().sum::&lt;<span class=\"built_in\">i32</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> right = left.split_off(n);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (left, right) = (Solution::to_count(&amp;left), Solution::to_count(&amp;right));</span><br><span class=\"line\">        left.iter().flat_map(|lhs| right.iter().map(<span class=\"keyword\">move</span> |rhs| (lhs, rhs)))</span><br><span class=\"line\">            .filter(|(lhs, rhs)| lhs.<span class=\"number\">0</span> + rhs.<span class=\"number\">0</span> == n <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>)    </span><br><span class=\"line\">            .fold(<span class=\"built_in\">i32</span>::MAX, |ans, (lhs, rhs)| &#123;</span><br><span class=\"line\">                lhs.<span class=\"number\">1</span>.iter().flat_map(|l| rhs.<span class=\"number\">1</span>.iter().map(<span class=\"keyword\">move</span> |r| (l, r)))</span><br><span class=\"line\">                    .fold(ans, |ans, (l, r) | &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">i32</span>::min(ans, (<span class=\"number\">2</span> * l + <span class=\"number\">2</span> * r - sum).abs())</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_count</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; HashMap&lt;<span class=\"built_in\">i32</span>, <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = vals.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> map = HashMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> mask <span class=\"keyword\">in</span> <span class=\"number\">0</span>..(<span class=\"number\">1</span> &lt;&lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> key = Solution::count_mask(mask);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> val = Solution::sum_mask(vals, mask);</span><br><span class=\"line\">            (*map.entry(key).or_insert(<span class=\"built_in\">vec!</span>[])).push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">count_mask</span></span>(<span class=\"keyword\">mut</span> mask: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> mask &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">            mask -= lowbit!(mask);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">sum_mask</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, mask: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..vals.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mask &amp; (<span class=\"number\">1</span> &lt;&lt; i) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                sum += vals[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  实际上可以二分降低复杂度。对于匹配的左侧右侧状态，如果要使得 $|lsum + rsum|$ 最小，显然是取两者符号相反，且 $|lsum|$ 和 $|rsum|$ 最接近的一组数。对于给定的 $rsum$ ，在所有 $lsum$ 里找到第一个不小于 $-rsum$ 的 $lsum$，则此时的 $lsum + rsum$ 是当前的最小值。遍历所有 $rsum$ 即可得到答案。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> lowbit &#123;</span><br><span class=\"line\">    ($x: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $x &amp; (!$x + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">minimum_difference</span></span>(<span class=\"keyword\">mut</span> left: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = left.len() / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> right = left.split_off(n);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (left, right) = (Solution::to_count(&amp;left), Solution::to_count(&amp;right));</span><br><span class=\"line\">        left.iter().flat_map(|lhs| right.iter().map(<span class=\"keyword\">move</span> |rhs| (lhs, rhs)))</span><br><span class=\"line\">            .filter(|(lhs, rhs)| lhs.<span class=\"number\">0</span> + rhs.<span class=\"number\">0</span> == n <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>)    </span><br><span class=\"line\">            .fold(<span class=\"built_in\">i32</span>::MAX, |ans, (lhs, rhs)| &#123;</span><br><span class=\"line\">                rhs.<span class=\"number\">1</span>.iter().fold(ans, |ans, r| &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> pos = lhs.<span class=\"number\">1</span>.binary_search(&amp;-r).unwrap_or_else(|err| err);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> pos != lhs.<span class=\"number\">1</span>.len() &#123; <span class=\"built_in\">i32</span>::min(ans, r + lhs.<span class=\"number\">1</span>[pos]) &#125; <span class=\"keyword\">else</span> &#123;ans&#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_count</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; HashMap&lt;<span class=\"built_in\">i32</span>, <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = vals.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> map = HashMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> mask <span class=\"keyword\">in</span> <span class=\"number\">0</span>..(<span class=\"number\">1</span> &lt;&lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> key = Solution::count_mask(mask);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> val = Solution::sum_mask(vals, mask);</span><br><span class=\"line\">            (*map.entry(key).or_insert(<span class=\"built_in\">vec!</span>[])).push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.iter_mut().for_each(|(_, v)| v.sort());</span><br><span class=\"line\">        map</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">count_mask</span></span>(<span class=\"keyword\">mut</span> mask: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> mask &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">            mask -= lowbit!(mask);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">sum_mask</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, mask: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..vals.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mask &amp; (<span class=\"number\">1</span> &lt;&lt; i) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                sum += vals[i];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sum -= vals[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不一定对的复杂度分析：</p>\n<ul>\n<li>不使用二分，直接折半遍历<ul>\n<li>  预处理阶段，左右各自遍历 $2^n$ 个 $mask$ 构造哈希表</li>\n<li>  遍历左侧的 $n$ 种情况，右侧的情况与之对应。设左侧取 $i$ 个数，右侧取 $n - i$ 个，则需要计算 $C_n^i C_n^{n - i}$ 次</li>\n<li>  总复杂度 $O(2^{n}) + O(\\sum_{i = 0}^n C_n^i C_n^{n - i})$ = $O(2^{n+1}) + O(\\frac{4^n\\Gamma(n + \\frac{1}{2})}{\\sqrt{\\pi} n!})$ <del>，$\\lim_{n \\to \\infty} \\frac{\\Gamma(n + \\frac{1}{2})}{\\sqrt{\\pi} n! \\sqrt n} = 0.56419$，因此该解法的复杂度比不折半低一个$O(\\sqrt n)$？</del></li>\n<li>  用 Wolfram Alpha 计算 $n = 30$ 时后半部分的求和是 $1e9$ 的 $1e8$ 倍</li>\n</ul>\n</li>\n<li>使用二分<ul>\n<li>  预处理阶段，左右各遍历 $2^n$ 个 $mask$ 构造哈希表</li>\n<li>  遍历哈希表，每一侧取 $i$ 个数时的 $C_n^i$ 种情况需要排序，合计 $2 \\sum_{i = 0}^n C_n^i\\log{C_n^i}$</li>\n<li>  遍历左侧的 $n$ 种情况，设左侧取 $i$ 个数，二分查找右侧位置，需要计算 $C_n^i\\log{C_n^{n-i}}$ 次</li>\n<li>  总复杂度 $O(2^{n}) + O(\\sum_{i = 0}^n C_n^i\\log{C_n^i})$ </li>\n<li>  用 Wolfram Alpha 计算 $n = 30$ 时后两者的比值，结果为 $4.15e6$，后半部分是 $1e9$ 的约 28 倍</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-262\"><a href=\"#LeetCode-周赛-262\" class=\"headerlink\" title=\"LeetCode 周赛 262\"></a>LeetCode 周赛 262</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-262/problems/two-out-of-three/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-262/problems/minimum-operations-to-make-a-uni-value-grid/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-262/problems/stock-price-fluctuation/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-262/problems/partition-array-into-two-arrays-to-minimize-sum-difference/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2378 / 4260</td>\n<td>MiracleSNeko</td>\n<td>3</td>\n<td>0:21:15</td>\n<td>0:16:15 1</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>大写的寄</p>\n</blockquote>\n<h2 id=\"T1-5894-至少在两个数组中出现的值\"><a href=\"#T1-5894-至少在两个数组中出现的值\" class=\"headerlink\" title=\"T1 5894. 至少在两个数组中出现的值\"></a>T1 5894. 至少在两个数组中出现的值</h2><ul>\n<li><strong>通过的用户数</strong>3063</li>\n<li><strong>尝试过的用户数</strong>3147</li>\n<li><strong>用户总通过次数</strong>3114</li>\n<li><strong>用户总提交次数</strong>4627</li>\n<li><strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 <strong>不同</strong> 数组，且由 <strong>至少</strong> 在 <strong>两个</strong> 数组中出现的所有值组成<em>。</em>数组中的元素可以按 <strong>任意</strong> 顺序排列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]</span><br><span class=\"line\">输出：[3,2]</span><br><span class=\"line\">解释：至少在两个数组中出现的所有值为：</span><br><span class=\"line\">- 3 ，在全部三个数组中都出现过。</span><br><span class=\"line\">- 2 ，在数组 nums1 和 nums2 中出现过。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]</span><br><span class=\"line\">输出：[2,3,1]</span><br><span class=\"line\">解释：至少在两个数组中出现的所有值为：</span><br><span class=\"line\">- 2 ，在数组 nums2 和 nums3 中出现过。</span><br><span class=\"line\">- 3 ，在数组 nums1 和 nums2 中出现过。</span><br><span class=\"line\">- 1 ，在数组 nums1 和 nums3 中出现过。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：不存在至少在两个数组中出现的值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li>\n<li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> init_cin &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#123;</span><br><span class=\"line\">        (io::stdin(), <span class=\"built_in\">String</span>::new())</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> scanf &#123;</span><br><span class=\"line\">    ($buf: expr, $div: expr, $($x:ty), +) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> iter = $buf.split($div);</span><br><span class=\"line\">        ($(iter.next().and_then(|token| token.parse::&lt;$x&gt;().ok()), ) *)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> getline &#123;</span><br><span class=\"line\">    ($cin: expr, $buf: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $buf.clear();</span><br><span class=\"line\">        $cin.read_line(&amp;<span class=\"keyword\">mut</span> $buf)?;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">two_out_of_three</span></span>(nums1: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, nums2: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, nums3: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mp = HashMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums1 &#123;</span><br><span class=\"line\">            map_or_insert!(mp, i, |x: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>| *x |= <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums2 &#123;</span><br><span class=\"line\">            map_or_insert!(mp, i, |x: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>| *x |= <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums3 &#123;</span><br><span class=\"line\">            map_or_insert!(mp, i, |x: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>| *x |= <span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mp.into_iter()</span><br><span class=\"line\">            .filter(|&amp;(_, v)| v == <span class=\"number\">3</span> || v == <span class=\"number\">5</span> || v == <span class=\"number\">6</span> || v == <span class=\"number\">7</span>)</span><br><span class=\"line\">            .map(|(k, _)| k)</span><br><span class=\"line\">            .collect()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5895-获取单值网格的最小操作数\"><a href=\"#T2-5895-获取单值网格的最小操作数\" class=\"headerlink\" title=\"T2 5895. 获取单值网格的最小操作数\"></a>T2 5895. 获取单值网格的最小操作数</h2><ul>\n<li><strong>通过的用户数</strong>1442</li>\n<li><strong>尝试过的用户数</strong>2095</li>\n<li><strong>用户总通过次数</strong>1486</li>\n<li><strong>用户总提交次数</strong>5233</li>\n<li><strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个大小为 <code>m x n</code> 的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 <strong>加</strong> <code>x</code> 或 <strong>减</strong> <code>x</code> 。</p>\n<p><strong>单值网格</strong> 是全部元素都相等的网格。</p>\n<p>返回使网格化为单值网格所需的 <strong>最小</strong> 操作数。如果不能，返回 <code>-1</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：grid = [[2,4],[6,8]], x = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：可以执行下述操作使所有元素都等于 4 ： </span><br><span class=\"line\">- 2 加 x 一次。</span><br><span class=\"line\">- 6 减 x 一次。</span><br><span class=\"line\">- 8 减 x 两次。</span><br><span class=\"line\">共计 4 次操作。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：grid = [[1,5],[2,3]], x = 1</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：可以使所有元素都等于 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：grid = [[1,2],[3,4]], x = 2</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：无法使所有元素相等。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == grid.length</code></li>\n<li><code>n == grid[i].length</code></li>\n<li><code>1 &lt;= m, n &lt;= 105</code></li>\n<li><code>1 &lt;= m * n &lt;= 105</code></li>\n<li><code>1 &lt;= x, grid[i][j] &lt;= 104</code></li>\n</ul>\n<p><strong>代码：</strong></p>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/\">某道题</a>的原题改编。找到中位数即可。至于为什么找中位数：</p>\n<p>因为可以证明 $f(x) = |x - x_1| + … + |x - x_n|$ 在中位数处取得最小值。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">min_operations</span></span>(grid: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;, x: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> flat = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">        grid.iter()</span><br><span class=\"line\">            .for_each(|v| v.iter().for_each(|&amp;i| flat.push(i)));</span><br><span class=\"line\">        flat.sort();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mid = flat[flat.len() / <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> flat &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> diff = (i - mid).abs();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> diff % x != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += diff / x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-5896-股票价格波动\"><a href=\"#T3-5896-股票价格波动\" class=\"headerlink\" title=\"T3 5896. 股票价格波动\"></a>T3 5896. 股票价格波动</h2><ul>\n<li><strong>通过的用户数</strong>853</li>\n<li><strong>尝试过的用户数</strong>1843</li>\n<li><strong>用户总通过次数</strong>878</li>\n<li><strong>用户总提交次数</strong>4663</li>\n<li><strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一支股票价格的数据流。数据流中每一条记录包含一个 <strong>时间戳</strong> 和该时间点股票对应的 <strong>价格</strong> 。</p>\n<p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 <strong>更正</strong> 前一条错误的记录。</p>\n<p>请你设计一个算法，实现：</p>\n<ul>\n<li><strong>更新</strong> 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 <strong>更正</strong> 之前的错误价格。</li>\n<li>找到当前记录里 <strong>最新股票价格</strong> 。<strong>最新股票价格</strong> 定义为时间戳最晚的股票价格。</li>\n<li>找到当前记录里股票的 <strong>最高价格</strong> 。</li>\n<li>找到当前记录里股票的 <strong>最低价格</strong> 。</li>\n</ul>\n<p>请你实现 <code>StockPrice</code> 类：</p>\n<ul>\n<li><code>StockPrice()</code> 初始化对象，当前无股票价格记录。</li>\n<li><code>void update(int timestamp, int price)</code> 在时间点 <code>timestamp</code> 更新股票价格为 <code>price</code> 。</li>\n<li><code>int current()</code> 返回股票 <strong>最新价格</strong> 。</li>\n<li><code>int maximum()</code> 返回股票 <strong>最高价格</strong> 。</li>\n<li><code>int minimum()</code> 返回股票 <strong>最低价格</strong> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;StockPrice&quot;, &quot;update&quot;, &quot;update&quot;, &quot;current&quot;, &quot;maximum&quot;, &quot;update&quot;, &quot;maximum&quot;, &quot;update&quot;, &quot;minimum&quot;]</span><br><span class=\"line\">[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, 5, 10, null, 5, null, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">StockPrice stockPrice = new StockPrice();</span><br><span class=\"line\">stockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。</span><br><span class=\"line\">stockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。</span><br><span class=\"line\">stockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。</span><br><span class=\"line\">stockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。</span><br><span class=\"line\">stockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。</span><br><span class=\"line\">                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。</span><br><span class=\"line\">stockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。</span><br><span class=\"line\">stockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。</span><br><span class=\"line\">stockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= timestamp, price &lt;= 109</code></li>\n<li><code>update</code>，<code>current</code>，<code>maximum</code> 和 <code>minimum</code> <strong>总</strong> 调用次数不超过 <code>105</code> 。</li>\n<li><code>current</code>，<code>maximum</code> 和 <code>minimum</code> 被调用时，<code>update</code> 操作 <strong>至少</strong> 已经被调用过 <strong>一次</strong> 。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>对 C++ 来说是个简单题，对 Rust 来说，坐牢（</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StockPrice</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">StockPrice</span>() &#123;</span><br><span class=\"line\">        lastTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> timestamp, <span class=\"keyword\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//更新某一时间戳价格时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f.<span class=\"built_in\">count</span>(timestamp))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = p.<span class=\"built_in\">count</span>(f[timestamp]);</span><br><span class=\"line\">            <span class=\"comment\">//erase会删除所有值为f[timestamp]的数据</span></span><br><span class=\"line\">            p.<span class=\"built_in\">erase</span>(f[timestamp]);</span><br><span class=\"line\">            <span class=\"comment\">//只删去一个,多删的补回来</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;x<span class=\"number\">-1</span>; i++) p.<span class=\"built_in\">insert</span>(f[timestamp]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新价格</span></span><br><span class=\"line\">        f[timestamp] = price;</span><br><span class=\"line\">        <span class=\"comment\">//记录最新时间戳</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timestamp &gt; lastTime) lastTime = timestamp;</span><br><span class=\"line\">        <span class=\"comment\">//插入价格</span></span><br><span class=\"line\">        p.<span class=\"built_in\">insert</span>(price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">current</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[lastTime];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *p.<span class=\"built_in\">rbegin</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minimum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *p.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:.</span><br><span class=\"line\">    <span class=\"comment\">//从大到小排序的股票价格</span></span><br><span class=\"line\">    multiset&lt;<span class=\"keyword\">int</span>&gt; p;</span><br><span class=\"line\">    <span class=\"comment\">//时间戳对应的股票价格</span></span><br><span class=\"line\">    unordered_map&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; f;</span><br><span class=\"line\">    <span class=\"comment\">//最新时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastTime;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your StockPrice object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * StockPrice* obj = new StockPrice();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj-&gt;update(timestamp,price);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj-&gt;current();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj-&gt;maximum();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj-&gt;minimum();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">作者：foreversun</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/stock-price-fluctuation/solution/5896-gu-piao-jie-ge-bo-dong-by-foreversu-28c2/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5897-将数组分成两个数组并最小化数组和的差\"><a href=\"#T4-5897-将数组分成两个数组并最小化数组和的差\" class=\"headerlink\" title=\"T4 5897. 将数组分成两个数组并最小化数组和的差\"></a>T4 5897. 将数组分成两个数组并最小化数组和的差</h2><ul>\n<li><strong>通过的用户数</strong>140</li>\n<li><strong>尝试过的用户数</strong>653</li>\n<li><strong>用户总通过次数</strong>160</li>\n<li><strong>用户总提交次数</strong>1707</li>\n<li><strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 <strong>两个</strong> 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 <strong>最小化</strong> 两个数组和之 <strong>差的绝对值</strong> 。<code>nums</code> 中每个元素都需要放入两个数组之一。</p>\n<p>请你返回 <strong>最小</strong> 的数组和之差。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/02/ex1.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,9,7,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：最优分组方案是分成 [3,9] 和 [7,3] 。</span><br><span class=\"line\">数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-36,36]</span><br><span class=\"line\">输出：72</span><br><span class=\"line\">解释：最优分组方案是分成 [-36] 和 [36] 。</span><br><span class=\"line\">数组和之差的绝对值为 abs((-36) - (36)) = 72 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/02/ex3.png\" alt=\"example-3\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,0,4,-2,-9]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。</span><br><span class=\"line\">数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 15</code></li>\n<li><code>nums.length == 2 * n</code></li>\n<li><code>-107 &lt;= nums[i] &lt;= 107</code></li>\n</ul>\n<p><strong>代码：</strong></p>\n<blockquote>\n<p>参考 1755. 最接近目标值的子序列和。$2^{30}$ 的大小是 $10^9$ 级别，直接枚举必定超时。</p>\n<p>所以要将这 $2n$ 长度的数组拆分为左右两部分，重点考虑到左右都取了元素的情况</p>\n</blockquote>\n<blockquote>\n<p>  详情参考折半搜索相关内容</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minimumDifference</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前 n 个元素元素组合情况存储在left 中, 后 n 个元素组合请情况存储在 right 中</span></span><br><span class=\"line\">        <span class=\"comment\">// Map&lt;元素个数, Set&lt;key个元素的总和&gt;&gt;</span></span><br><span class=\"line\">        Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; left = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; right = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i &lt; <span class=\"number\">2</span> * n;i++)&#123;</span><br><span class=\"line\">            total += nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &lt; n)&#123;</span><br><span class=\"line\">                left.put(i+<span class=\"number\">1</span>, <span class=\"keyword\">new</span> TreeSet&lt;&gt;());</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                right.put(i - n + <span class=\"number\">1</span>, <span class=\"keyword\">new</span> TreeSet&lt;&gt;());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dfs(nums, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n, left);</span><br><span class=\"line\">        dfs(nums, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n, <span class=\"number\">2</span>*n, right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 情况一, 一部分元素在左侧，一部分元素在右侧</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            TreeSet&lt;Integer&gt; set = left.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> leftSum : set)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 前 i 个元素在  left 中, 后  n - i 个元素在 right 中</span></span><br><span class=\"line\">                <span class=\"comment\">// 最佳情况是分成两侧相等即  total / 2, 寻找最佳组合最近的组合</span></span><br><span class=\"line\">                Integer rightSum = right.get(n-i).ceiling(total / <span class=\"number\">2</span> - leftSum);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != rightSum)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = leftSum + rightSum;</span><br><span class=\"line\">                    min = Math.min(min, Math.abs(sum - (total - sum)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                rightSum = right.get(n-i).floor(total / <span class=\"number\">2</span> - leftSum);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != rightSum)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = leftSum + rightSum;</span><br><span class=\"line\">                    min = Math.min(min, Math.abs(sum - (total - sum)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(min == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 情况二,  所有元素都来源与一侧</span></span><br><span class=\"line\">        TreeSet&lt;Integer&gt; set = left.get(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> sum : set)&#123;</span><br><span class=\"line\">            min = Math.min(min, Math.abs(sum - (total - sum)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归枚举所有的元素组合,将元素组合情况存 Map&lt;元素个数, Set&lt;key个元素的总和&gt;&gt; 中</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nums</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> sum   已选数组和</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count 已选数个数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> idx   当前索引</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> limit   索引边界</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> visited</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> count, <span class=\"keyword\">int</span> idx, <span class=\"keyword\">int</span> limit, Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; visited)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(visited.containsKey(count))&#123;</span><br><span class=\"line\">            visited.get(count).add(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx &gt;= limit) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 选择当前元素</span></span><br><span class=\"line\">        dfs(nums, sum + nums[idx], count+<span class=\"number\">1</span>, idx+<span class=\"number\">1</span>, limit, visited);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 不选当前元素</span></span><br><span class=\"line\">        dfs(nums, sum, count, idx+<span class=\"number\">1</span>, limit, visited);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：smqk</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution/fen-zu-mei-ju-shuang-100-by-smqk-wnpe/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  单纯的折半查找，会 TLE 在第 175 个测试点</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> lowbit &#123;</span><br><span class=\"line\">    ($x: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $x &amp; (!$x + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">minimum_difference</span></span>(<span class=\"keyword\">mut</span> left: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = left.len() / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sum = left.iter().sum::&lt;<span class=\"built_in\">i32</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> right = left.split_off(n);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (left, right) = (Solution::to_count(&amp;left), Solution::to_count(&amp;right));</span><br><span class=\"line\">        left.iter().flat_map(|lhs| right.iter().map(<span class=\"keyword\">move</span> |rhs| (lhs, rhs)))</span><br><span class=\"line\">            .filter(|(lhs, rhs)| lhs.<span class=\"number\">0</span> + rhs.<span class=\"number\">0</span> == n <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>)    </span><br><span class=\"line\">            .fold(<span class=\"built_in\">i32</span>::MAX, |ans, (lhs, rhs)| &#123;</span><br><span class=\"line\">                lhs.<span class=\"number\">1</span>.iter().flat_map(|l| rhs.<span class=\"number\">1</span>.iter().map(<span class=\"keyword\">move</span> |r| (l, r)))</span><br><span class=\"line\">                    .fold(ans, |ans, (l, r) | &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">i32</span>::min(ans, (<span class=\"number\">2</span> * l + <span class=\"number\">2</span> * r - sum).abs())</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_count</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; HashMap&lt;<span class=\"built_in\">i32</span>, <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = vals.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> map = HashMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> mask <span class=\"keyword\">in</span> <span class=\"number\">0</span>..(<span class=\"number\">1</span> &lt;&lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> key = Solution::count_mask(mask);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> val = Solution::sum_mask(vals, mask);</span><br><span class=\"line\">            (*map.entry(key).or_insert(<span class=\"built_in\">vec!</span>[])).push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">count_mask</span></span>(<span class=\"keyword\">mut</span> mask: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> mask &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">            mask -= lowbit!(mask);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">sum_mask</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, mask: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..vals.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mask &amp; (<span class=\"number\">1</span> &lt;&lt; i) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                sum += vals[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  实际上可以二分降低复杂度。对于匹配的左侧右侧状态，如果要使得 $|lsum + rsum|$ 最小，显然是取两者符号相反，且 $|lsum|$ 和 $|rsum|$ 最接近的一组数。对于给定的 $rsum$ ，在所有 $lsum$ 里找到第一个不小于 $-rsum$ 的 $lsum$，则此时的 $lsum + rsum$ 是当前的最小值。遍历所有 $rsum$ 即可得到答案。</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> lowbit &#123;</span><br><span class=\"line\">    ($x: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $x &amp; (!$x + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">minimum_difference</span></span>(<span class=\"keyword\">mut</span> left: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = left.len() / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> right = left.split_off(n);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (left, right) = (Solution::to_count(&amp;left), Solution::to_count(&amp;right));</span><br><span class=\"line\">        left.iter().flat_map(|lhs| right.iter().map(<span class=\"keyword\">move</span> |rhs| (lhs, rhs)))</span><br><span class=\"line\">            .filter(|(lhs, rhs)| lhs.<span class=\"number\">0</span> + rhs.<span class=\"number\">0</span> == n <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>)    </span><br><span class=\"line\">            .fold(<span class=\"built_in\">i32</span>::MAX, |ans, (lhs, rhs)| &#123;</span><br><span class=\"line\">                rhs.<span class=\"number\">1</span>.iter().fold(ans, |ans, r| &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> pos = lhs.<span class=\"number\">1</span>.binary_search(&amp;-r).unwrap_or_else(|err| err);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> pos != lhs.<span class=\"number\">1</span>.len() &#123; <span class=\"built_in\">i32</span>::min(ans, r + lhs.<span class=\"number\">1</span>[pos]) &#125; <span class=\"keyword\">else</span> &#123;ans&#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_count</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; HashMap&lt;<span class=\"built_in\">i32</span>, <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = vals.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> map = HashMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> mask <span class=\"keyword\">in</span> <span class=\"number\">0</span>..(<span class=\"number\">1</span> &lt;&lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> key = Solution::count_mask(mask);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> val = Solution::sum_mask(vals, mask);</span><br><span class=\"line\">            (*map.entry(key).or_insert(<span class=\"built_in\">vec!</span>[])).push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.iter_mut().for_each(|(_, v)| v.sort());</span><br><span class=\"line\">        map</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">count_mask</span></span>(<span class=\"keyword\">mut</span> mask: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> mask &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">            mask -= lowbit!(mask);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">sum_mask</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, mask: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..vals.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mask &amp; (<span class=\"number\">1</span> &lt;&lt; i) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                sum += vals[i];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sum -= vals[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>不一定对的复杂度分析：</p>\n<ul>\n<li>不使用二分，直接折半遍历<ul>\n<li>  预处理阶段，左右各自遍历 $2^n$ 个 $mask$ 构造哈希表</li>\n<li>  遍历左侧的 $n$ 种情况，右侧的情况与之对应。设左侧取 $i$ 个数，右侧取 $n - i$ 个，则需要计算 $C_n^i C_n^{n - i}$ 次</li>\n<li>  总复杂度 $O(2^{n}) + O(\\sum_{i = 0}^n C_n^i C_n^{n - i})$ = $O(2^{n+1}) + O(\\frac{4^n\\Gamma(n + \\frac{1}{2})}{\\sqrt{\\pi} n!})$ <del>，$\\lim_{n \\to \\infty} \\frac{\\Gamma(n + \\frac{1}{2})}{\\sqrt{\\pi} n! \\sqrt n} = 0.56419$，因此该解法的复杂度比不折半低一个$O(\\sqrt n)$？</del></li>\n<li>  用 Wolfram Alpha 计算 $n = 30$ 时后半部分的求和是 $1e9$ 的 $1e8$ 倍</li>\n</ul>\n</li>\n<li>使用二分<ul>\n<li>  预处理阶段，左右各遍历 $2^n$ 个 $mask$ 构造哈希表</li>\n<li>  遍历哈希表，每一侧取 $i$ 个数时的 $C_n^i$ 种情况需要排序，合计 $2 \\sum_{i = 0}^n C_n^i\\log{C_n^i}$</li>\n<li>  遍历左侧的 $n$ 种情况，设左侧取 $i$ 个数，二分查找右侧位置，需要计算 $C_n^i\\log{C_n^{n-i}}$ 次</li>\n<li>  总复杂度 $O(2^{n}) + O(\\sum_{i = 0}^n C_n^i\\log{C_n^i})$ </li>\n<li>  用 Wolfram Alpha 计算 $n = 30$ 时后两者的比值，结果为 $4.15e6$，后半部分是 $1e9$ 的约 28 倍</li>\n</ul>\n</li>\n</ul>\n"},{"title":"LeetCode 周赛 263","date":"2021-10-17T12:16:30.000Z","_content":"\n-----\n\n# LeetCode 周赛 263\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-263/problems/check-if-numbers-are-ascending-in-a-sentence/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-263/problems/simple-bank-system/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-263/problems/count-number-of-maximum-bitwise-or-subsets/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-263/problems/second-minimum-time-to-reach-destination/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 698 / 4571 | MiracleSNeko | 12   | 0:29:14  | 0:04:25 1                                                    | 0:14:17                                                      | 0:24:14                                                      |                                                              |\n\n>字节的题出的这么简单的？\n\n## T1 5902. 检查句子中的数字是否递增\n\n-   **通过的用户数**3235\n-   **尝试过的用户数**3345\n-   **用户总通过次数**3272\n-   **用户总提交次数**4483\n-   **题目难度** **Easy**\n\n句子是由若干 **token** 组成的一个列表，**token** 间用 **单个** 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 `0-9` 组成的不含前导零的 **正整数** ，要么是一个由小写英文字母组成的 **单词** 。\n\n-   示例，`\"a puppy has 2 eyes 4 legs\"` 是一个由 7 个 token 组成的句子：`\"2\"` 和 `\"4\"` 是数字，其他像 `\"puppy\"` 这样的 tokens 属于单词。\n\n给你一个表示句子的字符串 `s` ，你需要检查 `s` 中的 **全部** 数字是否从左到右严格递增（即，除了最后一个数字，`s` 中的 **每个** 数字都严格小于它 **右侧** 的数字）。\n\n如果满足题目要求，返回 `true` ，否则，返回 `false` 。\n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/09/30/example1.png)\n\n```\n输入：s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n输出：true\n解释：句子中的数字是：1, 3, 4, 6, 12 。\n这些数字是按从左到右严格递增的 1 < 3 < 4 < 6 < 12 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"hello world 5 x 5\"\n输出：false\n解释：句子中的数字是：5, 5 。这些数字不是严格递增的。\n```\n\n**示例 3：**\n\n![example-3](https://assets.leetcode.com/uploads/2021/09/30/example3.png)\n\n```\n输入：s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"\n输出：false\n解释：s 中的数字是：7, 51, 50, 60 。这些数字不是严格递增的。\n```\n\n**示例 4：**\n\n```\n输入：s = \"4 5 11 26\"\n输出：true\n解释：s 中的数字是：4, 5, 11, 26 。\n这些数字是按从左到右严格递增的：4 < 5 < 11 < 26 。\n```\n\n**提示：**\n\n-   `3 <= s.length <= 200`\n-   `s` 由小写英文字母、空格和数字 `0` 到 `9` 组成（包含 `0` 和 `9`）\n-   `s` 中数字 token 的数目在 `2` 和 `100` 之间（包含 `2` 和 `100`）\n-   `s` 中的 token 之间由单个空格分隔\n-   `s` 中至少有 **两个** 数字\n-   `s` 中的每个数字都是一个 **小于** `100` 的 **正** 数，且不含前导零\n-   `s` 不含前导或尾随空格\n\n**我的提交：**\n\n>   我是怎么傻逼到去比较 `v.sort()` 和 `v` 是否相等的？\n\n```rust\nimpl Solution {\n    pub fn are_numbers_ascending(s: String) -> bool {\n        let v = s.split(char::is_whitespace)\n            .map(|tok| tok.parse::<i32>())\n            .filter(|p| p.is_ok())\n            .map(|tok| tok.unwrap())\n            .collect::<Vec<_>>();\n        for i in 1..v.len() {\n            if v[i-1] >= v[i] {\n                return false;\n            }\n        }\n        true\n    }\n}\n```\n\n## T2 5903. 简易银行系统\n\n-   **通过的用户数**2917\n-   **尝试过的用户数**3021\n-   **用户总通过次数**2939\n-   **用户总提交次数**4978\n-   **题目难度** **Medium**\n\n你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 `n` 个账户，编号从 `1` 到 `n` 。每个账号的初始余额存储在一个下标从 **0** 开始的整数数组 `balance` 中，其中第 `(i + 1)` 个账户的初始余额是 `balance[i]` 。\n\n请你执行所有 **有效的** 交易。如果满足下面全部条件，则交易 **有效** ：\n\n-   指定的账户数量在 `1` 和 `n` 之间，且\n-   取款或者转账需要的钱的总数 **小于或者等于** 账户余额。\n\n实现 `Bank` 类：\n\n-   `Bank(long[] balance)` 使用下标从 **0** 开始的整数数组 `balance` 初始化该对象。\n-   `boolean transfer(int account1, int account2, long money)` 从编号为 `account1` 的账户向编号为 `account2` 的账户转帐 `money` 美元。如果交易成功，返回 `true` ，否则，返回 `false` 。\n-   `boolean deposit(int account, long money)` 向编号为 `account` 的账户存款 `money` 美元。如果交易成功，返回 `true` ；否则，返回 `false` 。\n-   `boolean withdraw(int account, long money)` 从编号为 `account` 的账户取款 `money` 美元。如果交易成功，返回 `true` ；否则，返回 `false` 。\n\n**示例：**\n\n```\n输入：\n[\"Bank\", \"withdraw\", \"transfer\", \"deposit\", \"transfer\", \"withdraw\"]\n[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]\n输出：\n[null, true, true, true, false, false]\n\n解释：\nBank bank = new Bank([10, 100, 20, 50, 30]);\nbank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。\n                         // 账户 3 余额为 $20 - $10 = $10 。\nbank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。\n                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。\nbank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。\n                         // 账户 5 的余额为 $10 + $20 = $30 。\nbank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。\n                         // 所以无法转账 $15 。\nbank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。\n```\n\n**提示：**\n\n-   `n == balance.length`\n-   `1 <= n, account, account1, account2 <= 105`\n-   `0 <= balance[i], money <= 1012`\n-   `transfer`, `deposit`, `withdraw` 三个函数，**每个** 最多调用 `104` 次\n\n**我的提交：**\n\n>   手速模拟，真的有 medium 的难度么？\n\n```rust\nstruct Bank {\n    balance : Vec<i64>\n}\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Bank {\n    fn new(mut balance: Vec<i64>) -> Self {\n        let mut vec = vec![0i64];\n        vec.append(&mut balance);\n        Self {\n            balance: vec\n        }\n    }\n\n    fn transfer(&mut self, account1: i32, account2: i32, money: i64) -> bool {\n        if self.check_bound(account1) && self.check_bound(account2) {\n            if self.check_balance(account1, money) {\n                self.balance[account1 as usize] -= money;\n                self.balance[account2 as usize] += money;\n                return true;\n            }\n        }\n        false\n    }\n\n    fn deposit(&mut self, account: i32, money: i64) -> bool {\n        if self.check_bound(account) {\n            self.balance[account as usize] += money;\n            return true;\n        }\n        false\n    }\n\n    fn withdraw(&mut self, account: i32, money: i64) -> bool {\n        if self.check_bound(account) && self.check_balance(account, money) {\n            self.balance[account as usize] -= money;\n            return true;\n        }\n        false\n    }\n\n    fn check_bound(&self, account: i32) -> bool {\n        self.balance.len() > account as usize && account > 0\n    }\n\n    fn check_balance(&self, account: i32, money: i64) -> bool {\n        self.balance[account as usize] >= money\n    }\n}\n```\n\n## T3 5904. 统计按位或能得到最大值的子集数目\n\n-   **通过的用户数**2029\n-   **尝试过的用户数**2202\n-   **用户总通过次数**2093\n-   **用户总提交次数**2804\n-   **题目难度** **Medium**\n\n给你一个整数数组 `nums` ，请你找出 `nums` 子集 **按位或** 可能得到的 **最大值** ，并返回按位或能得到最大值的 **不同非空子集的数目** 。\n\n如果数组 `a` 可以由数组 `b` 删除一些元素（或不删除）得到，则认为数组 `a` 是数组 `b` 的一个 **子集** 。如果选中的元素下标位置不一样，则认为两个子集 **不同** 。\n\n对数组 `a` 执行 **按位或** ，结果等于 `a[0] OR a[1] OR ... OR a[a.length - 1]`（下标从 **0** 开始）。\n\n**示例 1：**\n\n```\n输入：nums = [3,1]\n输出：2\n解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：\n- [3]\n- [3,1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,2,2]\n输出：7\n解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1,5]\n输出：6\n解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 16`\n-   `1 <= nums[i] <= 105`\n\n**我的提交：**\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::convert::{From, Into, TryFrom, TryInto};\n// use std::io;\nuse std::marker::PhantomData;\nuse std::rc::Rc;\n\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\n\nimpl Solution {\n    pub fn count_max_or_subsets(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let s = (1 << n) - 1;\n        let mut mp = HashMap::new(); // or, cnt\n        for ss in 1..=s {\n            if ss | s != s {\n                continue;\n            }\n            let or = Solution::get_xor_by_mask(&nums, ss);\n            map_or_insert!(mp, or, |x: &mut i32| *x += 1, 1);\n        }\n        let mut vec = mp.into_iter().collect::<Vec<_>>();\n        vec.sort_by(|lhs, rhs| rhs.0.cmp(&lhs.0));\n        vec[0].1\n    }\n\n    fn get_xor_by_mask(nums: &Vec<i32>, mask: i32) -> i32 {\n        let mut ret = 0;\n        for i in 0..20 {\n            if mask & (1 << i) != 0 {\n                ret |= nums[i as usize];\n            }\n        }\n        ret\n    }\n}\n```\n\n## T4 5905. 到达目的地的第二短时间\n\n-   **通过的用户数**340\n-   **尝试过的用户数**709\n-   **用户总通过次数**432\n-   **用户总提交次数**1943\n-   **题目难度** **Hard**\n\n城市用一个 **双向连通** 图表示，图中有 `n` 个节点，从 `1` 到 `n` 编号（包含 `1` 和 `n`）。图中的边用一个二维整数数组 `edges` 表示，其中每个 `edges[i] = [ui, vi]` 表示一条节点 `ui` 和节点 `vi` 之间的双向连通边。每组节点对由 **最多一条** 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 `time` 分钟。\n\n每个节点都有一个交通信号灯，每 `change` 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 **同时** 改变。你可以在 **任何时候** 进入某个节点，但是 **只能** 在节点 **信号灯是绿色时** 才能离开。如果信号灯是 **绿色** ，你 **不能** 在节点等待，必须离开。\n\n**第二小的值** 是 **严格大于** 最小值的所有值中最小的值。\n\n-   例如，`[2, 3, 4]` 中第二小的值是 `3` ，而 `[2, 2, 4]` 中第二小的值是 `4` 。\n\n给你 `n`、`edges`、`time` 和 `change` ，返回从节点 `1` 到节点 `n` 需要的 **第二短时间** 。\n\n**注意：**\n\n-   你可以 **任意次** 穿过任意顶点，**包括** `1` 和 `n` 。\n-   你可以假设在 **启程时** ，所有信号灯刚刚变成 **绿色** 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/29/e1.png)       ![img](https://assets.leetcode.com/uploads/2021/09/29/e2.png)\n\n```\n输入：n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\n输出：13\n解释：\n上面的左图展现了给出的城市交通图。\n右图中的蓝色路径是最短时间路径。\n花费的时间是：\n- 从节点 1 开始，总花费时间=0\n- 1 -> 4：3 分钟，总花费时间=3\n- 4 -> 5：3 分钟，总花费时间=6\n因此需要的最小时间是 6 分钟。\n\n右图中的红色路径是第二短时间路径。\n- 从节点 1 开始，总花费时间=0\n- 1 -> 3：3 分钟，总花费时间=3\n- 3 -> 4：3 分钟，总花费时间=6\n- 在节点 4 等待 4 分钟，总花费时间=10\n- 4 -> 5：3 分钟，总花费时间=13\n因此第二短时间是 13 分钟。      \n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/29/eg2.png)\n\n```\n输入：n = 2, edges = [[1,2]], time = 3, change = 2\n输出：11\n解释：\n最短时间路径是 1 -> 2 ，总花费时间 = 3 分钟\n最短时间路径是 1 -> 2 -> 1 -> 2 ，总花费时间 = 11 分钟\n```\n\n \n\n**提示：**\n\n-   `2 <= n <= 104`\n-   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n-   `edges[i].length == 2`\n-   `1 <= ui, vi <= n`\n-   `ui != vi`\n-   不含重复边\n-   每个节点都可以从其他节点直接或者间接到达\n-   `1 <= time, change <= 103`\n\n**思路：**\n\n群里大佬说可以每个点维护两个不同的到达时间值，做两次 bfs 即可。有空再做。\n\n>   2021-11-14 备注：兔子在京亲爹那本挑战程序设计竞赛上的原题改进版\n","source":"_posts/weekly-contest-263.md","raw":"---\ntitle: LeetCode 周赛 263\ndate: 2021-10-17 20:16:30\ntags: LeetCode 周赛总结\n---\n\n-----\n\n# LeetCode 周赛 263\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-263/problems/check-if-numbers-are-ascending-in-a-sentence/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-263/problems/simple-bank-system/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-263/problems/count-number-of-maximum-bitwise-or-subsets/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-263/problems/second-minimum-time-to-reach-destination/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 698 / 4571 | MiracleSNeko | 12   | 0:29:14  | 0:04:25 1                                                    | 0:14:17                                                      | 0:24:14                                                      |                                                              |\n\n>字节的题出的这么简单的？\n\n## T1 5902. 检查句子中的数字是否递增\n\n-   **通过的用户数**3235\n-   **尝试过的用户数**3345\n-   **用户总通过次数**3272\n-   **用户总提交次数**4483\n-   **题目难度** **Easy**\n\n句子是由若干 **token** 组成的一个列表，**token** 间用 **单个** 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 `0-9` 组成的不含前导零的 **正整数** ，要么是一个由小写英文字母组成的 **单词** 。\n\n-   示例，`\"a puppy has 2 eyes 4 legs\"` 是一个由 7 个 token 组成的句子：`\"2\"` 和 `\"4\"` 是数字，其他像 `\"puppy\"` 这样的 tokens 属于单词。\n\n给你一个表示句子的字符串 `s` ，你需要检查 `s` 中的 **全部** 数字是否从左到右严格递增（即，除了最后一个数字，`s` 中的 **每个** 数字都严格小于它 **右侧** 的数字）。\n\n如果满足题目要求，返回 `true` ，否则，返回 `false` 。\n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/09/30/example1.png)\n\n```\n输入：s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n输出：true\n解释：句子中的数字是：1, 3, 4, 6, 12 。\n这些数字是按从左到右严格递增的 1 < 3 < 4 < 6 < 12 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"hello world 5 x 5\"\n输出：false\n解释：句子中的数字是：5, 5 。这些数字不是严格递增的。\n```\n\n**示例 3：**\n\n![example-3](https://assets.leetcode.com/uploads/2021/09/30/example3.png)\n\n```\n输入：s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"\n输出：false\n解释：s 中的数字是：7, 51, 50, 60 。这些数字不是严格递增的。\n```\n\n**示例 4：**\n\n```\n输入：s = \"4 5 11 26\"\n输出：true\n解释：s 中的数字是：4, 5, 11, 26 。\n这些数字是按从左到右严格递增的：4 < 5 < 11 < 26 。\n```\n\n**提示：**\n\n-   `3 <= s.length <= 200`\n-   `s` 由小写英文字母、空格和数字 `0` 到 `9` 组成（包含 `0` 和 `9`）\n-   `s` 中数字 token 的数目在 `2` 和 `100` 之间（包含 `2` 和 `100`）\n-   `s` 中的 token 之间由单个空格分隔\n-   `s` 中至少有 **两个** 数字\n-   `s` 中的每个数字都是一个 **小于** `100` 的 **正** 数，且不含前导零\n-   `s` 不含前导或尾随空格\n\n**我的提交：**\n\n>   我是怎么傻逼到去比较 `v.sort()` 和 `v` 是否相等的？\n\n```rust\nimpl Solution {\n    pub fn are_numbers_ascending(s: String) -> bool {\n        let v = s.split(char::is_whitespace)\n            .map(|tok| tok.parse::<i32>())\n            .filter(|p| p.is_ok())\n            .map(|tok| tok.unwrap())\n            .collect::<Vec<_>>();\n        for i in 1..v.len() {\n            if v[i-1] >= v[i] {\n                return false;\n            }\n        }\n        true\n    }\n}\n```\n\n## T2 5903. 简易银行系统\n\n-   **通过的用户数**2917\n-   **尝试过的用户数**3021\n-   **用户总通过次数**2939\n-   **用户总提交次数**4978\n-   **题目难度** **Medium**\n\n你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 `n` 个账户，编号从 `1` 到 `n` 。每个账号的初始余额存储在一个下标从 **0** 开始的整数数组 `balance` 中，其中第 `(i + 1)` 个账户的初始余额是 `balance[i]` 。\n\n请你执行所有 **有效的** 交易。如果满足下面全部条件，则交易 **有效** ：\n\n-   指定的账户数量在 `1` 和 `n` 之间，且\n-   取款或者转账需要的钱的总数 **小于或者等于** 账户余额。\n\n实现 `Bank` 类：\n\n-   `Bank(long[] balance)` 使用下标从 **0** 开始的整数数组 `balance` 初始化该对象。\n-   `boolean transfer(int account1, int account2, long money)` 从编号为 `account1` 的账户向编号为 `account2` 的账户转帐 `money` 美元。如果交易成功，返回 `true` ，否则，返回 `false` 。\n-   `boolean deposit(int account, long money)` 向编号为 `account` 的账户存款 `money` 美元。如果交易成功，返回 `true` ；否则，返回 `false` 。\n-   `boolean withdraw(int account, long money)` 从编号为 `account` 的账户取款 `money` 美元。如果交易成功，返回 `true` ；否则，返回 `false` 。\n\n**示例：**\n\n```\n输入：\n[\"Bank\", \"withdraw\", \"transfer\", \"deposit\", \"transfer\", \"withdraw\"]\n[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]\n输出：\n[null, true, true, true, false, false]\n\n解释：\nBank bank = new Bank([10, 100, 20, 50, 30]);\nbank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。\n                         // 账户 3 余额为 $20 - $10 = $10 。\nbank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。\n                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。\nbank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。\n                         // 账户 5 的余额为 $10 + $20 = $30 。\nbank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。\n                         // 所以无法转账 $15 。\nbank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。\n```\n\n**提示：**\n\n-   `n == balance.length`\n-   `1 <= n, account, account1, account2 <= 105`\n-   `0 <= balance[i], money <= 1012`\n-   `transfer`, `deposit`, `withdraw` 三个函数，**每个** 最多调用 `104` 次\n\n**我的提交：**\n\n>   手速模拟，真的有 medium 的难度么？\n\n```rust\nstruct Bank {\n    balance : Vec<i64>\n}\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Bank {\n    fn new(mut balance: Vec<i64>) -> Self {\n        let mut vec = vec![0i64];\n        vec.append(&mut balance);\n        Self {\n            balance: vec\n        }\n    }\n\n    fn transfer(&mut self, account1: i32, account2: i32, money: i64) -> bool {\n        if self.check_bound(account1) && self.check_bound(account2) {\n            if self.check_balance(account1, money) {\n                self.balance[account1 as usize] -= money;\n                self.balance[account2 as usize] += money;\n                return true;\n            }\n        }\n        false\n    }\n\n    fn deposit(&mut self, account: i32, money: i64) -> bool {\n        if self.check_bound(account) {\n            self.balance[account as usize] += money;\n            return true;\n        }\n        false\n    }\n\n    fn withdraw(&mut self, account: i32, money: i64) -> bool {\n        if self.check_bound(account) && self.check_balance(account, money) {\n            self.balance[account as usize] -= money;\n            return true;\n        }\n        false\n    }\n\n    fn check_bound(&self, account: i32) -> bool {\n        self.balance.len() > account as usize && account > 0\n    }\n\n    fn check_balance(&self, account: i32, money: i64) -> bool {\n        self.balance[account as usize] >= money\n    }\n}\n```\n\n## T3 5904. 统计按位或能得到最大值的子集数目\n\n-   **通过的用户数**2029\n-   **尝试过的用户数**2202\n-   **用户总通过次数**2093\n-   **用户总提交次数**2804\n-   **题目难度** **Medium**\n\n给你一个整数数组 `nums` ，请你找出 `nums` 子集 **按位或** 可能得到的 **最大值** ，并返回按位或能得到最大值的 **不同非空子集的数目** 。\n\n如果数组 `a` 可以由数组 `b` 删除一些元素（或不删除）得到，则认为数组 `a` 是数组 `b` 的一个 **子集** 。如果选中的元素下标位置不一样，则认为两个子集 **不同** 。\n\n对数组 `a` 执行 **按位或** ，结果等于 `a[0] OR a[1] OR ... OR a[a.length - 1]`（下标从 **0** 开始）。\n\n**示例 1：**\n\n```\n输入：nums = [3,1]\n输出：2\n解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：\n- [3]\n- [3,1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,2,2]\n输出：7\n解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,2,1,5]\n输出：6\n解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 16`\n-   `1 <= nums[i] <= 105`\n\n**我的提交：**\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::convert::{From, Into, TryFrom, TryInto};\n// use std::io;\nuse std::marker::PhantomData;\nuse std::rc::Rc;\n\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\n\nimpl Solution {\n    pub fn count_max_or_subsets(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let s = (1 << n) - 1;\n        let mut mp = HashMap::new(); // or, cnt\n        for ss in 1..=s {\n            if ss | s != s {\n                continue;\n            }\n            let or = Solution::get_xor_by_mask(&nums, ss);\n            map_or_insert!(mp, or, |x: &mut i32| *x += 1, 1);\n        }\n        let mut vec = mp.into_iter().collect::<Vec<_>>();\n        vec.sort_by(|lhs, rhs| rhs.0.cmp(&lhs.0));\n        vec[0].1\n    }\n\n    fn get_xor_by_mask(nums: &Vec<i32>, mask: i32) -> i32 {\n        let mut ret = 0;\n        for i in 0..20 {\n            if mask & (1 << i) != 0 {\n                ret |= nums[i as usize];\n            }\n        }\n        ret\n    }\n}\n```\n\n## T4 5905. 到达目的地的第二短时间\n\n-   **通过的用户数**340\n-   **尝试过的用户数**709\n-   **用户总通过次数**432\n-   **用户总提交次数**1943\n-   **题目难度** **Hard**\n\n城市用一个 **双向连通** 图表示，图中有 `n` 个节点，从 `1` 到 `n` 编号（包含 `1` 和 `n`）。图中的边用一个二维整数数组 `edges` 表示，其中每个 `edges[i] = [ui, vi]` 表示一条节点 `ui` 和节点 `vi` 之间的双向连通边。每组节点对由 **最多一条** 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 `time` 分钟。\n\n每个节点都有一个交通信号灯，每 `change` 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 **同时** 改变。你可以在 **任何时候** 进入某个节点，但是 **只能** 在节点 **信号灯是绿色时** 才能离开。如果信号灯是 **绿色** ，你 **不能** 在节点等待，必须离开。\n\n**第二小的值** 是 **严格大于** 最小值的所有值中最小的值。\n\n-   例如，`[2, 3, 4]` 中第二小的值是 `3` ，而 `[2, 2, 4]` 中第二小的值是 `4` 。\n\n给你 `n`、`edges`、`time` 和 `change` ，返回从节点 `1` 到节点 `n` 需要的 **第二短时间** 。\n\n**注意：**\n\n-   你可以 **任意次** 穿过任意顶点，**包括** `1` 和 `n` 。\n-   你可以假设在 **启程时** ，所有信号灯刚刚变成 **绿色** 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/29/e1.png)       ![img](https://assets.leetcode.com/uploads/2021/09/29/e2.png)\n\n```\n输入：n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\n输出：13\n解释：\n上面的左图展现了给出的城市交通图。\n右图中的蓝色路径是最短时间路径。\n花费的时间是：\n- 从节点 1 开始，总花费时间=0\n- 1 -> 4：3 分钟，总花费时间=3\n- 4 -> 5：3 分钟，总花费时间=6\n因此需要的最小时间是 6 分钟。\n\n右图中的红色路径是第二短时间路径。\n- 从节点 1 开始，总花费时间=0\n- 1 -> 3：3 分钟，总花费时间=3\n- 3 -> 4：3 分钟，总花费时间=6\n- 在节点 4 等待 4 分钟，总花费时间=10\n- 4 -> 5：3 分钟，总花费时间=13\n因此第二短时间是 13 分钟。      \n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/09/29/eg2.png)\n\n```\n输入：n = 2, edges = [[1,2]], time = 3, change = 2\n输出：11\n解释：\n最短时间路径是 1 -> 2 ，总花费时间 = 3 分钟\n最短时间路径是 1 -> 2 -> 1 -> 2 ，总花费时间 = 11 分钟\n```\n\n \n\n**提示：**\n\n-   `2 <= n <= 104`\n-   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n-   `edges[i].length == 2`\n-   `1 <= ui, vi <= n`\n-   `ui != vi`\n-   不含重复边\n-   每个节点都可以从其他节点直接或者间接到达\n-   `1 <= time, change <= 103`\n\n**思路：**\n\n群里大佬说可以每个点维护两个不同的到达时间值，做两次 bfs 即可。有空再做。\n\n>   2021-11-14 备注：兔子在京亲爹那本挑战程序设计竞赛上的原题改进版\n","slug":"weekly-contest-263","published":1,"updated":"2021-11-17T05:21:51.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8q0000d1cy58ye0b15m","content":"<hr>\n<h1 id=\"LeetCode-周赛-263\"><a href=\"#LeetCode-周赛-263\" class=\"headerlink\" title=\"LeetCode 周赛 263\"></a>LeetCode 周赛 263</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-263/problems/check-if-numbers-are-ascending-in-a-sentence/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-263/problems/simple-bank-system/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-263/problems/count-number-of-maximum-bitwise-or-subsets/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-263/problems/second-minimum-time-to-reach-destination/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>698 / 4571</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>0:29:14</td>\n<td>0:04:25 1</td>\n<td>0:14:17</td>\n<td>0:24:14</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>字节的题出的这么简单的？</p>\n</blockquote>\n<h2 id=\"T1-5902-检查句子中的数字是否递增\"><a href=\"#T1-5902-检查句子中的数字是否递增\" class=\"headerlink\" title=\"T1 5902. 检查句子中的数字是否递增\"></a>T1 5902. 检查句子中的数字是否递增</h2><ul>\n<li>  <strong>通过的用户数</strong>3235</li>\n<li>  <strong>尝试过的用户数</strong>3345</li>\n<li>  <strong>用户总通过次数</strong>3272</li>\n<li>  <strong>用户总提交次数</strong>4483</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>句子是由若干 <strong>token</strong> 组成的一个列表，<strong>token</strong> 间用 <strong>单个</strong> 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 <code>0-9</code> 组成的不含前导零的 <strong>正整数</strong> ，要么是一个由小写英文字母组成的 <strong>单词</strong> 。</p>\n<ul>\n<li>  示例，<code>&quot;a puppy has 2 eyes 4 legs&quot;</code> 是一个由 7 个 token 组成的句子：<code>&quot;2&quot;</code> 和 <code>&quot;4&quot;</code> 是数字，其他像 <code>&quot;puppy&quot;</code> 这样的 tokens 属于单词。</li>\n</ul>\n<p>给你一个表示句子的字符串 <code>s</code> ，你需要检查 <code>s</code> 中的 <strong>全部</strong> 数字是否从左到右严格递增（即，除了最后一个数字，<code>s</code> 中的 <strong>每个</strong> 数字都严格小于它 <strong>右侧</strong> 的数字）。</p>\n<p>如果满足题目要求，返回 <code>true</code> ，否则，返回 <code>false</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/30/example1.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;1 box has 3 blue 4 red 6 green and 12 yellow marbles&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：句子中的数字是：1, 3, 4, 6, 12 。</span><br><span class=\"line\">这些数字是按从左到右严格递增的 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;hello world 5 x 5&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：句子中的数字是：5, 5 。这些数字不是严格递增的。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/30/example3.png\" alt=\"example-3\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：s 中的数字是：7, 51, 50, 60 。这些数字不是严格递增的。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;4 5 11 26&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：s 中的数字是：4, 5, 11, 26 。</span><br><span class=\"line\">这些数字是按从左到右严格递增的：4 &lt; 5 &lt; 11 &lt; 26 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>3 &lt;= s.length &lt;= 200</code></li>\n<li>  <code>s</code> 由小写英文字母、空格和数字 <code>0</code> 到 <code>9</code> 组成（包含 <code>0</code> 和 <code>9</code>）</li>\n<li>  <code>s</code> 中数字 token 的数目在 <code>2</code> 和 <code>100</code> 之间（包含 <code>2</code> 和 <code>100</code>）</li>\n<li>  <code>s</code> 中的 token 之间由单个空格分隔</li>\n<li>  <code>s</code> 中至少有 <strong>两个</strong> 数字</li>\n<li>  <code>s</code> 中的每个数字都是一个 <strong>小于</strong> <code>100</code> 的 <strong>正</strong> 数，且不含前导零</li>\n<li>  <code>s</code> 不含前导或尾随空格</li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  我是怎么傻逼到去比较 <code>v.sort()</code> 和 <code>v</code> 是否相等的？</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">are_numbers_ascending</span></span>(s: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> v = s.split(<span class=\"built_in\">char</span>::is_whitespace)</span><br><span class=\"line\">            .map(|tok| tok.parse::&lt;<span class=\"built_in\">i32</span>&gt;())</span><br><span class=\"line\">            .filter(|p| p.is_ok())</span><br><span class=\"line\">            .map(|tok| tok.unwrap())</span><br><span class=\"line\">            .collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..v.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> v[i-<span class=\"number\">1</span>] &gt;= v[i] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-5903-简易银行系统\"><a href=\"#T2-5903-简易银行系统\" class=\"headerlink\" title=\"T2 5903. 简易银行系统\"></a>T2 5903. 简易银行系统</h2><ul>\n<li>  <strong>通过的用户数</strong>2917</li>\n<li>  <strong>尝试过的用户数</strong>3021</li>\n<li>  <strong>用户总通过次数</strong>2939</li>\n<li>  <strong>用户总提交次数</strong>4978</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 <code>n</code> 个账户，编号从 <code>1</code> 到 <code>n</code> 。每个账号的初始余额存储在一个下标从 <strong>0</strong> 开始的整数数组 <code>balance</code> 中，其中第 <code>(i + 1)</code> 个账户的初始余额是 <code>balance[i]</code> 。</p>\n<p>请你执行所有 <strong>有效的</strong> 交易。如果满足下面全部条件，则交易 <strong>有效</strong> ：</p>\n<ul>\n<li>  指定的账户数量在 <code>1</code> 和 <code>n</code> 之间，且</li>\n<li>  取款或者转账需要的钱的总数 <strong>小于或者等于</strong> 账户余额。</li>\n</ul>\n<p>实现 <code>Bank</code> 类：</p>\n<ul>\n<li>  <code>Bank(long[] balance)</code> 使用下标从 <strong>0</strong> 开始的整数数组 <code>balance</code> 初始化该对象。</li>\n<li>  <code>boolean transfer(int account1, int account2, long money)</code> 从编号为 <code>account1</code> 的账户向编号为 <code>account2</code> 的账户转帐 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ，否则，返回 <code>false</code> 。</li>\n<li>  <code>boolean deposit(int account, long money)</code> 向编号为 <code>account</code> 的账户存款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n<li>  <code>boolean withdraw(int account, long money)</code> 从编号为 <code>account</code> 的账户取款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;Bank&quot;, &quot;withdraw&quot;, &quot;transfer&quot;, &quot;deposit&quot;, &quot;transfer&quot;, &quot;withdraw&quot;]</span><br><span class=\"line\">[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, true, true, true, false, false]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">Bank bank = new Bank([10, 100, 20, 50, 30]);</span><br><span class=\"line\">bank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。</span><br><span class=\"line\">                         // 账户 3 余额为 $20 - $10 = $10 。</span><br><span class=\"line\">bank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。</span><br><span class=\"line\">                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。</span><br><span class=\"line\">bank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。</span><br><span class=\"line\">                         // 账户 5 的余额为 $10 + $20 = $30 。</span><br><span class=\"line\">bank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。</span><br><span class=\"line\">                         // 所以无法转账 $15 。</span><br><span class=\"line\">bank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == balance.length</code></li>\n<li>  <code>1 &lt;= n, account, account1, account2 &lt;= 105</code></li>\n<li>  <code>0 &lt;= balance[i], money &lt;= 1012</code></li>\n<li>  <code>transfer</code>, <code>deposit</code>, <code>withdraw</code> 三个函数，<strong>每个</strong> 最多调用 <code>104</code> 次</li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  手速模拟，真的有 medium 的难度么？</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Bank</span></span> &#123;</span><br><span class=\"line\">    balance : <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i64</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Bank &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>(<span class=\"keyword\">mut</span> balance: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i64</span>&gt;) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vec = <span class=\"built_in\">vec!</span>[<span class=\"number\">0i64</span>];</span><br><span class=\"line\">        vec.append(&amp;<span class=\"keyword\">mut</span> balance);</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            balance: vec</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">transfer</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, account1: <span class=\"built_in\">i32</span>, account2: <span class=\"built_in\">i32</span>, money: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.check_bound(account1) &amp;&amp; <span class=\"keyword\">self</span>.check_bound(account2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.check_balance(account1, money) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.balance[account1 <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] -= money;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.balance[account2 <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] += money;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">deposit</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, account: <span class=\"built_in\">i32</span>, money: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.check_bound(account) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.balance[account <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] += money;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">withdraw</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, account: <span class=\"built_in\">i32</span>, money: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.check_bound(account) &amp;&amp; <span class=\"keyword\">self</span>.check_balance(account, money) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.balance[account <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] -= money;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_bound</span></span>(&amp;<span class=\"keyword\">self</span>, account: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.balance.len() &gt; account <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> &amp;&amp; account &gt; <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_balance</span></span>(&amp;<span class=\"keyword\">self</span>, account: <span class=\"built_in\">i32</span>, money: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.balance[account <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] &gt;= money</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T3-5904-统计按位或能得到最大值的子集数目\"><a href=\"#T3-5904-统计按位或能得到最大值的子集数目\" class=\"headerlink\" title=\"T3 5904. 统计按位或能得到最大值的子集数目\"></a>T3 5904. 统计按位或能得到最大值的子集数目</h2><ul>\n<li>  <strong>通过的用户数</strong>2029</li>\n<li>  <strong>尝试过的用户数</strong>2202</li>\n<li>  <strong>用户总通过次数</strong>2093</li>\n<li>  <strong>用户总提交次数</strong>2804</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的 <strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p>\n<p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p>\n<p>对数组 <code>a</code> 执行 <strong>按位或</strong> ，结果等于 <code>a[0] OR a[1] OR ... OR a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,1]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：</span><br><span class=\"line\">- [3]</span><br><span class=\"line\">- [3,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,2,2]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1,5]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：</span><br><span class=\"line\">- [3,5]</span><br><span class=\"line\">- [3,1,5]</span><br><span class=\"line\">- [3,2,5]</span><br><span class=\"line\">- [3,2,1,5]</span><br><span class=\"line\">- [2,5]</span><br><span class=\"line\">- [2,1,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 16</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::convert::&#123;<span class=\"built_in\">From</span>, <span class=\"built_in\">Into</span>, TryFrom, TryInto&#125;;</span><br><span class=\"line\"><span class=\"comment\">// use std::io;</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">count_max_or_subsets</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = nums.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> s = (<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mp = HashMap::new(); <span class=\"comment\">// or, cnt</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ss <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=s &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ss | s != s &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> or = Solution::get_xor_by_mask(&amp;nums, ss);</span><br><span class=\"line\">            map_or_insert!(mp, or, |x: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>| *x += <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vec = mp.into_iter().collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        vec.sort_by(|lhs, rhs| rhs.<span class=\"number\">0</span>.cmp(&amp;lhs.<span class=\"number\">0</span>));</span><br><span class=\"line\">        vec[<span class=\"number\">0</span>].<span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_xor_by_mask</span></span>(nums: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, mask: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">20</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mask &amp; (<span class=\"number\">1</span> &lt;&lt; i) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                ret |= nums[i <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-5905-到达目的地的第二短时间\"><a href=\"#T4-5905-到达目的地的第二短时间\" class=\"headerlink\" title=\"T4 5905. 到达目的地的第二短时间\"></a>T4 5905. 到达目的地的第二短时间</h2><ul>\n<li>  <strong>通过的用户数</strong>340</li>\n<li>  <strong>尝试过的用户数</strong>709</li>\n<li>  <strong>用户总通过次数</strong>432</li>\n<li>  <strong>用户总提交次数</strong>1943</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>城市用一个 <strong>双向连通</strong> 图表示，图中有 <code>n</code> 个节点，从 <code>1</code> 到 <code>n</code> 编号（包含 <code>1</code> 和 <code>n</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中每个 <code>edges[i] = [ui, vi]</code> 表示一条节点 <code>ui</code> 和节点 <code>vi</code> 之间的双向连通边。每组节点对由 <strong>最多一条</strong> 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 <code>time</code> 分钟。</p>\n<p>每个节点都有一个交通信号灯，每 <code>change</code> 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 <strong>同时</strong> 改变。你可以在 <strong>任何时候</strong> 进入某个节点，但是 <strong>只能</strong> 在节点 <strong>信号灯是绿色时</strong> 才能离开。如果信号灯是 <strong>绿色</strong> ，你 <strong>不能</strong> 在节点等待，必须离开。</p>\n<p><strong>第二小的值</strong> 是 <strong>严格大于</strong> 最小值的所有值中最小的值。</p>\n<ul>\n<li>  例如，<code>[2, 3, 4]</code> 中第二小的值是 <code>3</code> ，而 <code>[2, 2, 4]</code> 中第二小的值是 <code>4</code> 。</li>\n</ul>\n<p>给你 <code>n</code>、<code>edges</code>、<code>time</code> 和 <code>change</code> ，返回从节点 <code>1</code> 到节点 <code>n</code> 需要的 <strong>第二短时间</strong> 。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>  你可以 <strong>任意次</strong> 穿过任意顶点，<strong>包括</strong> <code>1</code> 和 <code>n</code> 。</li>\n<li>你可以假设在 <strong>启程时</strong> ，所有信号灯刚刚变成 <strong>绿色</strong> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/29/e1.png\" alt=\"img\">       <img src=\"https://assets.leetcode.com/uploads/2021/09/29/e2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5</span><br><span class=\"line\">输出：13</span><br><span class=\"line\">解释：</span><br><span class=\"line\">上面的左图展现了给出的城市交通图。</span><br><span class=\"line\">右图中的蓝色路径是最短时间路径。</span><br><span class=\"line\">花费的时间是：</span><br><span class=\"line\">- 从节点 1 开始，总花费时间=0</span><br><span class=\"line\">- 1 -&gt; 4：3 分钟，总花费时间=3</span><br><span class=\"line\">- 4 -&gt; 5：3 分钟，总花费时间=6</span><br><span class=\"line\">因此需要的最小时间是 6 分钟。</span><br><span class=\"line\"></span><br><span class=\"line\">右图中的红色路径是第二短时间路径。</span><br><span class=\"line\">- 从节点 1 开始，总花费时间=0</span><br><span class=\"line\">- 1 -&gt; 3：3 分钟，总花费时间=3</span><br><span class=\"line\">- 3 -&gt; 4：3 分钟，总花费时间=6</span><br><span class=\"line\">- 在节点 4 等待 4 分钟，总花费时间=10</span><br><span class=\"line\">- 4 -&gt; 5：3 分钟，总花费时间=13</span><br><span class=\"line\">因此第二短时间是 13 分钟。      </span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/29/eg2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 2, edges = [[1,2]], time = 3, change = 2</span><br><span class=\"line\">输出：11</span><br><span class=\"line\">解释：</span><br><span class=\"line\">最短时间路径是 1 -&gt; 2 ，总花费时间 = 3 分钟</span><br><span class=\"line\">最短时间路径是 1 -&gt; 2 -&gt; 1 -&gt; 2 ，总花费时间 = 11 分钟</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= n &lt;= 104</code></li>\n<li>  <code>n - 1 &lt;= edges.length &lt;= min(2 * 104, n * (n - 1) / 2)</code></li>\n<li>  <code>edges[i].length == 2</code></li>\n<li>  <code>1 &lt;= ui, vi &lt;= n</code></li>\n<li>  <code>ui != vi</code></li>\n<li>  不含重复边</li>\n<li>  每个节点都可以从其他节点直接或者间接到达</li>\n<li>  <code>1 &lt;= time, change &lt;= 103</code></li>\n</ul>\n<p><strong>思路：</strong></p>\n<p>群里大佬说可以每个点维护两个不同的到达时间值，做两次 bfs 即可。有空再做。</p>\n<blockquote>\n<p>  2021-11-14 备注：兔子在京亲爹那本挑战程序设计竞赛上的原题改进版</p>\n</blockquote>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-263\"><a href=\"#LeetCode-周赛-263\" class=\"headerlink\" title=\"LeetCode 周赛 263\"></a>LeetCode 周赛 263</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-263/problems/check-if-numbers-are-ascending-in-a-sentence/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-263/problems/simple-bank-system/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-263/problems/count-number-of-maximum-bitwise-or-subsets/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-263/problems/second-minimum-time-to-reach-destination/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>698 / 4571</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>0:29:14</td>\n<td>0:04:25 1</td>\n<td>0:14:17</td>\n<td>0:24:14</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>字节的题出的这么简单的？</p>\n</blockquote>\n<h2 id=\"T1-5902-检查句子中的数字是否递增\"><a href=\"#T1-5902-检查句子中的数字是否递增\" class=\"headerlink\" title=\"T1 5902. 检查句子中的数字是否递增\"></a>T1 5902. 检查句子中的数字是否递增</h2><ul>\n<li>  <strong>通过的用户数</strong>3235</li>\n<li>  <strong>尝试过的用户数</strong>3345</li>\n<li>  <strong>用户总通过次数</strong>3272</li>\n<li>  <strong>用户总提交次数</strong>4483</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>句子是由若干 <strong>token</strong> 组成的一个列表，<strong>token</strong> 间用 <strong>单个</strong> 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 <code>0-9</code> 组成的不含前导零的 <strong>正整数</strong> ，要么是一个由小写英文字母组成的 <strong>单词</strong> 。</p>\n<ul>\n<li>  示例，<code>&quot;a puppy has 2 eyes 4 legs&quot;</code> 是一个由 7 个 token 组成的句子：<code>&quot;2&quot;</code> 和 <code>&quot;4&quot;</code> 是数字，其他像 <code>&quot;puppy&quot;</code> 这样的 tokens 属于单词。</li>\n</ul>\n<p>给你一个表示句子的字符串 <code>s</code> ，你需要检查 <code>s</code> 中的 <strong>全部</strong> 数字是否从左到右严格递增（即，除了最后一个数字，<code>s</code> 中的 <strong>每个</strong> 数字都严格小于它 <strong>右侧</strong> 的数字）。</p>\n<p>如果满足题目要求，返回 <code>true</code> ，否则，返回 <code>false</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/30/example1.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;1 box has 3 blue 4 red 6 green and 12 yellow marbles&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：句子中的数字是：1, 3, 4, 6, 12 。</span><br><span class=\"line\">这些数字是按从左到右严格递增的 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;hello world 5 x 5&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：句子中的数字是：5, 5 。这些数字不是严格递增的。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/30/example3.png\" alt=\"example-3\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：s 中的数字是：7, 51, 50, 60 。这些数字不是严格递增的。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;4 5 11 26&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：s 中的数字是：4, 5, 11, 26 。</span><br><span class=\"line\">这些数字是按从左到右严格递增的：4 &lt; 5 &lt; 11 &lt; 26 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>3 &lt;= s.length &lt;= 200</code></li>\n<li>  <code>s</code> 由小写英文字母、空格和数字 <code>0</code> 到 <code>9</code> 组成（包含 <code>0</code> 和 <code>9</code>）</li>\n<li>  <code>s</code> 中数字 token 的数目在 <code>2</code> 和 <code>100</code> 之间（包含 <code>2</code> 和 <code>100</code>）</li>\n<li>  <code>s</code> 中的 token 之间由单个空格分隔</li>\n<li>  <code>s</code> 中至少有 <strong>两个</strong> 数字</li>\n<li>  <code>s</code> 中的每个数字都是一个 <strong>小于</strong> <code>100</code> 的 <strong>正</strong> 数，且不含前导零</li>\n<li>  <code>s</code> 不含前导或尾随空格</li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  我是怎么傻逼到去比较 <code>v.sort()</code> 和 <code>v</code> 是否相等的？</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">are_numbers_ascending</span></span>(s: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> v = s.split(<span class=\"built_in\">char</span>::is_whitespace)</span><br><span class=\"line\">            .map(|tok| tok.parse::&lt;<span class=\"built_in\">i32</span>&gt;())</span><br><span class=\"line\">            .filter(|p| p.is_ok())</span><br><span class=\"line\">            .map(|tok| tok.unwrap())</span><br><span class=\"line\">            .collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..v.len() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> v[i-<span class=\"number\">1</span>] &gt;= v[i] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-5903-简易银行系统\"><a href=\"#T2-5903-简易银行系统\" class=\"headerlink\" title=\"T2 5903. 简易银行系统\"></a>T2 5903. 简易银行系统</h2><ul>\n<li>  <strong>通过的用户数</strong>2917</li>\n<li>  <strong>尝试过的用户数</strong>3021</li>\n<li>  <strong>用户总通过次数</strong>2939</li>\n<li>  <strong>用户总提交次数</strong>4978</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 <code>n</code> 个账户，编号从 <code>1</code> 到 <code>n</code> 。每个账号的初始余额存储在一个下标从 <strong>0</strong> 开始的整数数组 <code>balance</code> 中，其中第 <code>(i + 1)</code> 个账户的初始余额是 <code>balance[i]</code> 。</p>\n<p>请你执行所有 <strong>有效的</strong> 交易。如果满足下面全部条件，则交易 <strong>有效</strong> ：</p>\n<ul>\n<li>  指定的账户数量在 <code>1</code> 和 <code>n</code> 之间，且</li>\n<li>  取款或者转账需要的钱的总数 <strong>小于或者等于</strong> 账户余额。</li>\n</ul>\n<p>实现 <code>Bank</code> 类：</p>\n<ul>\n<li>  <code>Bank(long[] balance)</code> 使用下标从 <strong>0</strong> 开始的整数数组 <code>balance</code> 初始化该对象。</li>\n<li>  <code>boolean transfer(int account1, int account2, long money)</code> 从编号为 <code>account1</code> 的账户向编号为 <code>account2</code> 的账户转帐 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ，否则，返回 <code>false</code> 。</li>\n<li>  <code>boolean deposit(int account, long money)</code> 向编号为 <code>account</code> 的账户存款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n<li>  <code>boolean withdraw(int account, long money)</code> 从编号为 <code>account</code> 的账户取款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;Bank&quot;, &quot;withdraw&quot;, &quot;transfer&quot;, &quot;deposit&quot;, &quot;transfer&quot;, &quot;withdraw&quot;]</span><br><span class=\"line\">[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, true, true, true, false, false]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">Bank bank = new Bank([10, 100, 20, 50, 30]);</span><br><span class=\"line\">bank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。</span><br><span class=\"line\">                         // 账户 3 余额为 $20 - $10 = $10 。</span><br><span class=\"line\">bank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。</span><br><span class=\"line\">                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。</span><br><span class=\"line\">bank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。</span><br><span class=\"line\">                         // 账户 5 的余额为 $10 + $20 = $30 。</span><br><span class=\"line\">bank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。</span><br><span class=\"line\">                         // 所以无法转账 $15 。</span><br><span class=\"line\">bank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == balance.length</code></li>\n<li>  <code>1 &lt;= n, account, account1, account2 &lt;= 105</code></li>\n<li>  <code>0 &lt;= balance[i], money &lt;= 1012</code></li>\n<li>  <code>transfer</code>, <code>deposit</code>, <code>withdraw</code> 三个函数，<strong>每个</strong> 最多调用 <code>104</code> 次</li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<blockquote>\n<p>  手速模拟，真的有 medium 的难度么？</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Bank</span></span> &#123;</span><br><span class=\"line\">    balance : <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i64</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Bank &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>(<span class=\"keyword\">mut</span> balance: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i64</span>&gt;) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vec = <span class=\"built_in\">vec!</span>[<span class=\"number\">0i64</span>];</span><br><span class=\"line\">        vec.append(&amp;<span class=\"keyword\">mut</span> balance);</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            balance: vec</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">transfer</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, account1: <span class=\"built_in\">i32</span>, account2: <span class=\"built_in\">i32</span>, money: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.check_bound(account1) &amp;&amp; <span class=\"keyword\">self</span>.check_bound(account2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.check_balance(account1, money) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.balance[account1 <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] -= money;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.balance[account2 <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] += money;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">deposit</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, account: <span class=\"built_in\">i32</span>, money: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.check_bound(account) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.balance[account <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] += money;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">withdraw</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, account: <span class=\"built_in\">i32</span>, money: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.check_bound(account) &amp;&amp; <span class=\"keyword\">self</span>.check_balance(account, money) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.balance[account <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] -= money;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_bound</span></span>(&amp;<span class=\"keyword\">self</span>, account: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.balance.len() &gt; account <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> &amp;&amp; account &gt; <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_balance</span></span>(&amp;<span class=\"keyword\">self</span>, account: <span class=\"built_in\">i32</span>, money: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.balance[account <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] &gt;= money</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T3-5904-统计按位或能得到最大值的子集数目\"><a href=\"#T3-5904-统计按位或能得到最大值的子集数目\" class=\"headerlink\" title=\"T3 5904. 统计按位或能得到最大值的子集数目\"></a>T3 5904. 统计按位或能得到最大值的子集数目</h2><ul>\n<li>  <strong>通过的用户数</strong>2029</li>\n<li>  <strong>尝试过的用户数</strong>2202</li>\n<li>  <strong>用户总通过次数</strong>2093</li>\n<li>  <strong>用户总提交次数</strong>2804</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的 <strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p>\n<p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p>\n<p>对数组 <code>a</code> 执行 <strong>按位或</strong> ，结果等于 <code>a[0] OR a[1] OR ... OR a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,1]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：</span><br><span class=\"line\">- [3]</span><br><span class=\"line\">- [3,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,2,2]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,1,5]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：</span><br><span class=\"line\">- [3,5]</span><br><span class=\"line\">- [3,1,5]</span><br><span class=\"line\">- [3,2,5]</span><br><span class=\"line\">- [3,2,1,5]</span><br><span class=\"line\">- [2,5]</span><br><span class=\"line\">- [2,1,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 16</code></li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p><strong>我的提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::convert::&#123;<span class=\"built_in\">From</span>, <span class=\"built_in\">Into</span>, TryFrom, TryInto&#125;;</span><br><span class=\"line\"><span class=\"comment\">// use std::io;</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">count_max_or_subsets</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = nums.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> s = (<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mp = HashMap::new(); <span class=\"comment\">// or, cnt</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ss <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=s &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ss | s != s &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> or = Solution::get_xor_by_mask(&amp;nums, ss);</span><br><span class=\"line\">            map_or_insert!(mp, or, |x: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>| *x += <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vec = mp.into_iter().collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        vec.sort_by(|lhs, rhs| rhs.<span class=\"number\">0</span>.cmp(&amp;lhs.<span class=\"number\">0</span>));</span><br><span class=\"line\">        vec[<span class=\"number\">0</span>].<span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_xor_by_mask</span></span>(nums: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, mask: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">20</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mask &amp; (<span class=\"number\">1</span> &lt;&lt; i) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                ret |= nums[i <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-5905-到达目的地的第二短时间\"><a href=\"#T4-5905-到达目的地的第二短时间\" class=\"headerlink\" title=\"T4 5905. 到达目的地的第二短时间\"></a>T4 5905. 到达目的地的第二短时间</h2><ul>\n<li>  <strong>通过的用户数</strong>340</li>\n<li>  <strong>尝试过的用户数</strong>709</li>\n<li>  <strong>用户总通过次数</strong>432</li>\n<li>  <strong>用户总提交次数</strong>1943</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>城市用一个 <strong>双向连通</strong> 图表示，图中有 <code>n</code> 个节点，从 <code>1</code> 到 <code>n</code> 编号（包含 <code>1</code> 和 <code>n</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中每个 <code>edges[i] = [ui, vi]</code> 表示一条节点 <code>ui</code> 和节点 <code>vi</code> 之间的双向连通边。每组节点对由 <strong>最多一条</strong> 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 <code>time</code> 分钟。</p>\n<p>每个节点都有一个交通信号灯，每 <code>change</code> 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 <strong>同时</strong> 改变。你可以在 <strong>任何时候</strong> 进入某个节点，但是 <strong>只能</strong> 在节点 <strong>信号灯是绿色时</strong> 才能离开。如果信号灯是 <strong>绿色</strong> ，你 <strong>不能</strong> 在节点等待，必须离开。</p>\n<p><strong>第二小的值</strong> 是 <strong>严格大于</strong> 最小值的所有值中最小的值。</p>\n<ul>\n<li>  例如，<code>[2, 3, 4]</code> 中第二小的值是 <code>3</code> ，而 <code>[2, 2, 4]</code> 中第二小的值是 <code>4</code> 。</li>\n</ul>\n<p>给你 <code>n</code>、<code>edges</code>、<code>time</code> 和 <code>change</code> ，返回从节点 <code>1</code> 到节点 <code>n</code> 需要的 <strong>第二短时间</strong> 。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>  你可以 <strong>任意次</strong> 穿过任意顶点，<strong>包括</strong> <code>1</code> 和 <code>n</code> 。</li>\n<li>你可以假设在 <strong>启程时</strong> ，所有信号灯刚刚变成 <strong>绿色</strong> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/29/e1.png\" alt=\"img\">       <img src=\"https://assets.leetcode.com/uploads/2021/09/29/e2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5</span><br><span class=\"line\">输出：13</span><br><span class=\"line\">解释：</span><br><span class=\"line\">上面的左图展现了给出的城市交通图。</span><br><span class=\"line\">右图中的蓝色路径是最短时间路径。</span><br><span class=\"line\">花费的时间是：</span><br><span class=\"line\">- 从节点 1 开始，总花费时间=0</span><br><span class=\"line\">- 1 -&gt; 4：3 分钟，总花费时间=3</span><br><span class=\"line\">- 4 -&gt; 5：3 分钟，总花费时间=6</span><br><span class=\"line\">因此需要的最小时间是 6 分钟。</span><br><span class=\"line\"></span><br><span class=\"line\">右图中的红色路径是第二短时间路径。</span><br><span class=\"line\">- 从节点 1 开始，总花费时间=0</span><br><span class=\"line\">- 1 -&gt; 3：3 分钟，总花费时间=3</span><br><span class=\"line\">- 3 -&gt; 4：3 分钟，总花费时间=6</span><br><span class=\"line\">- 在节点 4 等待 4 分钟，总花费时间=10</span><br><span class=\"line\">- 4 -&gt; 5：3 分钟，总花费时间=13</span><br><span class=\"line\">因此第二短时间是 13 分钟。      </span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/29/eg2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 2, edges = [[1,2]], time = 3, change = 2</span><br><span class=\"line\">输出：11</span><br><span class=\"line\">解释：</span><br><span class=\"line\">最短时间路径是 1 -&gt; 2 ，总花费时间 = 3 分钟</span><br><span class=\"line\">最短时间路径是 1 -&gt; 2 -&gt; 1 -&gt; 2 ，总花费时间 = 11 分钟</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= n &lt;= 104</code></li>\n<li>  <code>n - 1 &lt;= edges.length &lt;= min(2 * 104, n * (n - 1) / 2)</code></li>\n<li>  <code>edges[i].length == 2</code></li>\n<li>  <code>1 &lt;= ui, vi &lt;= n</code></li>\n<li>  <code>ui != vi</code></li>\n<li>  不含重复边</li>\n<li>  每个节点都可以从其他节点直接或者间接到达</li>\n<li>  <code>1 &lt;= time, change &lt;= 103</code></li>\n</ul>\n<p><strong>思路：</strong></p>\n<p>群里大佬说可以每个点维护两个不同的到达时间值，做两次 bfs 即可。有空再做。</p>\n<blockquote>\n<p>  2021-11-14 备注：兔子在京亲爹那本挑战程序设计竞赛上的原题改进版</p>\n</blockquote>\n"},{"title":"LeetCode 周赛 267","date":"2021-11-14T15:22:04.000Z","_content":"\n--------\n\n# LeetCode 周赛 267\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-267/problems/time-needed-to-buy-tickets/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-267/problems/reverse-nodes-in-even-length-groups/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-267/problems/decode-the-slanted-ciphertext/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-267/problems/process-restricted-friend-requests/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1279 / 4364 | MiracleSNeko | 8    | 1:10:34  | 0:07:14 2                                                    |                                                              | 1:00:34                                                      |                                                              |\n\n>   以后不强行要求的时候再原地玩链表我就是伞兵\n\n## T1 5926. 买票需要的时间\n\n-   **通过的用户数**3160\n-   **尝试过的用户数**3336\n-   **用户总通过次数**3204\n-   **用户总提交次数**5384\n-   **题目难度** **Easy**\n\n有 `n` 个人前来排队买票，其中第 `0` 人站在队伍 **最前方** ，第 `(n - 1)` 人站在队伍 **最后方** 。\n\n给你一个下标从 **0** 开始的整数数组 `tickets` ，数组长度为 `n` ，其中第 `i` 人想要购买的票数为 `tickets[i]` 。\n\n每个人买票都需要用掉 **恰好 1 秒** 。一个人 **一次只能买一张票** ，如果需要购买更多票，他必须走到 **队尾** 重新排队（**瞬间** 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 **离开** 队伍。\n\n返回位于位置 `k`（下标从 **0** 开始）的人完成买票需要的时间（以秒为单位）。\n\n**示例 1：**\n\n```\n输入：tickets = [2,3,2], k = 2\n输出：6\n解释： \n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。\n- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。\n位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。\n```\n\n**示例 2：**\n\n```\n输入：tickets = [5,1,1,1], k = 0\n输出：8\n解释：\n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。\n- 接下来的 4 轮，只有位置 0 的人在买票。\n位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。 \n```\n\n**提示：**\n\n-   `n == tickets.length`\n-   `1 <= n <= 100`\n-   `1 <= tickets[i] <= 100`\n-   `0 <= k < n`\n\n**提交：**\n\n>   目标后面的 >= 应该少算一次，吃 WA\n\n```rust\nimpl Solution {\n    pub fn time_required_to_buy(tickets: Vec<i32>, k: i32) -> i32 {\n        let kth = tickets[k as usize];\n        tickets.iter().filter(|&&i| i < kth).sum::<i32>() + kth * tickets.iter().filter(|&&i| i >= kth).count() as i32 - tickets.iter().enumerate().filter(|&(id, i)| id > k as usize && *i >= kth).count() as i32\n    }\n}\n```\n\n## T2 5927. 反转偶数长度组的节点\n\n-   **通过的用户数**1679\n-   **尝试过的用户数**2097\n-   **用户总通过次数**1699\n-   **用户总提交次数**5004\n-   **题目难度****Medium**\n\n给你一个链表的头节点 `head` 。\n\n链表中的节点 **按顺序** 划分成若干 **非空** 组，这些非空组的长度构成一个自然数序列（`1, 2, 3, 4, ...`）。一个组的 **长度** 就是组中分配到的节点数目。换句话说：\n\n-   节点 `1` 分配给第一组\n-   节点 `2` 和 `3` 分配给第二组\n-   节点 `4`、`5` 和 `6` 分配给第三组，以此类推\n\n注意，最后一组的长度可能小于或者等于 `1 + 倒数第二组的长度` 。\n\n**反转** 每个 **偶数** 长度组中的节点，并返回修改后链表的头节点 `head` 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/25/eg1.png)\n\n```\n输入：head = [5,2,6,3,9,1,7,3,8,4]\n输出：[5,6,2,3,9,1,4,8,3,7]\n解释：\n- 第一组长度为 1 ，奇数，没有发生反转。\n- 第二组长度为 2 ，偶数，节点反转。\n- 第三组长度为 3 ，奇数，没有发生反转。\n- 最后一组长度为 4 ，偶数，节点反转。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/25/eg2.png)\n\n```\n输入：head = [1,1,0,6]\n输出：[1,0,1,6]\n解释：\n- 第一组长度为 1 ，没有发生反转。\n- 第二组长度为 2 ，节点反转。\n- 最后一组长度为 1 ，没有发生反转。\n```\n\n**示例 3：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/28/eg3.png)\n\n```\n输入：head = [2,1]\n输出：[2,1]\n解释：\n- 第一组长度为 1 ，没有发生反转。\n- 最后一组长度为 1 ，没有发生反转。\n```\n\n**示例 4：**\n\n```\n输入：head = [8]\n输出：[8]\n解释：只有一个长度为 1 的组，没有发生反转。\n```\n\n \n\n**提示：**\n\n-   链表中节点数目范围是 `[1, 105]`\n-   `0 <= Node.val <= 105`\n\n**答案：**\n\n>   等我抽空给 `Option<Box<ListNode>>` 写个封装和 IntoIter。我再原地就是伞兵\n\n```rust\n\n```\n\n## T3 5928. 解码斜向换位密码\n\n-   **通过的用户数**1380\n-   **尝试过的用户数**1575\n-   **用户总通过次数**1412\n-   **用户总提交次数**3238\n-   **题目难度** **Medium**\n\n字符串 `originalText` 使用 **斜向换位密码** ，经由 **行数固定** 为 `rows` 的矩阵辅助，加密得到一个字符串 `encodedText` 。\n\n`originalText` 先按从左上到右下的方式放置到矩阵中。\n\n![img](https://assets.leetcode.com/uploads/2021/11/07/exa11.png)\n\n先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 `originalText` 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 `' '` 进行填充。矩阵的列数需满足：用 `originalText` 填充之后，最右侧列 **不为空** 。\n\n接着按行将字符附加到矩阵中，构造 `encodedText` 。\n\n![img](https://assets.leetcode.com/uploads/2021/11/07/exa12.png)\n\n先把蓝色单元格中的字符附加到 `encodedText` 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。\n\n例如，如果 `originalText = \"cipher\"` 且 `rows = 3` ，那么我们可以按下述方法将其编码：\n\n![img](https://assets.leetcode.com/uploads/2021/10/25/desc2.png)\n\n蓝色箭头标识 `originalText` 是如何放入矩阵中的，红色箭头标识形成 `encodedText` 的顺序。在上述例子中，`encodedText = \"ch  ie  pr\"` 。\n\n给你编码后的字符串 `encodedText` 和矩阵的行数 `rows` ，返回源字符串 `originalText` 。\n\n**注意：**`originalText` **不** 含任何尾随空格 `' '` 。生成的测试用例满足 **仅存在一个** 可能的 `originalText` 。\n\n \n\n**示例 1：**\n\n```\n输入：encodedText = \"ch   ie   pr\", rows = 3\n输出：\"cipher\"\n解释：此示例与问题描述中的例子相同。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/26/exam1.png)\n\n```\n输入：encodedText = \"iveo    eed   l te   olc\", rows = 4\n输出：\"i love leetcode\"\n解释：上图标识用于编码 originalText 的矩阵。 \n蓝色箭头展示如何从 encodedText 找到 originalText 。\n```\n\n**示例 3：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/26/eg2.png)\n\n```\n输入：encodedText = \"coding\", rows = 1\n输出：\"coding\"\n解释：由于只有 1 行，所以 originalText 和 encodedText 是相同的。\n```\n\n**示例 4：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/26/exam3.png)\n\n```\n输入：encodedText = \" b  ac\", rows = 2\n输出：\" abc\"\n解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。\n```\n\n \n\n**提示：**\n\n-   `0 <= encodedText.length <= 106`\n-   `encodedText` 仅由小写英文字母和 `' '` 组成\n-   `encodedText` 是对某个 **不含** 尾随空格的 `originalText` 的一个有效编码\n-   `1 <= rows <= 1000`\n-   生成的测试用例满足 **仅存在一个** 可能的 `originalText`\n\n**提交：**\n\n>   推下公式很容易发现，rows 个一组，每组两个相邻字母隔着 cols + 1，去掉末尾空格就行了\n\n```rust\nimpl Solution {\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\n        if rows == 1 {\n            encoded_text\n        } else {\n            let rows = rows as usize;\n            let cols = encoded_text.len() / rows;\n            let mut text = Vec::<u8>::new();\n            let enc = encoded_text.bytes().collect::<Vec<_>>();\n            let len = enc.len();\n            let mut i = 0usize;\n            let mut r = 0usize;\n            while i + r * (cols + 1) < len {\n                text.push(enc[i + r * (cols + 1)]);\n                i += (r + 1) / rows;\n                r = (r + 1) % rows;\n            }\n            text = text.into_iter().rev().skip_while(|&ch| ch == b' ').collect();\n            text = text.into_iter().rev().collect();\n            String::from_utf8(text).unwrap_or(String::from(\"\"))\n        }\n    }\n}\n```\n\n## T4 5929. 处理含限制条件的好友请求\n\n-   **通过的用户数**452\n-   **尝试过的用户数**663\n-   **用户总通过次数**493\n-   **用户总提交次数**1216\n-   **题目难度** **Hard**\n\n给你一个整数 `n` ，表示网络上的用户数目。每个用户按从 `0` 到 `n - 1` 进行编号。\n\n给你一个下标从 **0** 开始的二维整数数组 `restrictions` ，其中 `restrictions[i] = [xi, yi]` 意味着用户 `xi` 和用户 `yi` **不能** 成为 **朋友** ，不管是 **直接** 还是通过其他用户 **间接** 。\n\n最初，用户里没有人是其他用户的朋友。给你一个下标从 **0** 开始的二维整数数组 `requests` 表示好友请求的列表，其中 `requests[j] = [uj, vj]` 是用户 `uj` 和用户 `vj` 之间的一条好友请求。\n\n如果 `uj` 和 `vj` 可以成为 **朋友** ，那么好友请求将会 **成功** 。每个好友请求都会按列表中给出的顺序进行处理（即，`requests[j]` 会在 `requests[j + 1]` 前）。一旦请求成功，那么对所有未来的好友请求而言， `uj` 和 `vj` 将会 **成为直接朋友 。**\n\n返回一个 **布尔数组** `result` ，其中元素遵循此规则：如果第 `j` 个好友请求 **成功** ，那么 `result[j]` 就是 `true` ；否则，为 `false` 。\n\n**注意：**如果 `uj` 和 `vj` 已经是直接朋友，那么他们之间的请求将仍然 **成功** 。\n\n \n\n**示例 1：**\n\n```\n输入：n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\n输出：[true,false]\n解释：\n请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。\n```\n\n**示例 2：**\n\n```\n输入：n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\n输出：[true,false]\n解释：\n请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。\n```\n\n**示例 3：**\n\n```\n输入：n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\n输出：[true,false,true,false]\n解释：\n请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。\n请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 \n请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。\n```\n\n \n\n**提示：**\n\n-   `2 <= n <= 1000`\n-   `0 <= restrictions.length <= 1000`\n-   `restrictions[i].length == 2`\n-   `0 <= xi, yi <= n - 1`\n-   `xi != yi`\n-   `1 <= requests.length <= 1000`\n-   `requests[j].length == 2`\n-   `0 <= uj, vj <= n - 1`\n-   `uj != vj`\n\n**思路：**\n\n并查集。吃饭去了没多想就没写，抽空补上。\n","source":"_posts/weekly-contest-267.md","raw":"---\ntitle: LeetCode 周赛 267\ndate: 2021-11-14 23:22:04\ntags: LeetCode 周赛总结\n---\n\n--------\n\n# LeetCode 周赛 267\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-267/problems/time-needed-to-buy-tickets/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-267/problems/reverse-nodes-in-even-length-groups/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-267/problems/decode-the-slanted-ciphertext/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-267/problems/process-restricted-friend-requests/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1279 / 4364 | MiracleSNeko | 8    | 1:10:34  | 0:07:14 2                                                    |                                                              | 1:00:34                                                      |                                                              |\n\n>   以后不强行要求的时候再原地玩链表我就是伞兵\n\n## T1 5926. 买票需要的时间\n\n-   **通过的用户数**3160\n-   **尝试过的用户数**3336\n-   **用户总通过次数**3204\n-   **用户总提交次数**5384\n-   **题目难度** **Easy**\n\n有 `n` 个人前来排队买票，其中第 `0` 人站在队伍 **最前方** ，第 `(n - 1)` 人站在队伍 **最后方** 。\n\n给你一个下标从 **0** 开始的整数数组 `tickets` ，数组长度为 `n` ，其中第 `i` 人想要购买的票数为 `tickets[i]` 。\n\n每个人买票都需要用掉 **恰好 1 秒** 。一个人 **一次只能买一张票** ，如果需要购买更多票，他必须走到 **队尾** 重新排队（**瞬间** 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 **离开** 队伍。\n\n返回位于位置 `k`（下标从 **0** 开始）的人完成买票需要的时间（以秒为单位）。\n\n**示例 1：**\n\n```\n输入：tickets = [2,3,2], k = 2\n输出：6\n解释： \n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。\n- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。\n位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。\n```\n\n**示例 2：**\n\n```\n输入：tickets = [5,1,1,1], k = 0\n输出：8\n解释：\n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。\n- 接下来的 4 轮，只有位置 0 的人在买票。\n位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。 \n```\n\n**提示：**\n\n-   `n == tickets.length`\n-   `1 <= n <= 100`\n-   `1 <= tickets[i] <= 100`\n-   `0 <= k < n`\n\n**提交：**\n\n>   目标后面的 >= 应该少算一次，吃 WA\n\n```rust\nimpl Solution {\n    pub fn time_required_to_buy(tickets: Vec<i32>, k: i32) -> i32 {\n        let kth = tickets[k as usize];\n        tickets.iter().filter(|&&i| i < kth).sum::<i32>() + kth * tickets.iter().filter(|&&i| i >= kth).count() as i32 - tickets.iter().enumerate().filter(|&(id, i)| id > k as usize && *i >= kth).count() as i32\n    }\n}\n```\n\n## T2 5927. 反转偶数长度组的节点\n\n-   **通过的用户数**1679\n-   **尝试过的用户数**2097\n-   **用户总通过次数**1699\n-   **用户总提交次数**5004\n-   **题目难度****Medium**\n\n给你一个链表的头节点 `head` 。\n\n链表中的节点 **按顺序** 划分成若干 **非空** 组，这些非空组的长度构成一个自然数序列（`1, 2, 3, 4, ...`）。一个组的 **长度** 就是组中分配到的节点数目。换句话说：\n\n-   节点 `1` 分配给第一组\n-   节点 `2` 和 `3` 分配给第二组\n-   节点 `4`、`5` 和 `6` 分配给第三组，以此类推\n\n注意，最后一组的长度可能小于或者等于 `1 + 倒数第二组的长度` 。\n\n**反转** 每个 **偶数** 长度组中的节点，并返回修改后链表的头节点 `head` 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/25/eg1.png)\n\n```\n输入：head = [5,2,6,3,9,1,7,3,8,4]\n输出：[5,6,2,3,9,1,4,8,3,7]\n解释：\n- 第一组长度为 1 ，奇数，没有发生反转。\n- 第二组长度为 2 ，偶数，节点反转。\n- 第三组长度为 3 ，奇数，没有发生反转。\n- 最后一组长度为 4 ，偶数，节点反转。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/25/eg2.png)\n\n```\n输入：head = [1,1,0,6]\n输出：[1,0,1,6]\n解释：\n- 第一组长度为 1 ，没有发生反转。\n- 第二组长度为 2 ，节点反转。\n- 最后一组长度为 1 ，没有发生反转。\n```\n\n**示例 3：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/28/eg3.png)\n\n```\n输入：head = [2,1]\n输出：[2,1]\n解释：\n- 第一组长度为 1 ，没有发生反转。\n- 最后一组长度为 1 ，没有发生反转。\n```\n\n**示例 4：**\n\n```\n输入：head = [8]\n输出：[8]\n解释：只有一个长度为 1 的组，没有发生反转。\n```\n\n \n\n**提示：**\n\n-   链表中节点数目范围是 `[1, 105]`\n-   `0 <= Node.val <= 105`\n\n**答案：**\n\n>   等我抽空给 `Option<Box<ListNode>>` 写个封装和 IntoIter。我再原地就是伞兵\n\n```rust\n\n```\n\n## T3 5928. 解码斜向换位密码\n\n-   **通过的用户数**1380\n-   **尝试过的用户数**1575\n-   **用户总通过次数**1412\n-   **用户总提交次数**3238\n-   **题目难度** **Medium**\n\n字符串 `originalText` 使用 **斜向换位密码** ，经由 **行数固定** 为 `rows` 的矩阵辅助，加密得到一个字符串 `encodedText` 。\n\n`originalText` 先按从左上到右下的方式放置到矩阵中。\n\n![img](https://assets.leetcode.com/uploads/2021/11/07/exa11.png)\n\n先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 `originalText` 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 `' '` 进行填充。矩阵的列数需满足：用 `originalText` 填充之后，最右侧列 **不为空** 。\n\n接着按行将字符附加到矩阵中，构造 `encodedText` 。\n\n![img](https://assets.leetcode.com/uploads/2021/11/07/exa12.png)\n\n先把蓝色单元格中的字符附加到 `encodedText` 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。\n\n例如，如果 `originalText = \"cipher\"` 且 `rows = 3` ，那么我们可以按下述方法将其编码：\n\n![img](https://assets.leetcode.com/uploads/2021/10/25/desc2.png)\n\n蓝色箭头标识 `originalText` 是如何放入矩阵中的，红色箭头标识形成 `encodedText` 的顺序。在上述例子中，`encodedText = \"ch  ie  pr\"` 。\n\n给你编码后的字符串 `encodedText` 和矩阵的行数 `rows` ，返回源字符串 `originalText` 。\n\n**注意：**`originalText` **不** 含任何尾随空格 `' '` 。生成的测试用例满足 **仅存在一个** 可能的 `originalText` 。\n\n \n\n**示例 1：**\n\n```\n输入：encodedText = \"ch   ie   pr\", rows = 3\n输出：\"cipher\"\n解释：此示例与问题描述中的例子相同。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/26/exam1.png)\n\n```\n输入：encodedText = \"iveo    eed   l te   olc\", rows = 4\n输出：\"i love leetcode\"\n解释：上图标识用于编码 originalText 的矩阵。 \n蓝色箭头展示如何从 encodedText 找到 originalText 。\n```\n\n**示例 3：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/26/eg2.png)\n\n```\n输入：encodedText = \"coding\", rows = 1\n输出：\"coding\"\n解释：由于只有 1 行，所以 originalText 和 encodedText 是相同的。\n```\n\n**示例 4：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/26/exam3.png)\n\n```\n输入：encodedText = \" b  ac\", rows = 2\n输出：\" abc\"\n解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。\n```\n\n \n\n**提示：**\n\n-   `0 <= encodedText.length <= 106`\n-   `encodedText` 仅由小写英文字母和 `' '` 组成\n-   `encodedText` 是对某个 **不含** 尾随空格的 `originalText` 的一个有效编码\n-   `1 <= rows <= 1000`\n-   生成的测试用例满足 **仅存在一个** 可能的 `originalText`\n\n**提交：**\n\n>   推下公式很容易发现，rows 个一组，每组两个相邻字母隔着 cols + 1，去掉末尾空格就行了\n\n```rust\nimpl Solution {\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\n        if rows == 1 {\n            encoded_text\n        } else {\n            let rows = rows as usize;\n            let cols = encoded_text.len() / rows;\n            let mut text = Vec::<u8>::new();\n            let enc = encoded_text.bytes().collect::<Vec<_>>();\n            let len = enc.len();\n            let mut i = 0usize;\n            let mut r = 0usize;\n            while i + r * (cols + 1) < len {\n                text.push(enc[i + r * (cols + 1)]);\n                i += (r + 1) / rows;\n                r = (r + 1) % rows;\n            }\n            text = text.into_iter().rev().skip_while(|&ch| ch == b' ').collect();\n            text = text.into_iter().rev().collect();\n            String::from_utf8(text).unwrap_or(String::from(\"\"))\n        }\n    }\n}\n```\n\n## T4 5929. 处理含限制条件的好友请求\n\n-   **通过的用户数**452\n-   **尝试过的用户数**663\n-   **用户总通过次数**493\n-   **用户总提交次数**1216\n-   **题目难度** **Hard**\n\n给你一个整数 `n` ，表示网络上的用户数目。每个用户按从 `0` 到 `n - 1` 进行编号。\n\n给你一个下标从 **0** 开始的二维整数数组 `restrictions` ，其中 `restrictions[i] = [xi, yi]` 意味着用户 `xi` 和用户 `yi` **不能** 成为 **朋友** ，不管是 **直接** 还是通过其他用户 **间接** 。\n\n最初，用户里没有人是其他用户的朋友。给你一个下标从 **0** 开始的二维整数数组 `requests` 表示好友请求的列表，其中 `requests[j] = [uj, vj]` 是用户 `uj` 和用户 `vj` 之间的一条好友请求。\n\n如果 `uj` 和 `vj` 可以成为 **朋友** ，那么好友请求将会 **成功** 。每个好友请求都会按列表中给出的顺序进行处理（即，`requests[j]` 会在 `requests[j + 1]` 前）。一旦请求成功，那么对所有未来的好友请求而言， `uj` 和 `vj` 将会 **成为直接朋友 。**\n\n返回一个 **布尔数组** `result` ，其中元素遵循此规则：如果第 `j` 个好友请求 **成功** ，那么 `result[j]` 就是 `true` ；否则，为 `false` 。\n\n**注意：**如果 `uj` 和 `vj` 已经是直接朋友，那么他们之间的请求将仍然 **成功** 。\n\n \n\n**示例 1：**\n\n```\n输入：n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\n输出：[true,false]\n解释：\n请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。\n```\n\n**示例 2：**\n\n```\n输入：n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\n输出：[true,false]\n解释：\n请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。\n```\n\n**示例 3：**\n\n```\n输入：n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\n输出：[true,false,true,false]\n解释：\n请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。\n请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 \n请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。\n```\n\n \n\n**提示：**\n\n-   `2 <= n <= 1000`\n-   `0 <= restrictions.length <= 1000`\n-   `restrictions[i].length == 2`\n-   `0 <= xi, yi <= n - 1`\n-   `xi != yi`\n-   `1 <= requests.length <= 1000`\n-   `requests[j].length == 2`\n-   `0 <= uj, vj <= n - 1`\n-   `uj != vj`\n\n**思路：**\n\n并查集。吃饭去了没多想就没写，抽空补上。\n","slug":"weekly-contest-267","published":1,"updated":"2021-11-21T04:33:48.628Z","_id":"ckw3kx8q1000f1cy5ct66408j","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h1 id=\"LeetCode-周赛-267\"><a href=\"#LeetCode-周赛-267\" class=\"headerlink\" title=\"LeetCode 周赛 267\"></a>LeetCode 周赛 267</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-267/problems/time-needed-to-buy-tickets/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-267/problems/reverse-nodes-in-even-length-groups/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-267/problems/decode-the-slanted-ciphertext/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-267/problems/process-restricted-friend-requests/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1279 / 4364</td>\n<td>MiracleSNeko</td>\n<td>8</td>\n<td>1:10:34</td>\n<td>0:07:14 2</td>\n<td></td>\n<td>1:00:34</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>  以后不强行要求的时候再原地玩链表我就是伞兵</p>\n</blockquote>\n<h2 id=\"T1-5926-买票需要的时间\"><a href=\"#T1-5926-买票需要的时间\" class=\"headerlink\" title=\"T1 5926. 买票需要的时间\"></a>T1 5926. 买票需要的时间</h2><ul>\n<li>  <strong>通过的用户数</strong>3160</li>\n<li>  <strong>尝试过的用户数</strong>3336</li>\n<li>  <strong>用户总通过次数</strong>3204</li>\n<li>  <strong>用户总提交次数</strong>5384</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 <strong>最前方</strong> ，第 <code>(n - 1)</code> 人站在队伍 <strong>最后方</strong> 。</p>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p>\n<p>每个人买票都需要用掉 <strong>恰好 1 秒</strong> 。一个人 <strong>一次只能买一张票</strong> ，如果需要购买更多票，他必须走到 <strong>队尾</strong> 重新排队（<strong>瞬间</strong> 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 <strong>离开</strong> 队伍。</p>\n<p>返回位于位置 <code>k</code>（下标从 <strong>0</strong> 开始）的人完成买票需要的时间（以秒为单位）。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tickets = [2,3,2], k = 2</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释： </span><br><span class=\"line\">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。</span><br><span class=\"line\">- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。</span><br><span class=\"line\">位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tickets = [5,1,1,1], k = 0</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。</span><br><span class=\"line\">- 接下来的 4 轮，只有位置 0 的人在买票。</span><br><span class=\"line\">位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。 </span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == tickets.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 100</code></li>\n<li>  <code>1 &lt;= tickets[i] &lt;= 100</code></li>\n<li>  <code>0 &lt;= k &lt; n</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  目标后面的 &gt;= 应该少算一次，吃 WA</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">time_required_to_buy</span></span>(tickets: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> kth = tickets[k <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>];</span><br><span class=\"line\">        tickets.iter().filter(|&amp;&amp;i| i &lt; kth).sum::&lt;<span class=\"built_in\">i32</span>&gt;() + kth * tickets.iter().filter(|&amp;&amp;i| i &gt;= kth).count() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> - tickets.iter().enumerate().filter(|&amp;(id, i)| id &gt; k <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> &amp;&amp; *i &gt;= kth).count() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-5927-反转偶数长度组的节点\"><a href=\"#T2-5927-反转偶数长度组的节点\" class=\"headerlink\" title=\"T2 5927. 反转偶数长度组的节点\"></a>T2 5927. 反转偶数长度组的节点</h2><ul>\n<li>  <strong>通过的用户数</strong>1679</li>\n<li>  <strong>尝试过的用户数</strong>2097</li>\n<li>  <strong>用户总通过次数</strong>1699</li>\n<li>  <strong>用户总提交次数</strong>5004</li>\n<li>  <strong>题目难度****Medium</strong></li>\n</ul>\n<p>给你一个链表的头节点 <code>head</code> 。</p>\n<p>链表中的节点 <strong>按顺序</strong> 划分成若干 <strong>非空</strong> 组，这些非空组的长度构成一个自然数序列（<code>1, 2, 3, 4, ...</code>）。一个组的 <strong>长度</strong> 就是组中分配到的节点数目。换句话说：</p>\n<ul>\n<li>  节点 <code>1</code> 分配给第一组</li>\n<li>  节点 <code>2</code> 和 <code>3</code> 分配给第二组</li>\n<li>  节点 <code>4</code>、<code>5</code> 和 <code>6</code> 分配给第三组，以此类推</li>\n</ul>\n<p>注意，最后一组的长度可能小于或者等于 <code>1 + 倒数第二组的长度</code> 。</p>\n<p><strong>反转</strong> 每个 <strong>偶数</strong> 长度组中的节点，并返回修改后链表的头节点 <code>head</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/25/eg1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [5,2,6,3,9,1,7,3,8,4]</span><br><span class=\"line\">输出：[5,6,2,3,9,1,4,8,3,7]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 第一组长度为 1 ，奇数，没有发生反转。</span><br><span class=\"line\">- 第二组长度为 2 ，偶数，节点反转。</span><br><span class=\"line\">- 第三组长度为 3 ，奇数，没有发生反转。</span><br><span class=\"line\">- 最后一组长度为 4 ，偶数，节点反转。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/25/eg2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,1,0,6]</span><br><span class=\"line\">输出：[1,0,1,6]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 第一组长度为 1 ，没有发生反转。</span><br><span class=\"line\">- 第二组长度为 2 ，节点反转。</span><br><span class=\"line\">- 最后一组长度为 1 ，没有发生反转。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/28/eg3.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [2,1]</span><br><span class=\"line\">输出：[2,1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 第一组长度为 1 ，没有发生反转。</span><br><span class=\"line\">- 最后一组长度为 1 ，没有发生反转。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [8]</span><br><span class=\"line\">输出：[8]</span><br><span class=\"line\">解释：只有一个长度为 1 的组，没有发生反转。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  链表中节点数目范围是 <code>[1, 105]</code></li>\n<li>  <code>0 &lt;= Node.val &lt;= 105</code></li>\n</ul>\n<p><strong>答案：</strong></p>\n<blockquote>\n<p>  等我抽空给 <code>Option&lt;Box&lt;ListNode&gt;&gt;</code> 写个封装和 IntoIter。我再原地就是伞兵</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T3-5928-解码斜向换位密码\"><a href=\"#T3-5928-解码斜向换位密码\" class=\"headerlink\" title=\"T3 5928. 解码斜向换位密码\"></a>T3 5928. 解码斜向换位密码</h2><ul>\n<li>  <strong>通过的用户数</strong>1380</li>\n<li>  <strong>尝试过的用户数</strong>1575</li>\n<li>  <strong>用户总通过次数</strong>1412</li>\n<li>  <strong>用户总提交次数</strong>3238</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>字符串 <code>originalText</code> 使用 <strong>斜向换位密码</strong> ，经由 <strong>行数固定</strong> 为 <code>rows</code> 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p>\n<p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" alt=\"img\"></p>\n<p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 <code>&#39; &#39;</code> 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 <strong>不为空</strong> 。</p>\n<p>接着按行将字符附加到矩阵中，构造 <code>encodedText</code> 。</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" alt=\"img\"></p>\n<p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p>\n<p>例如，如果 <code>originalText = &quot;cipher&quot;</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" alt=\"img\"></p>\n<p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = &quot;ch  ie  pr&quot;</code> 。</p>\n<p>给你编码后的字符串 <code>encodedText</code> 和矩阵的行数 <code>rows</code> ，返回源字符串 <code>originalText</code> 。</p>\n<p><strong>注意：</strong><code>originalText</code> <strong>不</strong> 含任何尾随空格 <code>&#39; &#39;</code> 。生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：encodedText = &quot;ch   ie   pr&quot;, rows = 3</span><br><span class=\"line\">输出：&quot;cipher&quot;</span><br><span class=\"line\">解释：此示例与问题描述中的例子相同。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：encodedText = &quot;iveo    eed   l te   olc&quot;, rows = 4</span><br><span class=\"line\">输出：&quot;i love leetcode&quot;</span><br><span class=\"line\">解释：上图标识用于编码 originalText 的矩阵。 </span><br><span class=\"line\">蓝色箭头展示如何从 encodedText 找到 originalText 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：encodedText = &quot;coding&quot;, rows = 1</span><br><span class=\"line\">输出：&quot;coding&quot;</span><br><span class=\"line\">解释：由于只有 1 行，所以 originalText 和 encodedText 是相同的。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/26/exam3.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：encodedText = &quot; b  ac&quot;, rows = 2</span><br><span class=\"line\">输出：&quot; abc&quot;</span><br><span class=\"line\">解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>0 &lt;= encodedText.length &lt;= 106</code></li>\n<li>  <code>encodedText</code> 仅由小写英文字母和 <code>&#39; &#39;</code> 组成</li>\n<li>  <code>encodedText</code> 是对某个 <strong>不含</strong> 尾随空格的 <code>originalText</code> 的一个有效编码</li>\n<li>  <code>1 &lt;= rows &lt;= 1000</code></li>\n<li>  生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  推下公式很容易发现，rows 个一组，每组两个相邻字母隔着 cols + 1，去掉末尾空格就行了</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">decode_ciphertext</span></span>(encoded_text: <span class=\"built_in\">String</span>, rows: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rows == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            encoded_text</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> rows = rows <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> cols = encoded_text.len() / rows;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> text = <span class=\"built_in\">Vec</span>::&lt;<span class=\"built_in\">u8</span>&gt;::new();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> enc = encoded_text.bytes().collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> len = enc.len();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = <span class=\"number\">0usize</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> r = <span class=\"number\">0usize</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i + r * (cols + <span class=\"number\">1</span>) &lt; len &#123;</span><br><span class=\"line\">                text.push(enc[i + r * (cols + <span class=\"number\">1</span>)]);</span><br><span class=\"line\">                i += (r + <span class=\"number\">1</span>) / rows;</span><br><span class=\"line\">                r = (r + <span class=\"number\">1</span>) % rows;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            text = text.into_iter().rev().skip_while(|&amp;ch| ch == <span class=\"string\">b&#x27; &#x27;</span>).collect();</span><br><span class=\"line\">            text = text.into_iter().rev().collect();</span><br><span class=\"line\">            <span class=\"built_in\">String</span>::from_utf8(text).unwrap_or(<span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-5929-处理含限制条件的好友请求\"><a href=\"#T4-5929-处理含限制条件的好友请求\" class=\"headerlink\" title=\"T4 5929. 处理含限制条件的好友请求\"></a>T4 5929. 处理含限制条件的好友请求</h2><ul>\n<li>  <strong>通过的用户数</strong>452</li>\n<li>  <strong>尝试过的用户数</strong>663</li>\n<li>  <strong>用户总通过次数</strong>493</li>\n<li>  <strong>用户总提交次数</strong>1216</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个整数 <code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code> 进行编号。</p>\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>restrictions</code> ，其中 <code>restrictions[i] = [xi, yi]</code> 意味着用户 <code>xi</code> 和用户 <code>yi</code> <strong>不能</strong> 成为 <strong>朋友</strong> ，不管是 <strong>直接</strong> 还是通过其他用户 <strong>间接</strong> 。</p>\n<p>最初，用户里没有人是其他用户的朋友。给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [uj, vj]</code> 是用户 <code>uj</code> 和用户 <code>vj</code> 之间的一条好友请求。</p>\n<p>如果 <code>uj</code> 和 <code>vj</code> 可以成为 <strong>朋友</strong> ，那么好友请求将会 <strong>成功</strong> 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code> 前）。一旦请求成功，那么对所有未来的好友请求而言， <code>uj</code> 和 <code>vj</code> 将会 <strong>成为直接朋友 。</strong></p>\n<p>返回一个 <strong>布尔数组</strong> <code>result</code> ，其中元素遵循此规则：如果第 <code>j</code> 个好友请求 <strong>成功</strong> ，那么 <code>result[j]</code> 就是 <code>true</code> ；否则，为 <code>false</code> 。</p>\n<p><strong>注意：</strong>如果 <code>uj</code> 和 <code>vj</code> 已经是直接朋友，那么他们之间的请求将仍然 <strong>成功</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]</span><br><span class=\"line\">输出：[true,false]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 </span><br><span class=\"line\">请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]</span><br><span class=\"line\">输出：[true,false]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 </span><br><span class=\"line\">请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]</span><br><span class=\"line\">输出：[true,false,true,false]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 </span><br><span class=\"line\">请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。</span><br><span class=\"line\">请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 </span><br><span class=\"line\">请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= n &lt;= 1000</code></li>\n<li>  <code>0 &lt;= restrictions.length &lt;= 1000</code></li>\n<li>  <code>restrictions[i].length == 2</code></li>\n<li>  <code>0 &lt;= xi, yi &lt;= n - 1</code></li>\n<li>  <code>xi != yi</code></li>\n<li>  <code>1 &lt;= requests.length &lt;= 1000</code></li>\n<li>  <code>requests[j].length == 2</code></li>\n<li>  <code>0 &lt;= uj, vj &lt;= n - 1</code></li>\n<li>  <code>uj != vj</code></li>\n</ul>\n<p><strong>思路：</strong></p>\n<p>并查集。吃饭去了没多想就没写，抽空补上。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-267\"><a href=\"#LeetCode-周赛-267\" class=\"headerlink\" title=\"LeetCode 周赛 267\"></a>LeetCode 周赛 267</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-267/problems/time-needed-to-buy-tickets/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-267/problems/reverse-nodes-in-even-length-groups/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-267/problems/decode-the-slanted-ciphertext/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-267/problems/process-restricted-friend-requests/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1279 / 4364</td>\n<td>MiracleSNeko</td>\n<td>8</td>\n<td>1:10:34</td>\n<td>0:07:14 2</td>\n<td></td>\n<td>1:00:34</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>  以后不强行要求的时候再原地玩链表我就是伞兵</p>\n</blockquote>\n<h2 id=\"T1-5926-买票需要的时间\"><a href=\"#T1-5926-买票需要的时间\" class=\"headerlink\" title=\"T1 5926. 买票需要的时间\"></a>T1 5926. 买票需要的时间</h2><ul>\n<li>  <strong>通过的用户数</strong>3160</li>\n<li>  <strong>尝试过的用户数</strong>3336</li>\n<li>  <strong>用户总通过次数</strong>3204</li>\n<li>  <strong>用户总提交次数</strong>5384</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 <strong>最前方</strong> ，第 <code>(n - 1)</code> 人站在队伍 <strong>最后方</strong> 。</p>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p>\n<p>每个人买票都需要用掉 <strong>恰好 1 秒</strong> 。一个人 <strong>一次只能买一张票</strong> ，如果需要购买更多票，他必须走到 <strong>队尾</strong> 重新排队（<strong>瞬间</strong> 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 <strong>离开</strong> 队伍。</p>\n<p>返回位于位置 <code>k</code>（下标从 <strong>0</strong> 开始）的人完成买票需要的时间（以秒为单位）。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tickets = [2,3,2], k = 2</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释： </span><br><span class=\"line\">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。</span><br><span class=\"line\">- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。</span><br><span class=\"line\">位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tickets = [5,1,1,1], k = 0</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。</span><br><span class=\"line\">- 接下来的 4 轮，只有位置 0 的人在买票。</span><br><span class=\"line\">位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。 </span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == tickets.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 100</code></li>\n<li>  <code>1 &lt;= tickets[i] &lt;= 100</code></li>\n<li>  <code>0 &lt;= k &lt; n</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  目标后面的 &gt;= 应该少算一次，吃 WA</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">time_required_to_buy</span></span>(tickets: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, k: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> kth = tickets[k <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>];</span><br><span class=\"line\">        tickets.iter().filter(|&amp;&amp;i| i &lt; kth).sum::&lt;<span class=\"built_in\">i32</span>&gt;() + kth * tickets.iter().filter(|&amp;&amp;i| i &gt;= kth).count() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> - tickets.iter().enumerate().filter(|&amp;(id, i)| id &gt; k <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> &amp;&amp; *i &gt;= kth).count() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-5927-反转偶数长度组的节点\"><a href=\"#T2-5927-反转偶数长度组的节点\" class=\"headerlink\" title=\"T2 5927. 反转偶数长度组的节点\"></a>T2 5927. 反转偶数长度组的节点</h2><ul>\n<li>  <strong>通过的用户数</strong>1679</li>\n<li>  <strong>尝试过的用户数</strong>2097</li>\n<li>  <strong>用户总通过次数</strong>1699</li>\n<li>  <strong>用户总提交次数</strong>5004</li>\n<li>  <strong>题目难度****Medium</strong></li>\n</ul>\n<p>给你一个链表的头节点 <code>head</code> 。</p>\n<p>链表中的节点 <strong>按顺序</strong> 划分成若干 <strong>非空</strong> 组，这些非空组的长度构成一个自然数序列（<code>1, 2, 3, 4, ...</code>）。一个组的 <strong>长度</strong> 就是组中分配到的节点数目。换句话说：</p>\n<ul>\n<li>  节点 <code>1</code> 分配给第一组</li>\n<li>  节点 <code>2</code> 和 <code>3</code> 分配给第二组</li>\n<li>  节点 <code>4</code>、<code>5</code> 和 <code>6</code> 分配给第三组，以此类推</li>\n</ul>\n<p>注意，最后一组的长度可能小于或者等于 <code>1 + 倒数第二组的长度</code> 。</p>\n<p><strong>反转</strong> 每个 <strong>偶数</strong> 长度组中的节点，并返回修改后链表的头节点 <code>head</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/25/eg1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [5,2,6,3,9,1,7,3,8,4]</span><br><span class=\"line\">输出：[5,6,2,3,9,1,4,8,3,7]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 第一组长度为 1 ，奇数，没有发生反转。</span><br><span class=\"line\">- 第二组长度为 2 ，偶数，节点反转。</span><br><span class=\"line\">- 第三组长度为 3 ，奇数，没有发生反转。</span><br><span class=\"line\">- 最后一组长度为 4 ，偶数，节点反转。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/25/eg2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,1,0,6]</span><br><span class=\"line\">输出：[1,0,1,6]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 第一组长度为 1 ，没有发生反转。</span><br><span class=\"line\">- 第二组长度为 2 ，节点反转。</span><br><span class=\"line\">- 最后一组长度为 1 ，没有发生反转。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/28/eg3.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [2,1]</span><br><span class=\"line\">输出：[2,1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 第一组长度为 1 ，没有发生反转。</span><br><span class=\"line\">- 最后一组长度为 1 ，没有发生反转。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [8]</span><br><span class=\"line\">输出：[8]</span><br><span class=\"line\">解释：只有一个长度为 1 的组，没有发生反转。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  链表中节点数目范围是 <code>[1, 105]</code></li>\n<li>  <code>0 &lt;= Node.val &lt;= 105</code></li>\n</ul>\n<p><strong>答案：</strong></p>\n<blockquote>\n<p>  等我抽空给 <code>Option&lt;Box&lt;ListNode&gt;&gt;</code> 写个封装和 IntoIter。我再原地就是伞兵</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T3-5928-解码斜向换位密码\"><a href=\"#T3-5928-解码斜向换位密码\" class=\"headerlink\" title=\"T3 5928. 解码斜向换位密码\"></a>T3 5928. 解码斜向换位密码</h2><ul>\n<li>  <strong>通过的用户数</strong>1380</li>\n<li>  <strong>尝试过的用户数</strong>1575</li>\n<li>  <strong>用户总通过次数</strong>1412</li>\n<li>  <strong>用户总提交次数</strong>3238</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>字符串 <code>originalText</code> 使用 <strong>斜向换位密码</strong> ，经由 <strong>行数固定</strong> 为 <code>rows</code> 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p>\n<p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" alt=\"img\"></p>\n<p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 <code>&#39; &#39;</code> 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 <strong>不为空</strong> 。</p>\n<p>接着按行将字符附加到矩阵中，构造 <code>encodedText</code> 。</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" alt=\"img\"></p>\n<p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p>\n<p>例如，如果 <code>originalText = &quot;cipher&quot;</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" alt=\"img\"></p>\n<p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = &quot;ch  ie  pr&quot;</code> 。</p>\n<p>给你编码后的字符串 <code>encodedText</code> 和矩阵的行数 <code>rows</code> ，返回源字符串 <code>originalText</code> 。</p>\n<p><strong>注意：</strong><code>originalText</code> <strong>不</strong> 含任何尾随空格 <code>&#39; &#39;</code> 。生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：encodedText = &quot;ch   ie   pr&quot;, rows = 3</span><br><span class=\"line\">输出：&quot;cipher&quot;</span><br><span class=\"line\">解释：此示例与问题描述中的例子相同。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：encodedText = &quot;iveo    eed   l te   olc&quot;, rows = 4</span><br><span class=\"line\">输出：&quot;i love leetcode&quot;</span><br><span class=\"line\">解释：上图标识用于编码 originalText 的矩阵。 </span><br><span class=\"line\">蓝色箭头展示如何从 encodedText 找到 originalText 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：encodedText = &quot;coding&quot;, rows = 1</span><br><span class=\"line\">输出：&quot;coding&quot;</span><br><span class=\"line\">解释：由于只有 1 行，所以 originalText 和 encodedText 是相同的。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/26/exam3.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：encodedText = &quot; b  ac&quot;, rows = 2</span><br><span class=\"line\">输出：&quot; abc&quot;</span><br><span class=\"line\">解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>0 &lt;= encodedText.length &lt;= 106</code></li>\n<li>  <code>encodedText</code> 仅由小写英文字母和 <code>&#39; &#39;</code> 组成</li>\n<li>  <code>encodedText</code> 是对某个 <strong>不含</strong> 尾随空格的 <code>originalText</code> 的一个有效编码</li>\n<li>  <code>1 &lt;= rows &lt;= 1000</code></li>\n<li>  生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  推下公式很容易发现，rows 个一组，每组两个相邻字母隔着 cols + 1，去掉末尾空格就行了</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">decode_ciphertext</span></span>(encoded_text: <span class=\"built_in\">String</span>, rows: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rows == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            encoded_text</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> rows = rows <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> cols = encoded_text.len() / rows;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> text = <span class=\"built_in\">Vec</span>::&lt;<span class=\"built_in\">u8</span>&gt;::new();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> enc = encoded_text.bytes().collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> len = enc.len();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = <span class=\"number\">0usize</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> r = <span class=\"number\">0usize</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i + r * (cols + <span class=\"number\">1</span>) &lt; len &#123;</span><br><span class=\"line\">                text.push(enc[i + r * (cols + <span class=\"number\">1</span>)]);</span><br><span class=\"line\">                i += (r + <span class=\"number\">1</span>) / rows;</span><br><span class=\"line\">                r = (r + <span class=\"number\">1</span>) % rows;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            text = text.into_iter().rev().skip_while(|&amp;ch| ch == <span class=\"string\">b&#x27; &#x27;</span>).collect();</span><br><span class=\"line\">            text = text.into_iter().rev().collect();</span><br><span class=\"line\">            <span class=\"built_in\">String</span>::from_utf8(text).unwrap_or(<span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-5929-处理含限制条件的好友请求\"><a href=\"#T4-5929-处理含限制条件的好友请求\" class=\"headerlink\" title=\"T4 5929. 处理含限制条件的好友请求\"></a>T4 5929. 处理含限制条件的好友请求</h2><ul>\n<li>  <strong>通过的用户数</strong>452</li>\n<li>  <strong>尝试过的用户数</strong>663</li>\n<li>  <strong>用户总通过次数</strong>493</li>\n<li>  <strong>用户总提交次数</strong>1216</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个整数 <code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code> 进行编号。</p>\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>restrictions</code> ，其中 <code>restrictions[i] = [xi, yi]</code> 意味着用户 <code>xi</code> 和用户 <code>yi</code> <strong>不能</strong> 成为 <strong>朋友</strong> ，不管是 <strong>直接</strong> 还是通过其他用户 <strong>间接</strong> 。</p>\n<p>最初，用户里没有人是其他用户的朋友。给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [uj, vj]</code> 是用户 <code>uj</code> 和用户 <code>vj</code> 之间的一条好友请求。</p>\n<p>如果 <code>uj</code> 和 <code>vj</code> 可以成为 <strong>朋友</strong> ，那么好友请求将会 <strong>成功</strong> 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code> 前）。一旦请求成功，那么对所有未来的好友请求而言， <code>uj</code> 和 <code>vj</code> 将会 <strong>成为直接朋友 。</strong></p>\n<p>返回一个 <strong>布尔数组</strong> <code>result</code> ，其中元素遵循此规则：如果第 <code>j</code> 个好友请求 <strong>成功</strong> ，那么 <code>result[j]</code> 就是 <code>true</code> ；否则，为 <code>false</code> 。</p>\n<p><strong>注意：</strong>如果 <code>uj</code> 和 <code>vj</code> 已经是直接朋友，那么他们之间的请求将仍然 <strong>成功</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]</span><br><span class=\"line\">输出：[true,false]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 </span><br><span class=\"line\">请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]</span><br><span class=\"line\">输出：[true,false]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 </span><br><span class=\"line\">请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]</span><br><span class=\"line\">输出：[true,false,true,false]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 </span><br><span class=\"line\">请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。</span><br><span class=\"line\">请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 </span><br><span class=\"line\">请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= n &lt;= 1000</code></li>\n<li>  <code>0 &lt;= restrictions.length &lt;= 1000</code></li>\n<li>  <code>restrictions[i].length == 2</code></li>\n<li>  <code>0 &lt;= xi, yi &lt;= n - 1</code></li>\n<li>  <code>xi != yi</code></li>\n<li>  <code>1 &lt;= requests.length &lt;= 1000</code></li>\n<li>  <code>requests[j].length == 2</code></li>\n<li>  <code>0 &lt;= uj, vj &lt;= n - 1</code></li>\n<li>  <code>uj != vj</code></li>\n</ul>\n<p><strong>思路：</strong></p>\n<p>并查集。吃饭去了没多想就没写，抽空补上。</p>\n"},{"title":"洛谷模板题集合","date":"2021-10-09T16:01:12.000Z","_content":"\n---------\n\n# 洛谷模板题集合\n\n> 参考[这篇文章](https://www.cnblogs.com/Ender-hz/p/15018563.html)列出的题目\n\n## 0. 工具宏 & 包导入声明\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque, BTreeMap};\nuse std::convert::{From, Into, TryFrom, TryInto};\nuse std::io;\nuse std::marker::PhantomData;\nuse std::rc::Rc;\n\nmacro_rules! init_cin {\n    () => {{\n        (io::stdin(), String::new())\n    }};\n}\nmacro_rules! scanf {\n    ($buf: expr, $div: expr, $($x:ty), +) => {{\n        let mut iter = $buf.split($div);\n        ($(iter.next().and_then(|token| token.parse::<$x>().ok()), ) *)\n    }};\n}\nmacro_rules! getline {\n    ($cin: expr, $buf: expr) => {{\n        $buf.clear();\n        $cin.read_line(&mut $buf)?;\n    }};\n}\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\n```\n\n## 1. 普及-\n\n### P3367 并查集\n\n```rust\nstruct DisjointSet<T>\nwhere\n    T: Sized + Eq + Copy + TryInto<usize>,\n{\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n    phantom: PhantomData<T>,\n}\n\nimpl<T> DisjointSet<T>\nwhere\n    T: Sized + Eq + Copy + TryInto<usize>,\n{\n    pub fn with_capacity(cap: usize) -> Self {\n        Self {\n            parent: vec![usize::MAX; cap],\n            rank: vec![0; cap],\n            phantom: PhantomData,\n        }\n    }\n    pub fn modify(&mut self, x: T, p: usize) {\n        match x.try_into() {\n            Ok(x) => { self.parent[x] = p; },\n            Err(_) => panic!()\n        }\n    }\n    pub fn union(&mut self, x: T, y: T) -> bool {\n        let (mut fx, mut fy) = (self.find(x), self.find(y));\n        if fx == fy || fx == usize::MAX || fy == usize::MAX {\n            false\n        } else {\n            if self.rank[fx] > self.rank[fy] {\n                std::mem::swap(&mut fx, &mut fy);\n            }\n            self.parent[fx] = fy;\n            if self.rank[fx] == self.rank[fy] {\n                self.rank[fy] += 1;\n            }\n            true\n        }\n    }\n    pub fn find(&mut self, x: T) -> usize {\n        match x.try_into() {\n            Ok(x) => self.find_wrapper(x),\n            Err(_) => usize::MAX\n        }\n    }\n    fn find_wrapper(&mut self, x: usize) -> usize {\n        if x != self.parent[x] {\n            self.parent[x] = self.find_wrapper(self.parent[x]);\n        }\n        self.parent[x]\n    }\n}\n\nfn main() -> io::Result<()> {\n    let cin = io::stdin();\n    let mut buf = String::new();\n    getline!(cin, buf);\n    // n m\n    if let (Some(n), Some(mut m)) = scanf!(buf, char::is_whitespace, i32, i32) {\n        let mut dsj = DisjointSet::<i32>::with_capacity(n as usize + 1);\n        (1..=n).for_each(|i| dsj.modify(i, i as usize));\n        while m > 0 {\n            getline!(cin, buf);\n            if let (Some(op), Some(arg1), Some(arg2)) =\n                scanf!(buf, char::is_whitespace, i32, i32, i32)\n            {\n                match op {\n                    1 => { dsj.union(arg1, arg2); },\n                    2 => { println!(\"{:}\", if dsj.find(arg1) == dsj.find(arg2) && dsj.find(arg1) != usize::MAX {\"Y\"} else {\"N\"})},\n                    _ => unreachable!()\n                }\n            }\n            m -= 1;\n        }\n    }\n    Ok(())\n}\n```\n\n\n\n### P3371 单源最短路（非随机数据）\n\n> 看描述似乎允许 SPFA ，但是原版 SPFA 还是被卡掉了三个用例\n\n```rust\nmod my {\n    #[derive(Debug, Clone)]\n    struct LFSNode {\n        to: usize,\n        next: usize,\n        w: i32,\n    }\n    pub struct LinkedForwardStar {\n        edges: Vec<LFSNode>,\n        head: Vec<usize>,\n        tot: usize,\n    }\n    impl LinkedForwardStar {\n        pub fn with_capacity(nodes: usize, edges: usize) -> Self {\n            Self {\n                edges: vec![\n                    LFSNode {\n                        to: usize::MAX,\n                        next: usize::MAX,\n                        w: 0\n                    };\n                    edges\n                ],\n                head: vec![usize::MAX; nodes],\n                tot: 0,\n            }\n        }\n        pub fn add(&mut self, src: usize, dst: usize, weight: i32) {\n            self.edges[self.tot].next = self.head[src];\n            self.edges[self.tot].to = dst;\n            self.edges[self.tot].w = weight;\n            self.head[src] = self.tot;\n            self.tot += 1;\n        }\n    }\n    pub fn spfa_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n        let mut vis = vec![false; lfs.tot];\n        let mut dist = vec![i32::MAX; lfs.head.len()];\n        let mut queue = vec![src];\n        dist[src] = 0;\n        vis[src] = true;\n        while !queue.is_empty() {\n            let x = queue.pop().unwrap();\n            vis[x] = false;\n            let mut i = lfs.head[x];\n            while i != usize::MAX {\n                let y = lfs.edges[i].to;\n                if dist[y] - lfs.edges[i].w > dist[x] {\n                    dist[y] = dist[x] + lfs.edges[i].w;\n                    if !vis[y] {\n                        vis[y] = true;\n                        queue.push(y);\n                    }\n                }\n                i = lfs.edges[i].next;\n            }\n        }\n        dist\n    }\n    pub fn dijkstra_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n        let mut vis = vec![false; lfs.head.len()];\n        let mut dist = vec![i32::MAX; lfs.head.len()];\n        let mut x = src;\n        dist[src] = 0;\n        while !vis[x] {\n            let mut curr = i32::MAX;\n            vis[x] = true;\n            let mut y = lfs.head[x];\n            while y != usize::MAX {\n                if !vis[lfs.edges[y].to] && dist[lfs.edges[y].to] - lfs.edges[y].w > dist[x] {\n                    dist[lfs.edges[y].to] = dist[x] + lfs.edges[y].w;\n                }\n                y = lfs.edges[y].next;\n            }\n            for i in 1..lfs.head.len() {\n                if dist[i] < curr && !vis[i] {\n                    curr = dist[i];\n                    x = i;\n                }\n            }\n        }\n        dist\n    }\n}\nuse my::*;\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m), Some(src)) = scanf!(buf, char::is_whitespace, usize, usize, usize)\n    {\n        let mut lfs = LinkedForwardStar::with_capacity(n + 1, m + 1);\n        while m > 0 {\n            m -= 1;\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                lfs.add(u, v, w);\n            }\n        }\n        // spfa_solver(lfs, src)\n        dijkstra_solver(lfs, src)\n            .iter()\n            .skip(1)\n            .for_each(|i| print!(\"{:} \", i))\n    }\n    Ok(())\n}\n```\n\n\n\n### P1226 快速幂\n\n```rust\nfn fast_pow(x: i64, n: i64, m: i64) -> i64 {\n    let (mut x, mut n, mut ret) = (x, n, 1);\n    while n > 0 {\n        if (n & 1) == 1 {\n            ret *= x;\n            ret %= m;\n        }\n        x *= x;\n        x %= m;\n        n >>= 1;\n    }\n    ret % m\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(x), Some(n), Some(m)) = scanf!(buf, char::is_whitespace, i64, i64, i64) {\n        println!(\"{0}^{1} mod {2}={3}\", x, n, m, fast_pow(x, n, m));\n    }\n    Ok(())\n}\n```\n\n\n\n### P4779 单源最短路（标准）\n\n> 不优化的 Dijkstra 也寄了，堆优化的 AC\n\n```rust\n#[derive(Default, Debug, Clone)]\nstruct LFSNode {\n    to: usize,\n    next: usize,\n    w: i32,\n}\npub struct LinkedForwardStar {\n    edges: Vec<LFSNode>,\n    head: Vec<usize>,\n    tot: usize,\n}\nimpl LinkedForwardStar {\n    pub fn with_capacity(node_cap: usize, edge_cap: usize) -> Self {\n        Self {\n            edges: vec![LFSNode::default(); edge_cap],\n            head: vec![usize::MAX; node_cap],\n            tot: 0,\n        }\n    }\n    pub fn add(&mut self, src: usize, dst: usize, weight: i32) {\n        self.edges[self.tot].next = self.head[src];\n        self.edges[self.tot].to = dst;\n        self.edges[self.tot].w = weight;\n        self.head[src] = self.tot;\n        self.tot += 1;\n    }\n}\npub fn spfa_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n    let mut vis = vec![false; lfs.tot];\n    let mut dist = vec![i32::MAX; lfs.head.len()];\n    let mut queue = vec![src];\n    dist[src] = 0;\n    vis[src] = true;\n    while !queue.is_empty() {\n        let x = queue.pop().unwrap();\n        vis[x] = false;\n        let mut i = lfs.head[x];\n        while i != usize::MAX {\n            let y = lfs.edges[i].to;\n            if dist[y] - lfs.edges[i].w > dist[x] {\n                dist[y] = dist[x] + lfs.edges[i].w;\n                if !vis[y] {\n                    vis[y] = true;\n                    queue.push(y);\n                }\n            }\n            i = lfs.edges[i].next;\n        }\n    }\n    dist\n}\n/// Dijkstra with Heap optimization\npub fn dijkstra_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n    let mut vis = vec![false; lfs.head.len()];\n    let mut dist = vec![i32::MAX; lfs.head.len()];\n    let mut pq = BinaryHeap::new();\n    dist[src] = 0;\n    pq.push(Reverse((dist[src], src)));\n    while let Some(Reverse((_, u))) = pq.pop() {\n        if vis[u] {\n            continue;\n        }\n        vis[u] = true;\n        let mut e = lfs.head[u];\n        while e != usize::MAX {\n            let v = lfs.edges[e].to;\n            let w = lfs.edges[e].w;\n            if dist[v] > dist[u] + w {\n                dist[v] = dist[u] + w;\n                pq.push(Reverse((dist[v], v)));\n            }\n            e = lfs.edges[e].next;\n        }\n    }\n    dist\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m), Some(src)) = scanf!(buf, char::is_whitespace, usize, usize, usize)\n    {\n        let mut lfs = LinkedForwardStar::with_capacity(n + 1, m + 1);\n        while m > 0 {\n            m -= 1;\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                lfs.add(u, v, w);\n            }\n        }\n        // spfa_solver(lfs, src)\n        dijkstra_solver(lfs, src)\n            .iter()\n            .skip(1)\n            .for_each(|i| print!(\"{:} \", i))\n    }\n    Ok(())\n}\n```\n\n### P3383 【模板】线性筛素数\n\n```rust\nfn euler_sieve(n: usize) -> Vec<i32> {\n    let mut valid = vec![true; n + 1];\n    let mut ans = vec![0; n + 1];\n    let mut tot = 0;\n    for i in 2..=n {\n        if valid[i] {\n            tot += 1;\n            ans[tot] = i;\n        }\n        let mut j = 1;\n        while j <= tot && i * ans[j] <= n {\n            valid[i * ans[j]] = false;\n            if i % ans[j] == 0 {\n                break;\n            }\n            j += 1;\n        }\n    }\n    ans.into_iter().skip(1).take(tot).map(|i| i as i32).collect()\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut qs)) = scanf!(buf, char::is_whitespace, usize, i32) {\n        let primes = euler_sieve(n);\n        while qs > 0 {\n            getline!(cin, buf);\n            if let (Some(q),) = scanf!(buf, char::is_whitespace, usize) {\n                println!(\"{0}\", primes[q-1]);\n            }\n            qs -= 1;\n        }\n    }\n    Ok(())\n}\n```\n\n### P3366 【模板】最小生成树\n\n```rust\nstruct Edge {\n    u: usize,\n    v: usize,\n    w: i32,\n}\n\n/// Kruskal 算法\n/// 复杂度 `M \\log M`\n/// 思想：每次取剩下的边权最小的边，如果加上这条边后图中出现了一个环，就不选这条边（可以通过并查集）判断\nfn kruskal(edges: &mut Vec<Edge>, nodes_num: usize) -> i32 {\n    let mut parent = (0..=nodes_num).collect::<Vec<_>>();\n    fn find(u: usize, parent: &mut Vec<usize>) -> usize {\n        if u == parent[u] {\n            u\n        } else {\n            parent[u] = find(parent[u], parent);\n            parent[u]\n        }\n    }\n    edges.sort_by(|lhs, rhs| lhs.w.cmp(&rhs.w));\n    let mut ans = 0;\n    let mut cnt = nodes_num;\n    for i in 0..edges.len() {\n        let (p1, p2) = (find(edges[i].u, &mut parent), find(edges[i].v, &mut parent));\n        if p1 != p2 {\n            parent[p1] = p2;\n            ans += edges[i].w;\n            cnt -= 1;\n            if cnt == 1 {\n                break;\n            }\n        }\n    }\n    if cnt == 1 {\n        ans\n    } else {\n        i32::MAX\n    }\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m)) = scanf!(buf, char::is_whitespace, usize, usize) {\n        let mut edges = Vec::with_capacity(m);\n        while m > 0 {\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                edges.push(Edge { u, v, w });\n            }\n            m -= 1;\n        }\n        let ans = kruskal(&mut edges, n);\n        println!(\"{0}\", if ans == i32::MAX { \"orz\".to_string() } else { ans.to_string() });\n    }\n    Ok(())\n}\n```\n\n### P3378 【模板】堆\n\n>   不想手写，直接用了 std\n\n### P3370 【模板】字符串哈希\n\n>   交了半天都是 TLE，一开 O2 过了，烦死\n\n```rust\nfn string_hash(s: &String) -> i32 {\n    let mut hash = s.chars()\n        .fold(0, |mut hash: i32, ch| {\n            hash = hash.wrapping_add(ch as i32);\n            hash = hash.wrapping_add(hash.wrapping_shl(10));\n            hash ^= hash.wrapping_shr(6);\n            hash\n        });\n    hash = hash.wrapping_add(hash.wrapping_shl(3));\n    hash ^= hash.wrapping_shr(11);\n    hash = hash.wrapping_add(hash.wrapping_shl(15));\n    hash\n}\n\n/*\nconst MOD: usize = 2147483647;\nconst POW: usize = 257;\n\nfn string_hash(s: &String) -> usize {\n    s.chars()\n        .fold(0, |hash, ch| (hash * POW + (ch as usize)) % MOD)\n}\n*/\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n),) = scanf!(buf, char::is_whitespace, usize) {\n        let mut bucket = vec![0; n];\n        let mut i = 0usize;\n        let mut ans = n;\n        while i < n {\n            getline!(cin, buf);\n            bucket[i] = string_hash(&buf);\n            i += 1;\n        }\n        bucket.sort();\n        (1..n).for_each(|i| if bucket[i] == bucket[i - 1] { ans -= 1 } );\n        println!(\"{0}\", ans);\n    }\n    Ok(())\n}\n```\n\n### P1177 【模板】快速排序\n\n```rust\n/*\nfn sort(vals: &mut Vec<i32>, l: usize, r: usize) {\n    if r - l > 10 {\n        quick_sort(vals, l, r);\n    } else {\n        insert_sort(vals, l, r);\n    }\n}\n*/\n\nfn quick_sort(vals: &mut Vec<i32>, l: usize, r: usize) {\n    if l >= r {\n        return;\n    }\n    let mut i = l;\n    let mut j = r;\n    let pivot = vals[((l + r) >> 1) as usize];\n    while i <= j {\n        while pivot > vals[i] {\n            i += 1;\n        }\n        while pivot < vals[j] {\n            j -= 1;\n        }\n        if i <= j {\n            let tmp = vals[i];\n            vals[i] = vals[j];\n            vals[j] = tmp;\n            i += 1;\n            j -= 1;\n        }\n    }\n    quick_sort(vals, l, j);\n    quick_sort(vals, i, r);\n}\n\n/*\nfn insert_sort(vals: &mut Vec<i32>, l: usize, r: usize) {\n    for i in l..=r {\n        let mut j = i;\n        let pivot = vals[i];\n        while j >= 1 && vals[j - 1] > pivot {\n            vals[j] = vals[j - 1];\n            j -= 1;\n        }\n        vals[j] = pivot;\n    }\n}\n*/\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n),) = scanf!(buf, char::is_whitespace, usize) {\n        getline!(cin, buf);\n        let mut vals = buf\n            .split(char::is_whitespace)\n            .map(|i| i.parse::<i32>())\n            .filter(|i| i.is_ok())\n            .map(|i| i.unwrap())\n            .collect::<Vec<_>>();\n        let len = vals.len();\n        assert_eq!(len, n);\n        let len = vals.len();\n        quick_sort(&mut vals, 0, len - 1);\n        vals.iter().for_each(|i| print!(\"{0} \", i));\n    }\n    Ok(())\n}\n```\n\n普及 / 提高-\nP1886 【模板】单调队列 / 滑动窗口\nP3382 【模板】三分法\nP3374 【模板】树状数组 1\nP3811 【模板】乘法逆元\nP3372 【模板】线段树 1\nP3375 【模板】KMP字符串匹配\nP3368 【模板】树状数组 2\nP3379 【模板】最近公共祖先（LCA）\nP1939 【模板】矩阵加速（数列）\nP3385 【模板】负环\nP3865 【模板】ST 表\nP3390 【模板】矩阵快速幂\nP4549 【模板】裴蜀定理\nP4779 【模板】单源最短路径（标准版）\nP5788 【模板】单调栈\n普及+ / 提高\nP5431 【模板】乘法逆元2\nP5367 【模板】康托展开\nP5960 【模板】差分约束算法\nP2613 【模板】有理数取余\nP2252 【模板】威佐夫博弈 / [SHOI2002] 取石子游戏\nP3373 【模板】线段树 2\nP5905 【模板】Johnson 全源最短路\nP2197 【模板】nim 游戏\nP3387 【模板】缩点\nP1439 【模板】最长公共子序列\nP3386 【模板】二分图最大匹配\nP3388 【模板】割点（割顶）\nP5656 【模板】二元一次不定方程 (exgcd)\n提高+ / 省选-\nP3377 【模板】左偏树（可并堆）\nP3381 【模板】最小费用最大流\nP3369 【模板】普通平衡树\nP6091 【模板】原根\nP4781 【模板】拉格朗日插值\nP5903 【模板】树上 k 级祖先\nP5854 【模板】笛卡尔树\nP6086 【模板】Prufer 序列\nP1368 【模板】最小表示法\nP5632 【模板】Stoer-Wagner算法\nP5490 【模板】扫描线\nP3805 【模板】manacher 算法\nP1495 【模板】中国剩余定理(CRT)/曹冲养猪\nP2742 【模板】二维凸包 / [USACO5.1]圈奶牛Fencing the Cows\nP3389 【模板】高斯消元法\nP4783 【模板】矩阵求逆\nP3796 【模板】AC自动机（加强版）\nP3808 【模板】AC自动机（简单版）\nP5826 【模板】子序列自动机\nP3846 【模板】BSGS / [TJOI2007] 可爱的质数\nP3376 【模板】网络最大流\nP3391 【模板】文艺平衡树\nP5091 【模板】扩展欧拉定理\nP3807 【模板】卢卡斯定理/Lucas 定理\nP3384 【模板】轻重链剖分/树链剖分\nP3812 【模板】线性基\nP3919 【模板】可持久化线段树 1（可持久化数组）\nP3834 【模板】可持久化线段树 2（主席树）\nP7112 【模板】行列式求值\nP1919 【模板】A*B Problem升级版（FFT快速傅里叶）\nP3803 【模板】多项式乘法（FFT）\nP4525 【模板】自适应辛普森法1\n省选 / NOI-\nP4196 【模板】半平面交 / [CQOI2006]凸多边形\nP1452 【模板】旋转卡壳 / [USACO03FALL]Beauty Contest G\nP3809 【模板】后缀排序\nP6177 【模板】树分块 / Count on a tree II\nP5906 【模板】回滚莫队&不删除莫队\nP4782 【模板】2-SAT 问题\nP5357 【模板】AC自动机（二次加强版）\nP4719 【模板】\"动态 DP\"&动态树分治\nP5055 【模板】可持久化文艺平衡树\nP5236 【模板】静态仙人掌\nP5394 【模板】下降幂多项式乘法\nP5496 【模板】回文自动机（PAM）\nP5494 【模板】线段树分裂\nP6136 【模板】普通平衡树（数据加强版）\nP6114 【模板】Lyndon 分解\nP5807 【模板】BEST 定理 / Which Dreamed It\nP6139 【模板】广义后缀自动机（广义 SAM）\nP6329 【模板】点分树 | 震波\nP4213 【模板】杜教筛（Sum）\nP4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)\nP5043 【模板】树同构 / [BJOI2015] 树的同构\nP5192 【模板】有源汇上下界最大流 / Zoj3229 Shoot the Bullet|东方文花帖|\nP5491 【模板】二次剩余\nP3804 【模板】后缀自动机 (SAM)\nP3810 【模板】三维偏序（陌上花开）\nP4526 【模板】自适应辛普森法2\nP4777 【模板】扩展中国剩余定理（EXCRT）\nP4716 【模板】最小树形图\nP4718 【模板】Pollard-Rho算法\nP4725 【模板】多项式对数函数（多项式 ln）\nP4929 【模板】舞蹈链（DLX）\nP5787 【模板】线段树分治 / 二分图\nP6113 【模板】一般图最大匹配\nP3835 【模板】可持久化平衡树\nP4195 【模板】扩展 BSGS/exBSGS\nP6097 【模板】子集卷积\nP6178 【模板】Matrix-Tree 定理\nP6164 【模板】后缀平衡树\nP6242 【模板】线段树 3\nP3806 【模板】点分治1\nP4556 【模板】线段树合并 / [Vani有约会]雨天的尾巴\nP4751 【模板】\"动态DP\"&动态树分治（加强版）\nP4721 【模板】分治 FFT\nP5410 【模板】扩展 KMP（Z 函数）\nP5829 【模板】失配树\nP6192 【模板】最小斯坦纳树\nP4720 【模板】扩展卢卡斯定理/exLucas\nP3690 【模板】动态树（Link Cut Tree）\nP4722 【模板】最大流 加强版 / 预流推进\nP3380 【模板】二逼平衡树（树套树）\nP4245 【模板】任意模数多项式乘法\nP7173 【模板】有负圈的费用流\nP5245 【模板】多项式快速幂\nP4238 【模板】多项式乘法逆\nP4897 【模板】最小割树（Gomory-Hu Tree）\nP4980 【模板】Pólya 定理\nP6657 【模板】LGV 引理\nP5205 【模板】多项式开根\nP4512 【模板】多项式除法\nP5277 【模板】多项式开根（加强版）\nP4726 【模板】多项式指数函数（多项式 exp）\nP5273 【模板】多项式幂函数 (加强版)\nP6577 【模板】二分图最大权完美匹配\nP6800 【模板】Chirp Z-Transform\nNOI / NOI+ / CTSC\nP4724 【模板】三维凸包\nP5180 【模板】支配树\nP4723 【模板】常系数齐次线性递推\nP2483 【模板】k短路 / [SDOI2010]魔法猪学院\nP5050 【模板】多项式多点求值\nP5282 【模板】快速阶乘算法\nP5325 【模板】Min_25筛\nP5247 【模板】动态图完全连通性\nP5809 【模板】多项式复合逆\nP5056 【模板】插头dp\nP5373 【模板】多项式复合函数\nP5808 【模板】常系数非齐次线性递推\nP5487 【模板】Berlekamp-Massey算法\nP5668 【模板】N次剩余\nP5158 【模板】多项式快速插值\nP4887 【模板】莫队二次离线（第十四分块(前体)）\nP5170 【模板】类欧几里得算法\nP6699 【模板】一般图最大权匹配\nP6656 【模板】Runs\nP6115 【模板】整式递推\n","source":"_posts/Luogu-Template.md","raw":"---\ntitle: 洛谷模板题集合\ndate: 2021-10-10 00:01:12\ntags: 模板\n---\n\n---------\n\n# 洛谷模板题集合\n\n> 参考[这篇文章](https://www.cnblogs.com/Ender-hz/p/15018563.html)列出的题目\n\n## 0. 工具宏 & 包导入声明\n\n```rust\n/// Dummy Luogu/LeetCode Playground\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque, BTreeMap};\nuse std::convert::{From, Into, TryFrom, TryInto};\nuse std::io;\nuse std::marker::PhantomData;\nuse std::rc::Rc;\n\nmacro_rules! init_cin {\n    () => {{\n        (io::stdin(), String::new())\n    }};\n}\nmacro_rules! scanf {\n    ($buf: expr, $div: expr, $($x:ty), +) => {{\n        let mut iter = $buf.split($div);\n        ($(iter.next().and_then(|token| token.parse::<$x>().ok()), ) *)\n    }};\n}\nmacro_rules! getline {\n    ($cin: expr, $buf: expr) => {{\n        $buf.clear();\n        $cin.read_line(&mut $buf)?;\n    }};\n}\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\n```\n\n## 1. 普及-\n\n### P3367 并查集\n\n```rust\nstruct DisjointSet<T>\nwhere\n    T: Sized + Eq + Copy + TryInto<usize>,\n{\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n    phantom: PhantomData<T>,\n}\n\nimpl<T> DisjointSet<T>\nwhere\n    T: Sized + Eq + Copy + TryInto<usize>,\n{\n    pub fn with_capacity(cap: usize) -> Self {\n        Self {\n            parent: vec![usize::MAX; cap],\n            rank: vec![0; cap],\n            phantom: PhantomData,\n        }\n    }\n    pub fn modify(&mut self, x: T, p: usize) {\n        match x.try_into() {\n            Ok(x) => { self.parent[x] = p; },\n            Err(_) => panic!()\n        }\n    }\n    pub fn union(&mut self, x: T, y: T) -> bool {\n        let (mut fx, mut fy) = (self.find(x), self.find(y));\n        if fx == fy || fx == usize::MAX || fy == usize::MAX {\n            false\n        } else {\n            if self.rank[fx] > self.rank[fy] {\n                std::mem::swap(&mut fx, &mut fy);\n            }\n            self.parent[fx] = fy;\n            if self.rank[fx] == self.rank[fy] {\n                self.rank[fy] += 1;\n            }\n            true\n        }\n    }\n    pub fn find(&mut self, x: T) -> usize {\n        match x.try_into() {\n            Ok(x) => self.find_wrapper(x),\n            Err(_) => usize::MAX\n        }\n    }\n    fn find_wrapper(&mut self, x: usize) -> usize {\n        if x != self.parent[x] {\n            self.parent[x] = self.find_wrapper(self.parent[x]);\n        }\n        self.parent[x]\n    }\n}\n\nfn main() -> io::Result<()> {\n    let cin = io::stdin();\n    let mut buf = String::new();\n    getline!(cin, buf);\n    // n m\n    if let (Some(n), Some(mut m)) = scanf!(buf, char::is_whitespace, i32, i32) {\n        let mut dsj = DisjointSet::<i32>::with_capacity(n as usize + 1);\n        (1..=n).for_each(|i| dsj.modify(i, i as usize));\n        while m > 0 {\n            getline!(cin, buf);\n            if let (Some(op), Some(arg1), Some(arg2)) =\n                scanf!(buf, char::is_whitespace, i32, i32, i32)\n            {\n                match op {\n                    1 => { dsj.union(arg1, arg2); },\n                    2 => { println!(\"{:}\", if dsj.find(arg1) == dsj.find(arg2) && dsj.find(arg1) != usize::MAX {\"Y\"} else {\"N\"})},\n                    _ => unreachable!()\n                }\n            }\n            m -= 1;\n        }\n    }\n    Ok(())\n}\n```\n\n\n\n### P3371 单源最短路（非随机数据）\n\n> 看描述似乎允许 SPFA ，但是原版 SPFA 还是被卡掉了三个用例\n\n```rust\nmod my {\n    #[derive(Debug, Clone)]\n    struct LFSNode {\n        to: usize,\n        next: usize,\n        w: i32,\n    }\n    pub struct LinkedForwardStar {\n        edges: Vec<LFSNode>,\n        head: Vec<usize>,\n        tot: usize,\n    }\n    impl LinkedForwardStar {\n        pub fn with_capacity(nodes: usize, edges: usize) -> Self {\n            Self {\n                edges: vec![\n                    LFSNode {\n                        to: usize::MAX,\n                        next: usize::MAX,\n                        w: 0\n                    };\n                    edges\n                ],\n                head: vec![usize::MAX; nodes],\n                tot: 0,\n            }\n        }\n        pub fn add(&mut self, src: usize, dst: usize, weight: i32) {\n            self.edges[self.tot].next = self.head[src];\n            self.edges[self.tot].to = dst;\n            self.edges[self.tot].w = weight;\n            self.head[src] = self.tot;\n            self.tot += 1;\n        }\n    }\n    pub fn spfa_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n        let mut vis = vec![false; lfs.tot];\n        let mut dist = vec![i32::MAX; lfs.head.len()];\n        let mut queue = vec![src];\n        dist[src] = 0;\n        vis[src] = true;\n        while !queue.is_empty() {\n            let x = queue.pop().unwrap();\n            vis[x] = false;\n            let mut i = lfs.head[x];\n            while i != usize::MAX {\n                let y = lfs.edges[i].to;\n                if dist[y] - lfs.edges[i].w > dist[x] {\n                    dist[y] = dist[x] + lfs.edges[i].w;\n                    if !vis[y] {\n                        vis[y] = true;\n                        queue.push(y);\n                    }\n                }\n                i = lfs.edges[i].next;\n            }\n        }\n        dist\n    }\n    pub fn dijkstra_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n        let mut vis = vec![false; lfs.head.len()];\n        let mut dist = vec![i32::MAX; lfs.head.len()];\n        let mut x = src;\n        dist[src] = 0;\n        while !vis[x] {\n            let mut curr = i32::MAX;\n            vis[x] = true;\n            let mut y = lfs.head[x];\n            while y != usize::MAX {\n                if !vis[lfs.edges[y].to] && dist[lfs.edges[y].to] - lfs.edges[y].w > dist[x] {\n                    dist[lfs.edges[y].to] = dist[x] + lfs.edges[y].w;\n                }\n                y = lfs.edges[y].next;\n            }\n            for i in 1..lfs.head.len() {\n                if dist[i] < curr && !vis[i] {\n                    curr = dist[i];\n                    x = i;\n                }\n            }\n        }\n        dist\n    }\n}\nuse my::*;\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m), Some(src)) = scanf!(buf, char::is_whitespace, usize, usize, usize)\n    {\n        let mut lfs = LinkedForwardStar::with_capacity(n + 1, m + 1);\n        while m > 0 {\n            m -= 1;\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                lfs.add(u, v, w);\n            }\n        }\n        // spfa_solver(lfs, src)\n        dijkstra_solver(lfs, src)\n            .iter()\n            .skip(1)\n            .for_each(|i| print!(\"{:} \", i))\n    }\n    Ok(())\n}\n```\n\n\n\n### P1226 快速幂\n\n```rust\nfn fast_pow(x: i64, n: i64, m: i64) -> i64 {\n    let (mut x, mut n, mut ret) = (x, n, 1);\n    while n > 0 {\n        if (n & 1) == 1 {\n            ret *= x;\n            ret %= m;\n        }\n        x *= x;\n        x %= m;\n        n >>= 1;\n    }\n    ret % m\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(x), Some(n), Some(m)) = scanf!(buf, char::is_whitespace, i64, i64, i64) {\n        println!(\"{0}^{1} mod {2}={3}\", x, n, m, fast_pow(x, n, m));\n    }\n    Ok(())\n}\n```\n\n\n\n### P4779 单源最短路（标准）\n\n> 不优化的 Dijkstra 也寄了，堆优化的 AC\n\n```rust\n#[derive(Default, Debug, Clone)]\nstruct LFSNode {\n    to: usize,\n    next: usize,\n    w: i32,\n}\npub struct LinkedForwardStar {\n    edges: Vec<LFSNode>,\n    head: Vec<usize>,\n    tot: usize,\n}\nimpl LinkedForwardStar {\n    pub fn with_capacity(node_cap: usize, edge_cap: usize) -> Self {\n        Self {\n            edges: vec![LFSNode::default(); edge_cap],\n            head: vec![usize::MAX; node_cap],\n            tot: 0,\n        }\n    }\n    pub fn add(&mut self, src: usize, dst: usize, weight: i32) {\n        self.edges[self.tot].next = self.head[src];\n        self.edges[self.tot].to = dst;\n        self.edges[self.tot].w = weight;\n        self.head[src] = self.tot;\n        self.tot += 1;\n    }\n}\npub fn spfa_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n    let mut vis = vec![false; lfs.tot];\n    let mut dist = vec![i32::MAX; lfs.head.len()];\n    let mut queue = vec![src];\n    dist[src] = 0;\n    vis[src] = true;\n    while !queue.is_empty() {\n        let x = queue.pop().unwrap();\n        vis[x] = false;\n        let mut i = lfs.head[x];\n        while i != usize::MAX {\n            let y = lfs.edges[i].to;\n            if dist[y] - lfs.edges[i].w > dist[x] {\n                dist[y] = dist[x] + lfs.edges[i].w;\n                if !vis[y] {\n                    vis[y] = true;\n                    queue.push(y);\n                }\n            }\n            i = lfs.edges[i].next;\n        }\n    }\n    dist\n}\n/// Dijkstra with Heap optimization\npub fn dijkstra_solver(lfs: LinkedForwardStar, src: usize) -> Vec<i32> {\n    let mut vis = vec![false; lfs.head.len()];\n    let mut dist = vec![i32::MAX; lfs.head.len()];\n    let mut pq = BinaryHeap::new();\n    dist[src] = 0;\n    pq.push(Reverse((dist[src], src)));\n    while let Some(Reverse((_, u))) = pq.pop() {\n        if vis[u] {\n            continue;\n        }\n        vis[u] = true;\n        let mut e = lfs.head[u];\n        while e != usize::MAX {\n            let v = lfs.edges[e].to;\n            let w = lfs.edges[e].w;\n            if dist[v] > dist[u] + w {\n                dist[v] = dist[u] + w;\n                pq.push(Reverse((dist[v], v)));\n            }\n            e = lfs.edges[e].next;\n        }\n    }\n    dist\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m), Some(src)) = scanf!(buf, char::is_whitespace, usize, usize, usize)\n    {\n        let mut lfs = LinkedForwardStar::with_capacity(n + 1, m + 1);\n        while m > 0 {\n            m -= 1;\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                lfs.add(u, v, w);\n            }\n        }\n        // spfa_solver(lfs, src)\n        dijkstra_solver(lfs, src)\n            .iter()\n            .skip(1)\n            .for_each(|i| print!(\"{:} \", i))\n    }\n    Ok(())\n}\n```\n\n### P3383 【模板】线性筛素数\n\n```rust\nfn euler_sieve(n: usize) -> Vec<i32> {\n    let mut valid = vec![true; n + 1];\n    let mut ans = vec![0; n + 1];\n    let mut tot = 0;\n    for i in 2..=n {\n        if valid[i] {\n            tot += 1;\n            ans[tot] = i;\n        }\n        let mut j = 1;\n        while j <= tot && i * ans[j] <= n {\n            valid[i * ans[j]] = false;\n            if i % ans[j] == 0 {\n                break;\n            }\n            j += 1;\n        }\n    }\n    ans.into_iter().skip(1).take(tot).map(|i| i as i32).collect()\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut qs)) = scanf!(buf, char::is_whitespace, usize, i32) {\n        let primes = euler_sieve(n);\n        while qs > 0 {\n            getline!(cin, buf);\n            if let (Some(q),) = scanf!(buf, char::is_whitespace, usize) {\n                println!(\"{0}\", primes[q-1]);\n            }\n            qs -= 1;\n        }\n    }\n    Ok(())\n}\n```\n\n### P3366 【模板】最小生成树\n\n```rust\nstruct Edge {\n    u: usize,\n    v: usize,\n    w: i32,\n}\n\n/// Kruskal 算法\n/// 复杂度 `M \\log M`\n/// 思想：每次取剩下的边权最小的边，如果加上这条边后图中出现了一个环，就不选这条边（可以通过并查集）判断\nfn kruskal(edges: &mut Vec<Edge>, nodes_num: usize) -> i32 {\n    let mut parent = (0..=nodes_num).collect::<Vec<_>>();\n    fn find(u: usize, parent: &mut Vec<usize>) -> usize {\n        if u == parent[u] {\n            u\n        } else {\n            parent[u] = find(parent[u], parent);\n            parent[u]\n        }\n    }\n    edges.sort_by(|lhs, rhs| lhs.w.cmp(&rhs.w));\n    let mut ans = 0;\n    let mut cnt = nodes_num;\n    for i in 0..edges.len() {\n        let (p1, p2) = (find(edges[i].u, &mut parent), find(edges[i].v, &mut parent));\n        if p1 != p2 {\n            parent[p1] = p2;\n            ans += edges[i].w;\n            cnt -= 1;\n            if cnt == 1 {\n                break;\n            }\n        }\n    }\n    if cnt == 1 {\n        ans\n    } else {\n        i32::MAX\n    }\n}\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n), Some(mut m)) = scanf!(buf, char::is_whitespace, usize, usize) {\n        let mut edges = Vec::with_capacity(m);\n        while m > 0 {\n            getline!(cin, buf);\n            if let (Some(u), Some(v), Some(w)) = scanf!(buf, char::is_whitespace, usize, usize, i32)\n            {\n                edges.push(Edge { u, v, w });\n            }\n            m -= 1;\n        }\n        let ans = kruskal(&mut edges, n);\n        println!(\"{0}\", if ans == i32::MAX { \"orz\".to_string() } else { ans.to_string() });\n    }\n    Ok(())\n}\n```\n\n### P3378 【模板】堆\n\n>   不想手写，直接用了 std\n\n### P3370 【模板】字符串哈希\n\n>   交了半天都是 TLE，一开 O2 过了，烦死\n\n```rust\nfn string_hash(s: &String) -> i32 {\n    let mut hash = s.chars()\n        .fold(0, |mut hash: i32, ch| {\n            hash = hash.wrapping_add(ch as i32);\n            hash = hash.wrapping_add(hash.wrapping_shl(10));\n            hash ^= hash.wrapping_shr(6);\n            hash\n        });\n    hash = hash.wrapping_add(hash.wrapping_shl(3));\n    hash ^= hash.wrapping_shr(11);\n    hash = hash.wrapping_add(hash.wrapping_shl(15));\n    hash\n}\n\n/*\nconst MOD: usize = 2147483647;\nconst POW: usize = 257;\n\nfn string_hash(s: &String) -> usize {\n    s.chars()\n        .fold(0, |hash, ch| (hash * POW + (ch as usize)) % MOD)\n}\n*/\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n),) = scanf!(buf, char::is_whitespace, usize) {\n        let mut bucket = vec![0; n];\n        let mut i = 0usize;\n        let mut ans = n;\n        while i < n {\n            getline!(cin, buf);\n            bucket[i] = string_hash(&buf);\n            i += 1;\n        }\n        bucket.sort();\n        (1..n).for_each(|i| if bucket[i] == bucket[i - 1] { ans -= 1 } );\n        println!(\"{0}\", ans);\n    }\n    Ok(())\n}\n```\n\n### P1177 【模板】快速排序\n\n```rust\n/*\nfn sort(vals: &mut Vec<i32>, l: usize, r: usize) {\n    if r - l > 10 {\n        quick_sort(vals, l, r);\n    } else {\n        insert_sort(vals, l, r);\n    }\n}\n*/\n\nfn quick_sort(vals: &mut Vec<i32>, l: usize, r: usize) {\n    if l >= r {\n        return;\n    }\n    let mut i = l;\n    let mut j = r;\n    let pivot = vals[((l + r) >> 1) as usize];\n    while i <= j {\n        while pivot > vals[i] {\n            i += 1;\n        }\n        while pivot < vals[j] {\n            j -= 1;\n        }\n        if i <= j {\n            let tmp = vals[i];\n            vals[i] = vals[j];\n            vals[j] = tmp;\n            i += 1;\n            j -= 1;\n        }\n    }\n    quick_sort(vals, l, j);\n    quick_sort(vals, i, r);\n}\n\n/*\nfn insert_sort(vals: &mut Vec<i32>, l: usize, r: usize) {\n    for i in l..=r {\n        let mut j = i;\n        let pivot = vals[i];\n        while j >= 1 && vals[j - 1] > pivot {\n            vals[j] = vals[j - 1];\n            j -= 1;\n        }\n        vals[j] = pivot;\n    }\n}\n*/\n\nfn main() -> io::Result<()> {\n    let (cin, mut buf) = init_cin!();\n    getline!(cin, buf);\n    if let (Some(n),) = scanf!(buf, char::is_whitespace, usize) {\n        getline!(cin, buf);\n        let mut vals = buf\n            .split(char::is_whitespace)\n            .map(|i| i.parse::<i32>())\n            .filter(|i| i.is_ok())\n            .map(|i| i.unwrap())\n            .collect::<Vec<_>>();\n        let len = vals.len();\n        assert_eq!(len, n);\n        let len = vals.len();\n        quick_sort(&mut vals, 0, len - 1);\n        vals.iter().for_each(|i| print!(\"{0} \", i));\n    }\n    Ok(())\n}\n```\n\n普及 / 提高-\nP1886 【模板】单调队列 / 滑动窗口\nP3382 【模板】三分法\nP3374 【模板】树状数组 1\nP3811 【模板】乘法逆元\nP3372 【模板】线段树 1\nP3375 【模板】KMP字符串匹配\nP3368 【模板】树状数组 2\nP3379 【模板】最近公共祖先（LCA）\nP1939 【模板】矩阵加速（数列）\nP3385 【模板】负环\nP3865 【模板】ST 表\nP3390 【模板】矩阵快速幂\nP4549 【模板】裴蜀定理\nP4779 【模板】单源最短路径（标准版）\nP5788 【模板】单调栈\n普及+ / 提高\nP5431 【模板】乘法逆元2\nP5367 【模板】康托展开\nP5960 【模板】差分约束算法\nP2613 【模板】有理数取余\nP2252 【模板】威佐夫博弈 / [SHOI2002] 取石子游戏\nP3373 【模板】线段树 2\nP5905 【模板】Johnson 全源最短路\nP2197 【模板】nim 游戏\nP3387 【模板】缩点\nP1439 【模板】最长公共子序列\nP3386 【模板】二分图最大匹配\nP3388 【模板】割点（割顶）\nP5656 【模板】二元一次不定方程 (exgcd)\n提高+ / 省选-\nP3377 【模板】左偏树（可并堆）\nP3381 【模板】最小费用最大流\nP3369 【模板】普通平衡树\nP6091 【模板】原根\nP4781 【模板】拉格朗日插值\nP5903 【模板】树上 k 级祖先\nP5854 【模板】笛卡尔树\nP6086 【模板】Prufer 序列\nP1368 【模板】最小表示法\nP5632 【模板】Stoer-Wagner算法\nP5490 【模板】扫描线\nP3805 【模板】manacher 算法\nP1495 【模板】中国剩余定理(CRT)/曹冲养猪\nP2742 【模板】二维凸包 / [USACO5.1]圈奶牛Fencing the Cows\nP3389 【模板】高斯消元法\nP4783 【模板】矩阵求逆\nP3796 【模板】AC自动机（加强版）\nP3808 【模板】AC自动机（简单版）\nP5826 【模板】子序列自动机\nP3846 【模板】BSGS / [TJOI2007] 可爱的质数\nP3376 【模板】网络最大流\nP3391 【模板】文艺平衡树\nP5091 【模板】扩展欧拉定理\nP3807 【模板】卢卡斯定理/Lucas 定理\nP3384 【模板】轻重链剖分/树链剖分\nP3812 【模板】线性基\nP3919 【模板】可持久化线段树 1（可持久化数组）\nP3834 【模板】可持久化线段树 2（主席树）\nP7112 【模板】行列式求值\nP1919 【模板】A*B Problem升级版（FFT快速傅里叶）\nP3803 【模板】多项式乘法（FFT）\nP4525 【模板】自适应辛普森法1\n省选 / NOI-\nP4196 【模板】半平面交 / [CQOI2006]凸多边形\nP1452 【模板】旋转卡壳 / [USACO03FALL]Beauty Contest G\nP3809 【模板】后缀排序\nP6177 【模板】树分块 / Count on a tree II\nP5906 【模板】回滚莫队&不删除莫队\nP4782 【模板】2-SAT 问题\nP5357 【模板】AC自动机（二次加强版）\nP4719 【模板】\"动态 DP\"&动态树分治\nP5055 【模板】可持久化文艺平衡树\nP5236 【模板】静态仙人掌\nP5394 【模板】下降幂多项式乘法\nP5496 【模板】回文自动机（PAM）\nP5494 【模板】线段树分裂\nP6136 【模板】普通平衡树（数据加强版）\nP6114 【模板】Lyndon 分解\nP5807 【模板】BEST 定理 / Which Dreamed It\nP6139 【模板】广义后缀自动机（广义 SAM）\nP6329 【模板】点分树 | 震波\nP4213 【模板】杜教筛（Sum）\nP4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)\nP5043 【模板】树同构 / [BJOI2015] 树的同构\nP5192 【模板】有源汇上下界最大流 / Zoj3229 Shoot the Bullet|东方文花帖|\nP5491 【模板】二次剩余\nP3804 【模板】后缀自动机 (SAM)\nP3810 【模板】三维偏序（陌上花开）\nP4526 【模板】自适应辛普森法2\nP4777 【模板】扩展中国剩余定理（EXCRT）\nP4716 【模板】最小树形图\nP4718 【模板】Pollard-Rho算法\nP4725 【模板】多项式对数函数（多项式 ln）\nP4929 【模板】舞蹈链（DLX）\nP5787 【模板】线段树分治 / 二分图\nP6113 【模板】一般图最大匹配\nP3835 【模板】可持久化平衡树\nP4195 【模板】扩展 BSGS/exBSGS\nP6097 【模板】子集卷积\nP6178 【模板】Matrix-Tree 定理\nP6164 【模板】后缀平衡树\nP6242 【模板】线段树 3\nP3806 【模板】点分治1\nP4556 【模板】线段树合并 / [Vani有约会]雨天的尾巴\nP4751 【模板】\"动态DP\"&动态树分治（加强版）\nP4721 【模板】分治 FFT\nP5410 【模板】扩展 KMP（Z 函数）\nP5829 【模板】失配树\nP6192 【模板】最小斯坦纳树\nP4720 【模板】扩展卢卡斯定理/exLucas\nP3690 【模板】动态树（Link Cut Tree）\nP4722 【模板】最大流 加强版 / 预流推进\nP3380 【模板】二逼平衡树（树套树）\nP4245 【模板】任意模数多项式乘法\nP7173 【模板】有负圈的费用流\nP5245 【模板】多项式快速幂\nP4238 【模板】多项式乘法逆\nP4897 【模板】最小割树（Gomory-Hu Tree）\nP4980 【模板】Pólya 定理\nP6657 【模板】LGV 引理\nP5205 【模板】多项式开根\nP4512 【模板】多项式除法\nP5277 【模板】多项式开根（加强版）\nP4726 【模板】多项式指数函数（多项式 exp）\nP5273 【模板】多项式幂函数 (加强版)\nP6577 【模板】二分图最大权完美匹配\nP6800 【模板】Chirp Z-Transform\nNOI / NOI+ / CTSC\nP4724 【模板】三维凸包\nP5180 【模板】支配树\nP4723 【模板】常系数齐次线性递推\nP2483 【模板】k短路 / [SDOI2010]魔法猪学院\nP5050 【模板】多项式多点求值\nP5282 【模板】快速阶乘算法\nP5325 【模板】Min_25筛\nP5247 【模板】动态图完全连通性\nP5809 【模板】多项式复合逆\nP5056 【模板】插头dp\nP5373 【模板】多项式复合函数\nP5808 【模板】常系数非齐次线性递推\nP5487 【模板】Berlekamp-Massey算法\nP5668 【模板】N次剩余\nP5158 【模板】多项式快速插值\nP4887 【模板】莫队二次离线（第十四分块(前体)）\nP5170 【模板】类欧几里得算法\nP6699 【模板】一般图最大权匹配\nP6656 【模板】Runs\nP6115 【模板】整式递推\n","slug":"Luogu-Template","published":1,"updated":"2021-11-17T05:21:51.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8q4000o1cy53mm732vw","content":"<hr>\n<h1 id=\"洛谷模板题集合\"><a href=\"#洛谷模板题集合\" class=\"headerlink\" title=\"洛谷模板题集合\"></a>洛谷模板题集合</h1><blockquote>\n<p>参考<a href=\"https://www.cnblogs.com/Ender-hz/p/15018563.html\">这篇文章</a>列出的题目</p>\n</blockquote>\n<h2 id=\"0-工具宏-amp-包导入声明\"><a href=\"#0-工具宏-amp-包导入声明\" class=\"headerlink\" title=\"0. 工具宏 &amp; 包导入声明\"></a>0. 工具宏 &amp; 包导入声明</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BinaryHeap, HashMap, HashSet, VecDeque, BTreeMap&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::convert::&#123;<span class=\"built_in\">From</span>, <span class=\"built_in\">Into</span>, TryFrom, TryInto&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> init_cin &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#123;</span><br><span class=\"line\">        (io::stdin(), <span class=\"built_in\">String</span>::new())</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> scanf &#123;</span><br><span class=\"line\">    ($buf: expr, $div: expr, $($x:ty), +) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> iter = $buf.split($div);</span><br><span class=\"line\">        ($(iter.next().and_then(|token| token.parse::&lt;$x&gt;().ok()), ) *)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> getline &#123;</span><br><span class=\"line\">    ($cin: expr, $buf: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $buf.clear();</span><br><span class=\"line\">        $cin.read_line(&amp;<span class=\"keyword\">mut</span> $buf)?;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-普及\"><a href=\"#1-普及\" class=\"headerlink\" title=\"1. 普及-\"></a>1. 普及-</h2><h3 id=\"P3367-并查集\"><a href=\"#P3367-并查集\" class=\"headerlink\" title=\"P3367 并查集\"></a>P3367 并查集</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DisjointSet</span></span>&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"built_in\">Sized</span> + <span class=\"built_in\">Eq</span> + <span class=\"built_in\">Copy</span> + TryInto&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    parent: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    rank: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    phantom: PhantomData&lt;T&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; DisjointSet&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"built_in\">Sized</span> + <span class=\"built_in\">Eq</span> + <span class=\"built_in\">Copy</span> + TryInto&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            parent: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            rank: <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; cap],</span><br><span class=\"line\">            phantom: PhantomData,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">modify</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T, p: <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> x.try_into() &#123;</span><br><span class=\"line\">            <span class=\"literal\">Ok</span>(x) =&gt; &#123; <span class=\"keyword\">self</span>.parent[x] = p; &#125;,</span><br><span class=\"line\">            <span class=\"literal\">Err</span>(_) =&gt; <span class=\"built_in\">panic!</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">union</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T, y: T) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> fx, <span class=\"keyword\">mut</span> fy) = (<span class=\"keyword\">self</span>.find(x), <span class=\"keyword\">self</span>.find(y));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fx == fy || fx == <span class=\"built_in\">usize</span>::MAX || fy == <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fx] &gt; <span class=\"keyword\">self</span>.rank[fy] &#123;</span><br><span class=\"line\">                std::mem::swap(&amp;<span class=\"keyword\">mut</span> fx, &amp;<span class=\"keyword\">mut</span> fy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[fx] = fy;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fx] == <span class=\"keyword\">self</span>.rank[fy] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.rank[fy] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> x.try_into() &#123;</span><br><span class=\"line\">            <span class=\"literal\">Ok</span>(x) =&gt; <span class=\"keyword\">self</span>.find_wrapper(x),</span><br><span class=\"line\">            <span class=\"literal\">Err</span>(_) =&gt; <span class=\"built_in\">usize</span>::MAX</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find_wrapper</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != <span class=\"keyword\">self</span>.parent[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[x] = <span class=\"keyword\">self</span>.find_wrapper(<span class=\"keyword\">self</span>.parent[x]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent[x]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cin = io::stdin();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buf = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"comment\">// n m</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dsj = DisjointSet::&lt;<span class=\"built_in\">i32</span>&gt;::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">        (<span class=\"number\">1</span>..=n).for_each(|i| dsj.modify(i, i <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>));</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(op), <span class=\"literal\">Some</span>(arg1), <span class=\"literal\">Some</span>(arg2)) =</span><br><span class=\"line\">                scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">match</span> op &#123;</span><br><span class=\"line\">                    <span class=\"number\">1</span> =&gt; &#123; dsj.union(arg1, arg2); &#125;,</span><br><span class=\"line\">                    <span class=\"number\">2</span> =&gt; &#123; <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:&#125;&quot;</span>, <span class=\"keyword\">if</span> dsj.find(arg1) == dsj.find(arg2) &amp;&amp; dsj.find(arg1) != <span class=\"built_in\">usize</span>::MAX &#123;<span class=\"string\">&quot;Y&quot;</span>&#125; <span class=\"keyword\">else</span> &#123;<span class=\"string\">&quot;N&quot;</span>&#125;)&#125;,</span><br><span class=\"line\">                    _ =&gt; <span class=\"built_in\">unreachable!</span>()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P3371-单源最短路（非随机数据）\"><a href=\"#P3371-单源最短路（非随机数据）\" class=\"headerlink\" title=\"P3371 单源最短路（非随机数据）\"></a>P3371 单源最短路（非随机数据）</h3><blockquote>\n<p>看描述似乎允许 SPFA ，但是原版 SPFA 还是被卡掉了三个用例</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> my &#123;</span><br><span class=\"line\">    <span class=\"meta\">#[derive(Debug, Clone)]</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFSNode</span></span> &#123;</span><br><span class=\"line\">        to: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">        next: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">        w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">        edges: <span class=\"built_in\">Vec</span>&lt;LFSNode&gt;,</span><br><span class=\"line\">        head: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">        tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(nodes: <span class=\"built_in\">usize</span>, edges: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">                edges: <span class=\"built_in\">vec!</span>[</span><br><span class=\"line\">                    LFSNode &#123;</span><br><span class=\"line\">                        to: <span class=\"built_in\">usize</span>::MAX,</span><br><span class=\"line\">                        next: <span class=\"built_in\">usize</span>::MAX,</span><br><span class=\"line\">                        w: <span class=\"number\">0</span></span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                    edges</span><br><span class=\"line\">                ],</span><br><span class=\"line\">                head: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; nodes],</span><br><span class=\"line\">                tot: <span class=\"number\">0</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, dst: <span class=\"built_in\">usize</span>, weight: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].next = <span class=\"keyword\">self</span>.head[src];</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].to = dst;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].w = weight;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.head[src] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">spfa_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.tot];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> queue = <span class=\"built_in\">vec!</span>[src];</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !queue.is_empty() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> x = queue.pop().unwrap();</span><br><span class=\"line\">            vis[x] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = lfs.head[x];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> y = lfs.edges[i].to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[y] - lfs.edges[i].w &gt; dist[x] &#123;</span><br><span class=\"line\">                    dist[y] = dist[x] + lfs.edges[i].w;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> !vis[y] &#123;</span><br><span class=\"line\">                        vis[y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        queue.push(y);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i = lfs.edges[i].next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dist</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> x = src;</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !vis[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> curr = <span class=\"built_in\">i32</span>::MAX;</span><br><span class=\"line\">            vis[x] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> y = lfs.head[x];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> y != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> !vis[lfs.edges[y].to] &amp;&amp; dist[lfs.edges[y].to] - lfs.edges[y].w &gt; dist[x] &#123;</span><br><span class=\"line\">                    dist[lfs.edges[y].to] = dist[x] + lfs.edges[y].w;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                y = lfs.edges[y].next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..lfs.head.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[i] &lt; curr &amp;&amp; !vis[i] &#123;</span><br><span class=\"line\">                    curr = dist[i];</span><br><span class=\"line\">                    x = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dist</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">use</span> my::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m), <span class=\"literal\">Some</span>(src)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(n + <span class=\"number\">1</span>, m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                lfs.add(u, v, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// spfa_solver(lfs, src)</span></span><br><span class=\"line\">        dijkstra_solver(lfs, src)</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">            .for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;:&#125; &quot;</span>, i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P1226-快速幂\"><a href=\"#P1226-快速幂\" class=\"headerlink\" title=\"P1226 快速幂\"></a>P1226 快速幂</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">fast_pow</span></span>(x: <span class=\"built_in\">i64</span>, n: <span class=\"built_in\">i64</span>, m: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">i64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> x, <span class=\"keyword\">mut</span> n, <span class=\"keyword\">mut</span> ret) = (x, n, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            ret *= x;</span><br><span class=\"line\">            ret %= m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x *= x;</span><br><span class=\"line\">        x %= m;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret % m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(x), <span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i64</span>, <span class=\"built_in\">i64</span>, <span class=\"built_in\">i64</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;^&#123;1&#125; mod &#123;2&#125;=&#123;3&#125;&quot;</span>, x, n, m, fast_pow(x, n, m));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P4779-单源最短路（标准）\"><a href=\"#P4779-单源最短路（标准）\" class=\"headerlink\" title=\"P4779 单源最短路（标准）\"></a>P4779 单源最短路（标准）</h3><blockquote>\n<p>不优化的 Dijkstra 也寄了，堆优化的 AC</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Default, Debug, Clone)]</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFSNode</span></span> &#123;</span><br><span class=\"line\">    to: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    next: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">    edges: <span class=\"built_in\">Vec</span>&lt;LFSNode&gt;,</span><br><span class=\"line\">    head: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(node_cap: <span class=\"built_in\">usize</span>, edge_cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            edges: <span class=\"built_in\">vec!</span>[LFSNode::default(); edge_cap],</span><br><span class=\"line\">            head: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; node_cap],</span><br><span class=\"line\">            tot: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, dst: <span class=\"built_in\">usize</span>, weight: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].next = <span class=\"keyword\">self</span>.head[src];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].to = dst;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].w = weight;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.head[src] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">spfa_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.tot];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> queue = <span class=\"built_in\">vec!</span>[src];</span><br><span class=\"line\">    dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> !queue.is_empty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = queue.pop().unwrap();</span><br><span class=\"line\">        vis[x] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = lfs.head[x];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> y = lfs.edges[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[y] - lfs.edges[i].w &gt; dist[x] &#123;</span><br><span class=\"line\">                dist[y] = dist[x] + lfs.edges[i].w;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> !vis[y] &#123;</span><br><span class=\"line\">                    vis[y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    queue.push(y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i = lfs.edges[i].next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dist</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// Dijkstra with Heap optimization</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> pq = BinaryHeap::new();</span><br><span class=\"line\">    dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pq.push(Reverse((dist[src], src)));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(Reverse((_, u))) = pq.pop() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> vis[u] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> e = lfs.head[u];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> e != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> v = lfs.edges[e].to;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> w = lfs.edges[e].w;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[v] &gt; dist[u] + w &#123;</span><br><span class=\"line\">                dist[v] = dist[u] + w;</span><br><span class=\"line\">                pq.push(Reverse((dist[v], v)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = lfs.edges[e].next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dist</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m), <span class=\"literal\">Some</span>(src)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(n + <span class=\"number\">1</span>, m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                lfs.add(u, v, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// spfa_solver(lfs, src)</span></span><br><span class=\"line\">        dijkstra_solver(lfs, src)</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">            .for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;:&#125; &quot;</span>, i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"P3383-【模板】线性筛素数\"><a href=\"#P3383-【模板】线性筛素数\" class=\"headerlink\" title=\"P3383 【模板】线性筛素数\"></a>P3383 【模板】线性筛素数</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">euler_sieve</span></span>(n: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> valid = <span class=\"built_in\">vec!</span>[<span class=\"literal\">true</span>; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">2</span>..=n &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> valid[i] &#123;</span><br><span class=\"line\">            tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">            ans[tot] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt;= tot &amp;&amp; i * ans[j] &lt;= n &#123;</span><br><span class=\"line\">            valid[i * ans[j]] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i % ans[j] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            j += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans.into_iter().skip(<span class=\"number\">1</span>).take(tot).map(|i| i <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>).collect()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> qs)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> primes = euler_sieve(n);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> qs &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(q),) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;&quot;</span>, primes[q-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            qs -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"P3366-【模板】最小生成树\"><a href=\"#P3366-【模板】最小生成树\" class=\"headerlink\" title=\"P3366 【模板】最小生成树\"></a>P3366 【模板】最小生成树</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span> &#123;</span><br><span class=\"line\">    u: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    v: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Kruskal 算法</span></span><br><span class=\"line\"><span class=\"comment\">/// 复杂度 `M \\log M`</span></span><br><span class=\"line\"><span class=\"comment\">/// 思想：每次取剩下的边权最小的边，如果加上这条边后图中出现了一个环，就不选这条边（可以通过并查集）判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">kruskal</span></span>(edges: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">Vec</span>&lt;Edge&gt;, nodes_num: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> parent = (<span class=\"number\">0</span>..=nodes_num).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(u: <span class=\"built_in\">usize</span>, parent: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> u == parent[u] &#123;</span><br><span class=\"line\">            u</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            parent[u] = find(parent[u], parent);</span><br><span class=\"line\">            parent[u]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    edges.sort_by(|lhs, rhs| lhs.w.cmp(&amp;rhs.w));</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = nodes_num;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..edges.len() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (p1, p2) = (find(edges[i].u, &amp;<span class=\"keyword\">mut</span> parent), find(edges[i].v, &amp;<span class=\"keyword\">mut</span> parent));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1 != p2 &#123;</span><br><span class=\"line\">            parent[p1] = p2;</span><br><span class=\"line\">            ans += edges[i].w;</span><br><span class=\"line\">            cnt -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cnt == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> cnt == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">i32</span>::MAX</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> edges = <span class=\"built_in\">Vec</span>::with_capacity(m);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                edges.push(Edge &#123; u, v, w &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ans = kruskal(&amp;<span class=\"keyword\">mut</span> edges, n);</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;&quot;</span>, <span class=\"keyword\">if</span> ans == <span class=\"built_in\">i32</span>::MAX &#123; <span class=\"string\">&quot;orz&quot;</span>.to_string() &#125; <span class=\"keyword\">else</span> &#123; ans.to_string() &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"P3378-【模板】堆\"><a href=\"#P3378-【模板】堆\" class=\"headerlink\" title=\"P3378 【模板】堆\"></a>P3378 【模板】堆</h3><blockquote>\n<p>  不想手写，直接用了 std</p>\n</blockquote>\n<h3 id=\"P3370-【模板】字符串哈希\"><a href=\"#P3370-【模板】字符串哈希\" class=\"headerlink\" title=\"P3370 【模板】字符串哈希\"></a>P3370 【模板】字符串哈希</h3><blockquote>\n<p>  交了半天都是 TLE，一开 O2 过了，烦死</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">string_hash</span></span>(s: &amp;<span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> hash = s.chars()</span><br><span class=\"line\">        .fold(<span class=\"number\">0</span>, |<span class=\"keyword\">mut</span> hash: <span class=\"built_in\">i32</span>, ch| &#123;</span><br><span class=\"line\">            hash = hash.wrapping_add(ch <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>);</span><br><span class=\"line\">            hash = hash.wrapping_add(hash.wrapping_shl(<span class=\"number\">10</span>));</span><br><span class=\"line\">            hash ^= hash.wrapping_shr(<span class=\"number\">6</span>);</span><br><span class=\"line\">            hash</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    hash = hash.wrapping_add(hash.wrapping_shl(<span class=\"number\">3</span>));</span><br><span class=\"line\">    hash ^= hash.wrapping_shr(<span class=\"number\">11</span>);</span><br><span class=\"line\">    hash = hash.wrapping_add(hash.wrapping_shl(<span class=\"number\">15</span>));</span><br><span class=\"line\">    hash</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">const MOD: usize = 2147483647;</span></span><br><span class=\"line\"><span class=\"comment\">const POW: usize = 257;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">fn string_hash(s: &amp;String) -&gt; usize &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    s.chars()</span></span><br><span class=\"line\"><span class=\"comment\">        .fold(0, |hash, ch| (hash * POW + (ch as usize)) % MOD)</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n),) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> bucket = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; n];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = <span class=\"number\">0usize</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            bucket[i] = string_hash(&amp;buf);</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bucket.sort();</span><br><span class=\"line\">        (<span class=\"number\">1</span>..n).for_each(|i| <span class=\"keyword\">if</span> bucket[i] == bucket[i - <span class=\"number\">1</span>] &#123; ans -= <span class=\"number\">1</span> &#125; );</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;&quot;</span>, ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"P1177-【模板】快速排序\"><a href=\"#P1177-【模板】快速排序\" class=\"headerlink\" title=\"P1177 【模板】快速排序\"></a>P1177 【模板】快速排序</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">fn sort(vals: &amp;mut Vec&lt;i32&gt;, l: usize, r: usize) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    if r - l &gt; 10 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        quick_sort(vals, l, r);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        insert_sort(vals, l, r);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">quick_sort</span></span>(vals: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, l: <span class=\"built_in\">usize</span>, r: <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l &gt;= r &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = l;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> j = r;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pivot = vals[((l + r) &gt;&gt; <span class=\"number\">1</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt;= j &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pivot &gt; vals[i] &#123;</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pivot &lt; vals[j] &#123;</span><br><span class=\"line\">            j -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt;= j &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> tmp = vals[i];</span><br><span class=\"line\">            vals[i] = vals[j];</span><br><span class=\"line\">            vals[j] = tmp;</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">            j -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    quick_sort(vals, l, j);</span><br><span class=\"line\">    quick_sort(vals, i, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">fn insert_sort(vals: &amp;mut Vec&lt;i32&gt;, l: usize, r: usize) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    for i in l..=r &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut j = i;</span></span><br><span class=\"line\"><span class=\"comment\">        let pivot = vals[i];</span></span><br><span class=\"line\"><span class=\"comment\">        while j &gt;= 1 &amp;&amp; vals[j - 1] &gt; pivot &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            vals[j] = vals[j - 1];</span></span><br><span class=\"line\"><span class=\"comment\">            j -= 1;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        vals[j] = pivot;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n),) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        getline!(cin, buf);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vals = buf</span><br><span class=\"line\">            .split(<span class=\"built_in\">char</span>::is_whitespace)</span><br><span class=\"line\">            .map(|i| i.parse::&lt;<span class=\"built_in\">i32</span>&gt;())</span><br><span class=\"line\">            .filter(|i| i.is_ok())</span><br><span class=\"line\">            .map(|i| i.unwrap())</span><br><span class=\"line\">            .collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = vals.len();</span><br><span class=\"line\">        <span class=\"built_in\">assert_eq!</span>(len, n);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = vals.len();</span><br><span class=\"line\">        quick_sort(&amp;<span class=\"keyword\">mut</span> vals, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">        vals.iter().for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;0&#125; &quot;</span>, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>普及 / 提高-<br>P1886 【模板】单调队列 / 滑动窗口<br>P3382 【模板】三分法<br>P3374 【模板】树状数组 1<br>P3811 【模板】乘法逆元<br>P3372 【模板】线段树 1<br>P3375 【模板】KMP字符串匹配<br>P3368 【模板】树状数组 2<br>P3379 【模板】最近公共祖先（LCA）<br>P1939 【模板】矩阵加速（数列）<br>P3385 【模板】负环<br>P3865 【模板】ST 表<br>P3390 【模板】矩阵快速幂<br>P4549 【模板】裴蜀定理<br>P4779 【模板】单源最短路径（标准版）<br>P5788 【模板】单调栈<br>普及+ / 提高<br>P5431 【模板】乘法逆元2<br>P5367 【模板】康托展开<br>P5960 【模板】差分约束算法<br>P2613 【模板】有理数取余<br>P2252 【模板】威佐夫博弈 / [SHOI2002] 取石子游戏<br>P3373 【模板】线段树 2<br>P5905 【模板】Johnson 全源最短路<br>P2197 【模板】nim 游戏<br>P3387 【模板】缩点<br>P1439 【模板】最长公共子序列<br>P3386 【模板】二分图最大匹配<br>P3388 【模板】割点（割顶）<br>P5656 【模板】二元一次不定方程 (exgcd)<br>提高+ / 省选-<br>P3377 【模板】左偏树（可并堆）<br>P3381 【模板】最小费用最大流<br>P3369 【模板】普通平衡树<br>P6091 【模板】原根<br>P4781 【模板】拉格朗日插值<br>P5903 【模板】树上 k 级祖先<br>P5854 【模板】笛卡尔树<br>P6086 【模板】Prufer 序列<br>P1368 【模板】最小表示法<br>P5632 【模板】Stoer-Wagner算法<br>P5490 【模板】扫描线<br>P3805 【模板】manacher 算法<br>P1495 【模板】中国剩余定理(CRT)/曹冲养猪<br>P2742 【模板】二维凸包 / [USACO5.1]圈奶牛Fencing the Cows<br>P3389 【模板】高斯消元法<br>P4783 【模板】矩阵求逆<br>P3796 【模板】AC自动机（加强版）<br>P3808 【模板】AC自动机（简单版）<br>P5826 【模板】子序列自动机<br>P3846 【模板】BSGS / [TJOI2007] 可爱的质数<br>P3376 【模板】网络最大流<br>P3391 【模板】文艺平衡树<br>P5091 【模板】扩展欧拉定理<br>P3807 【模板】卢卡斯定理/Lucas 定理<br>P3384 【模板】轻重链剖分/树链剖分<br>P3812 【模板】线性基<br>P3919 【模板】可持久化线段树 1（可持久化数组）<br>P3834 【模板】可持久化线段树 2（主席树）<br>P7112 【模板】行列式求值<br>P1919 【模板】A*B Problem升级版（FFT快速傅里叶）<br>P3803 【模板】多项式乘法（FFT）<br>P4525 【模板】自适应辛普森法1<br>省选 / NOI-<br>P4196 【模板】半平面交 / [CQOI2006]凸多边形<br>P1452 【模板】旋转卡壳 / [USACO03FALL]Beauty Contest G<br>P3809 【模板】后缀排序<br>P6177 【模板】树分块 / Count on a tree II<br>P5906 【模板】回滚莫队&amp;不删除莫队<br>P4782 【模板】2-SAT 问题<br>P5357 【模板】AC自动机（二次加强版）<br>P4719 【模板】”动态 DP”&amp;动态树分治<br>P5055 【模板】可持久化文艺平衡树<br>P5236 【模板】静态仙人掌<br>P5394 【模板】下降幂多项式乘法<br>P5496 【模板】回文自动机（PAM）<br>P5494 【模板】线段树分裂<br>P6136 【模板】普通平衡树（数据加强版）<br>P6114 【模板】Lyndon 分解<br>P5807 【模板】BEST 定理 / Which Dreamed It<br>P6139 【模板】广义后缀自动机（广义 SAM）<br>P6329 【模板】点分树 | 震波<br>P4213 【模板】杜教筛（Sum）<br>P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)<br>P5043 【模板】树同构 / [BJOI2015] 树的同构<br>P5192 【模板】有源汇上下界最大流 / Zoj3229 Shoot the Bullet|东方文花帖|<br>P5491 【模板】二次剩余<br>P3804 【模板】后缀自动机 (SAM)<br>P3810 【模板】三维偏序（陌上花开）<br>P4526 【模板】自适应辛普森法2<br>P4777 【模板】扩展中国剩余定理（EXCRT）<br>P4716 【模板】最小树形图<br>P4718 【模板】Pollard-Rho算法<br>P4725 【模板】多项式对数函数（多项式 ln）<br>P4929 【模板】舞蹈链（DLX）<br>P5787 【模板】线段树分治 / 二分图<br>P6113 【模板】一般图最大匹配<br>P3835 【模板】可持久化平衡树<br>P4195 【模板】扩展 BSGS/exBSGS<br>P6097 【模板】子集卷积<br>P6178 【模板】Matrix-Tree 定理<br>P6164 【模板】后缀平衡树<br>P6242 【模板】线段树 3<br>P3806 【模板】点分治1<br>P4556 【模板】线段树合并 / [Vani有约会]雨天的尾巴<br>P4751 【模板】”动态DP”&amp;动态树分治（加强版）<br>P4721 【模板】分治 FFT<br>P5410 【模板】扩展 KMP（Z 函数）<br>P5829 【模板】失配树<br>P6192 【模板】最小斯坦纳树<br>P4720 【模板】扩展卢卡斯定理/exLucas<br>P3690 【模板】动态树（Link Cut Tree）<br>P4722 【模板】最大流 加强版 / 预流推进<br>P3380 【模板】二逼平衡树（树套树）<br>P4245 【模板】任意模数多项式乘法<br>P7173 【模板】有负圈的费用流<br>P5245 【模板】多项式快速幂<br>P4238 【模板】多项式乘法逆<br>P4897 【模板】最小割树（Gomory-Hu Tree）<br>P4980 【模板】Pólya 定理<br>P6657 【模板】LGV 引理<br>P5205 【模板】多项式开根<br>P4512 【模板】多项式除法<br>P5277 【模板】多项式开根（加强版）<br>P4726 【模板】多项式指数函数（多项式 exp）<br>P5273 【模板】多项式幂函数 (加强版)<br>P6577 【模板】二分图最大权完美匹配<br>P6800 【模板】Chirp Z-Transform<br>NOI / NOI+ / CTSC<br>P4724 【模板】三维凸包<br>P5180 【模板】支配树<br>P4723 【模板】常系数齐次线性递推<br>P2483 【模板】k短路 / [SDOI2010]魔法猪学院<br>P5050 【模板】多项式多点求值<br>P5282 【模板】快速阶乘算法<br>P5325 【模板】Min_25筛<br>P5247 【模板】动态图完全连通性<br>P5809 【模板】多项式复合逆<br>P5056 【模板】插头dp<br>P5373 【模板】多项式复合函数<br>P5808 【模板】常系数非齐次线性递推<br>P5487 【模板】Berlekamp-Massey算法<br>P5668 【模板】N次剩余<br>P5158 【模板】多项式快速插值<br>P4887 【模板】莫队二次离线（第十四分块(前体)）<br>P5170 【模板】类欧几里得算法<br>P6699 【模板】一般图最大权匹配<br>P6656 【模板】Runs<br>P6115 【模板】整式递推</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"洛谷模板题集合\"><a href=\"#洛谷模板题集合\" class=\"headerlink\" title=\"洛谷模板题集合\"></a>洛谷模板题集合</h1><blockquote>\n<p>参考<a href=\"https://www.cnblogs.com/Ender-hz/p/15018563.html\">这篇文章</a>列出的题目</p>\n</blockquote>\n<h2 id=\"0-工具宏-amp-包导入声明\"><a href=\"#0-工具宏-amp-包导入声明\" class=\"headerlink\" title=\"0. 工具宏 &amp; 包导入声明\"></a>0. 工具宏 &amp; 包导入声明</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Dummy Luogu/LeetCode Playground</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BinaryHeap, HashMap, HashSet, VecDeque, BTreeMap&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::convert::&#123;<span class=\"built_in\">From</span>, <span class=\"built_in\">Into</span>, TryFrom, TryInto&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> init_cin &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#123;</span><br><span class=\"line\">        (io::stdin(), <span class=\"built_in\">String</span>::new())</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> scanf &#123;</span><br><span class=\"line\">    ($buf: expr, $div: expr, $($x:ty), +) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> iter = $buf.split($div);</span><br><span class=\"line\">        ($(iter.next().and_then(|token| token.parse::&lt;$x&gt;().ok()), ) *)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> getline &#123;</span><br><span class=\"line\">    ($cin: expr, $buf: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $buf.clear();</span><br><span class=\"line\">        $cin.read_line(&amp;<span class=\"keyword\">mut</span> $buf)?;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-普及\"><a href=\"#1-普及\" class=\"headerlink\" title=\"1. 普及-\"></a>1. 普及-</h2><h3 id=\"P3367-并查集\"><a href=\"#P3367-并查集\" class=\"headerlink\" title=\"P3367 并查集\"></a>P3367 并查集</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DisjointSet</span></span>&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"built_in\">Sized</span> + <span class=\"built_in\">Eq</span> + <span class=\"built_in\">Copy</span> + TryInto&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    parent: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    rank: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    phantom: PhantomData&lt;T&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; DisjointSet&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"built_in\">Sized</span> + <span class=\"built_in\">Eq</span> + <span class=\"built_in\">Copy</span> + TryInto&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            parent: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; cap],</span><br><span class=\"line\">            rank: <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; cap],</span><br><span class=\"line\">            phantom: PhantomData,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">modify</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T, p: <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> x.try_into() &#123;</span><br><span class=\"line\">            <span class=\"literal\">Ok</span>(x) =&gt; &#123; <span class=\"keyword\">self</span>.parent[x] = p; &#125;,</span><br><span class=\"line\">            <span class=\"literal\">Err</span>(_) =&gt; <span class=\"built_in\">panic!</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">union</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T, y: T) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> fx, <span class=\"keyword\">mut</span> fy) = (<span class=\"keyword\">self</span>.find(x), <span class=\"keyword\">self</span>.find(y));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fx == fy || fx == <span class=\"built_in\">usize</span>::MAX || fy == <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fx] &gt; <span class=\"keyword\">self</span>.rank[fy] &#123;</span><br><span class=\"line\">                std::mem::swap(&amp;<span class=\"keyword\">mut</span> fx, &amp;<span class=\"keyword\">mut</span> fy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[fx] = fy;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fx] == <span class=\"keyword\">self</span>.rank[fy] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.rank[fy] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: T) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> x.try_into() &#123;</span><br><span class=\"line\">            <span class=\"literal\">Ok</span>(x) =&gt; <span class=\"keyword\">self</span>.find_wrapper(x),</span><br><span class=\"line\">            <span class=\"literal\">Err</span>(_) =&gt; <span class=\"built_in\">usize</span>::MAX</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find_wrapper</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, x: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != <span class=\"keyword\">self</span>.parent[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[x] = <span class=\"keyword\">self</span>.find_wrapper(<span class=\"keyword\">self</span>.parent[x]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent[x]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cin = io::stdin();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buf = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"comment\">// n m</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dsj = DisjointSet::&lt;<span class=\"built_in\">i32</span>&gt;::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">        (<span class=\"number\">1</span>..=n).for_each(|i| dsj.modify(i, i <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>));</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(op), <span class=\"literal\">Some</span>(arg1), <span class=\"literal\">Some</span>(arg2)) =</span><br><span class=\"line\">                scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">match</span> op &#123;</span><br><span class=\"line\">                    <span class=\"number\">1</span> =&gt; &#123; dsj.union(arg1, arg2); &#125;,</span><br><span class=\"line\">                    <span class=\"number\">2</span> =&gt; &#123; <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:&#125;&quot;</span>, <span class=\"keyword\">if</span> dsj.find(arg1) == dsj.find(arg2) &amp;&amp; dsj.find(arg1) != <span class=\"built_in\">usize</span>::MAX &#123;<span class=\"string\">&quot;Y&quot;</span>&#125; <span class=\"keyword\">else</span> &#123;<span class=\"string\">&quot;N&quot;</span>&#125;)&#125;,</span><br><span class=\"line\">                    _ =&gt; <span class=\"built_in\">unreachable!</span>()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P3371-单源最短路（非随机数据）\"><a href=\"#P3371-单源最短路（非随机数据）\" class=\"headerlink\" title=\"P3371 单源最短路（非随机数据）\"></a>P3371 单源最短路（非随机数据）</h3><blockquote>\n<p>看描述似乎允许 SPFA ，但是原版 SPFA 还是被卡掉了三个用例</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> my &#123;</span><br><span class=\"line\">    <span class=\"meta\">#[derive(Debug, Clone)]</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFSNode</span></span> &#123;</span><br><span class=\"line\">        to: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">        next: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">        w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">        edges: <span class=\"built_in\">Vec</span>&lt;LFSNode&gt;,</span><br><span class=\"line\">        head: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">        tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(nodes: <span class=\"built_in\">usize</span>, edges: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">                edges: <span class=\"built_in\">vec!</span>[</span><br><span class=\"line\">                    LFSNode &#123;</span><br><span class=\"line\">                        to: <span class=\"built_in\">usize</span>::MAX,</span><br><span class=\"line\">                        next: <span class=\"built_in\">usize</span>::MAX,</span><br><span class=\"line\">                        w: <span class=\"number\">0</span></span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                    edges</span><br><span class=\"line\">                ],</span><br><span class=\"line\">                head: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; nodes],</span><br><span class=\"line\">                tot: <span class=\"number\">0</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, dst: <span class=\"built_in\">usize</span>, weight: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].next = <span class=\"keyword\">self</span>.head[src];</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].to = dst;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].w = weight;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.head[src] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">spfa_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.tot];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> queue = <span class=\"built_in\">vec!</span>[src];</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !queue.is_empty() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> x = queue.pop().unwrap();</span><br><span class=\"line\">            vis[x] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = lfs.head[x];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> y = lfs.edges[i].to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[y] - lfs.edges[i].w &gt; dist[x] &#123;</span><br><span class=\"line\">                    dist[y] = dist[x] + lfs.edges[i].w;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> !vis[y] &#123;</span><br><span class=\"line\">                        vis[y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        queue.push(y);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i = lfs.edges[i].next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dist</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> x = src;</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !vis[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> curr = <span class=\"built_in\">i32</span>::MAX;</span><br><span class=\"line\">            vis[x] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> y = lfs.head[x];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> y != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> !vis[lfs.edges[y].to] &amp;&amp; dist[lfs.edges[y].to] - lfs.edges[y].w &gt; dist[x] &#123;</span><br><span class=\"line\">                    dist[lfs.edges[y].to] = dist[x] + lfs.edges[y].w;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                y = lfs.edges[y].next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..lfs.head.len() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[i] &lt; curr &amp;&amp; !vis[i] &#123;</span><br><span class=\"line\">                    curr = dist[i];</span><br><span class=\"line\">                    x = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dist</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">use</span> my::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m), <span class=\"literal\">Some</span>(src)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(n + <span class=\"number\">1</span>, m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                lfs.add(u, v, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// spfa_solver(lfs, src)</span></span><br><span class=\"line\">        dijkstra_solver(lfs, src)</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">            .for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;:&#125; &quot;</span>, i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P1226-快速幂\"><a href=\"#P1226-快速幂\" class=\"headerlink\" title=\"P1226 快速幂\"></a>P1226 快速幂</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">fast_pow</span></span>(x: <span class=\"built_in\">i64</span>, n: <span class=\"built_in\">i64</span>, m: <span class=\"built_in\">i64</span>) -&gt; <span class=\"built_in\">i64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> x, <span class=\"keyword\">mut</span> n, <span class=\"keyword\">mut</span> ret) = (x, n, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            ret *= x;</span><br><span class=\"line\">            ret %= m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x *= x;</span><br><span class=\"line\">        x %= m;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret % m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(x), <span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">i64</span>, <span class=\"built_in\">i64</span>, <span class=\"built_in\">i64</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;^&#123;1&#125; mod &#123;2&#125;=&#123;3&#125;&quot;</span>, x, n, m, fast_pow(x, n, m));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"P4779-单源最短路（标准）\"><a href=\"#P4779-单源最短路（标准）\" class=\"headerlink\" title=\"P4779 单源最短路（标准）\"></a>P4779 单源最短路（标准）</h3><blockquote>\n<p>不优化的 Dijkstra 也寄了，堆优化的 AC</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Default, Debug, Clone)]</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFSNode</span></span> &#123;</span><br><span class=\"line\">    to: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    next: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkedForwardStar</span></span> &#123;</span><br><span class=\"line\">    edges: <span class=\"built_in\">Vec</span>&lt;LFSNode&gt;,</span><br><span class=\"line\">    head: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    tot: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> LinkedForwardStar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(node_cap: <span class=\"built_in\">usize</span>, edge_cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            edges: <span class=\"built_in\">vec!</span>[LFSNode::default(); edge_cap],</span><br><span class=\"line\">            head: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">usize</span>::MAX; node_cap],</span><br><span class=\"line\">            tot: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, src: <span class=\"built_in\">usize</span>, dst: <span class=\"built_in\">usize</span>, weight: <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].next = <span class=\"keyword\">self</span>.head[src];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].to = dst;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.edges[<span class=\"keyword\">self</span>.tot].w = weight;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.head[src] = <span class=\"keyword\">self</span>.tot;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">spfa_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.tot];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> queue = <span class=\"built_in\">vec!</span>[src];</span><br><span class=\"line\">    dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> !queue.is_empty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = queue.pop().unwrap();</span><br><span class=\"line\">        vis[x] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = lfs.head[x];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> y = lfs.edges[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[y] - lfs.edges[i].w &gt; dist[x] &#123;</span><br><span class=\"line\">                dist[y] = dist[x] + lfs.edges[i].w;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> !vis[y] &#123;</span><br><span class=\"line\">                    vis[y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    queue.push(y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i = lfs.edges[i].next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dist</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// Dijkstra with Heap optimization</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dijkstra_solver</span></span>(lfs: LinkedForwardStar, src: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vis = <span class=\"built_in\">vec!</span>[<span class=\"literal\">false</span>; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dist = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; lfs.head.len()];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> pq = BinaryHeap::new();</span><br><span class=\"line\">    dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pq.push(Reverse((dist[src], src)));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(Reverse((_, u))) = pq.pop() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> vis[u] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> e = lfs.head[u];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> e != <span class=\"built_in\">usize</span>::MAX &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> v = lfs.edges[e].to;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> w = lfs.edges[e].w;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[v] &gt; dist[u] + w &#123;</span><br><span class=\"line\">                dist[v] = dist[u] + w;</span><br><span class=\"line\">                pq.push(Reverse((dist[v], v)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = lfs.edges[e].next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dist</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m), <span class=\"literal\">Some</span>(src)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> lfs = LinkedForwardStar::with_capacity(n + <span class=\"number\">1</span>, m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                lfs.add(u, v, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// spfa_solver(lfs, src)</span></span><br><span class=\"line\">        dijkstra_solver(lfs, src)</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">            .for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;:&#125; &quot;</span>, i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"P3383-【模板】线性筛素数\"><a href=\"#P3383-【模板】线性筛素数\" class=\"headerlink\" title=\"P3383 【模板】线性筛素数\"></a>P3383 【模板】线性筛素数</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">euler_sieve</span></span>(n: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> valid = <span class=\"built_in\">vec!</span>[<span class=\"literal\">true</span>; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">2</span>..=n &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> valid[i] &#123;</span><br><span class=\"line\">            tot += <span class=\"number\">1</span>;</span><br><span class=\"line\">            ans[tot] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt;= tot &amp;&amp; i * ans[j] &lt;= n &#123;</span><br><span class=\"line\">            valid[i * ans[j]] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i % ans[j] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            j += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans.into_iter().skip(<span class=\"number\">1</span>).take(tot).map(|i| i <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>).collect()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> qs)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> primes = euler_sieve(n);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> qs &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(q),) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;&quot;</span>, primes[q-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            qs -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"P3366-【模板】最小生成树\"><a href=\"#P3366-【模板】最小生成树\" class=\"headerlink\" title=\"P3366 【模板】最小生成树\"></a>P3366 【模板】最小生成树</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span> &#123;</span><br><span class=\"line\">    u: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    v: <span class=\"built_in\">usize</span>,</span><br><span class=\"line\">    w: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Kruskal 算法</span></span><br><span class=\"line\"><span class=\"comment\">/// 复杂度 `M \\log M`</span></span><br><span class=\"line\"><span class=\"comment\">/// 思想：每次取剩下的边权最小的边，如果加上这条边后图中出现了一个环，就不选这条边（可以通过并查集）判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">kruskal</span></span>(edges: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">Vec</span>&lt;Edge&gt;, nodes_num: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> parent = (<span class=\"number\">0</span>..=nodes_num).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(u: <span class=\"built_in\">usize</span>, parent: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> u == parent[u] &#123;</span><br><span class=\"line\">            u</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            parent[u] = find(parent[u], parent);</span><br><span class=\"line\">            parent[u]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    edges.sort_by(|lhs, rhs| lhs.w.cmp(&amp;rhs.w));</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = nodes_num;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..edges.len() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (p1, p2) = (find(edges[i].u, &amp;<span class=\"keyword\">mut</span> parent), find(edges[i].v, &amp;<span class=\"keyword\">mut</span> parent));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1 != p2 &#123;</span><br><span class=\"line\">            parent[p1] = p2;</span><br><span class=\"line\">            ans += edges[i].w;</span><br><span class=\"line\">            cnt -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cnt == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> cnt == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">i32</span>::MAX</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n), <span class=\"literal\">Some</span>(<span class=\"keyword\">mut</span> m)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> edges = <span class=\"built_in\">Vec</span>::with_capacity(m);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> m &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(u), <span class=\"literal\">Some</span>(v), <span class=\"literal\">Some</span>(w)) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>, <span class=\"built_in\">usize</span>, <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                edges.push(Edge &#123; u, v, w &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ans = kruskal(&amp;<span class=\"keyword\">mut</span> edges, n);</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;&quot;</span>, <span class=\"keyword\">if</span> ans == <span class=\"built_in\">i32</span>::MAX &#123; <span class=\"string\">&quot;orz&quot;</span>.to_string() &#125; <span class=\"keyword\">else</span> &#123; ans.to_string() &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"P3378-【模板】堆\"><a href=\"#P3378-【模板】堆\" class=\"headerlink\" title=\"P3378 【模板】堆\"></a>P3378 【模板】堆</h3><blockquote>\n<p>  不想手写，直接用了 std</p>\n</blockquote>\n<h3 id=\"P3370-【模板】字符串哈希\"><a href=\"#P3370-【模板】字符串哈希\" class=\"headerlink\" title=\"P3370 【模板】字符串哈希\"></a>P3370 【模板】字符串哈希</h3><blockquote>\n<p>  交了半天都是 TLE，一开 O2 过了，烦死</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">string_hash</span></span>(s: &amp;<span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> hash = s.chars()</span><br><span class=\"line\">        .fold(<span class=\"number\">0</span>, |<span class=\"keyword\">mut</span> hash: <span class=\"built_in\">i32</span>, ch| &#123;</span><br><span class=\"line\">            hash = hash.wrapping_add(ch <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>);</span><br><span class=\"line\">            hash = hash.wrapping_add(hash.wrapping_shl(<span class=\"number\">10</span>));</span><br><span class=\"line\">            hash ^= hash.wrapping_shr(<span class=\"number\">6</span>);</span><br><span class=\"line\">            hash</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    hash = hash.wrapping_add(hash.wrapping_shl(<span class=\"number\">3</span>));</span><br><span class=\"line\">    hash ^= hash.wrapping_shr(<span class=\"number\">11</span>);</span><br><span class=\"line\">    hash = hash.wrapping_add(hash.wrapping_shl(<span class=\"number\">15</span>));</span><br><span class=\"line\">    hash</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">const MOD: usize = 2147483647;</span></span><br><span class=\"line\"><span class=\"comment\">const POW: usize = 257;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">fn string_hash(s: &amp;String) -&gt; usize &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    s.chars()</span></span><br><span class=\"line\"><span class=\"comment\">        .fold(0, |hash, ch| (hash * POW + (ch as usize)) % MOD)</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n),) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> bucket = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; n];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = <span class=\"number\">0usize</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n &#123;</span><br><span class=\"line\">            getline!(cin, buf);</span><br><span class=\"line\">            bucket[i] = string_hash(&amp;buf);</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bucket.sort();</span><br><span class=\"line\">        (<span class=\"number\">1</span>..n).for_each(|i| <span class=\"keyword\">if</span> bucket[i] == bucket[i - <span class=\"number\">1</span>] &#123; ans -= <span class=\"number\">1</span> &#125; );</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;0&#125;&quot;</span>, ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"P1177-【模板】快速排序\"><a href=\"#P1177-【模板】快速排序\" class=\"headerlink\" title=\"P1177 【模板】快速排序\"></a>P1177 【模板】快速排序</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">fn sort(vals: &amp;mut Vec&lt;i32&gt;, l: usize, r: usize) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    if r - l &gt; 10 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        quick_sort(vals, l, r);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        insert_sort(vals, l, r);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">quick_sort</span></span>(vals: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, l: <span class=\"built_in\">usize</span>, r: <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l &gt;= r &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = l;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> j = r;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pivot = vals[((l + r) &gt;&gt; <span class=\"number\">1</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt;= j &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pivot &gt; vals[i] &#123;</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pivot &lt; vals[j] &#123;</span><br><span class=\"line\">            j -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt;= j &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> tmp = vals[i];</span><br><span class=\"line\">            vals[i] = vals[j];</span><br><span class=\"line\">            vals[j] = tmp;</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">            j -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    quick_sort(vals, l, j);</span><br><span class=\"line\">    quick_sort(vals, i, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">fn insert_sort(vals: &amp;mut Vec&lt;i32&gt;, l: usize, r: usize) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    for i in l..=r &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut j = i;</span></span><br><span class=\"line\"><span class=\"comment\">        let pivot = vals[i];</span></span><br><span class=\"line\"><span class=\"comment\">        while j &gt;= 1 &amp;&amp; vals[j - 1] &gt; pivot &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            vals[j] = vals[j - 1];</span></span><br><span class=\"line\"><span class=\"comment\">            j -= 1;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        vals[j] = pivot;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (cin, <span class=\"keyword\">mut</span> buf) = init_cin!();</span><br><span class=\"line\">    getline!(cin, buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> (<span class=\"literal\">Some</span>(n),) = scanf!(buf, <span class=\"built_in\">char</span>::is_whitespace, <span class=\"built_in\">usize</span>) &#123;</span><br><span class=\"line\">        getline!(cin, buf);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> vals = buf</span><br><span class=\"line\">            .split(<span class=\"built_in\">char</span>::is_whitespace)</span><br><span class=\"line\">            .map(|i| i.parse::&lt;<span class=\"built_in\">i32</span>&gt;())</span><br><span class=\"line\">            .filter(|i| i.is_ok())</span><br><span class=\"line\">            .map(|i| i.unwrap())</span><br><span class=\"line\">            .collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = vals.len();</span><br><span class=\"line\">        <span class=\"built_in\">assert_eq!</span>(len, n);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = vals.len();</span><br><span class=\"line\">        quick_sort(&amp;<span class=\"keyword\">mut</span> vals, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">        vals.iter().for_each(|i| <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;&#123;0&#125; &quot;</span>, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>普及 / 提高-<br>P1886 【模板】单调队列 / 滑动窗口<br>P3382 【模板】三分法<br>P3374 【模板】树状数组 1<br>P3811 【模板】乘法逆元<br>P3372 【模板】线段树 1<br>P3375 【模板】KMP字符串匹配<br>P3368 【模板】树状数组 2<br>P3379 【模板】最近公共祖先（LCA）<br>P1939 【模板】矩阵加速（数列）<br>P3385 【模板】负环<br>P3865 【模板】ST 表<br>P3390 【模板】矩阵快速幂<br>P4549 【模板】裴蜀定理<br>P4779 【模板】单源最短路径（标准版）<br>P5788 【模板】单调栈<br>普及+ / 提高<br>P5431 【模板】乘法逆元2<br>P5367 【模板】康托展开<br>P5960 【模板】差分约束算法<br>P2613 【模板】有理数取余<br>P2252 【模板】威佐夫博弈 / [SHOI2002] 取石子游戏<br>P3373 【模板】线段树 2<br>P5905 【模板】Johnson 全源最短路<br>P2197 【模板】nim 游戏<br>P3387 【模板】缩点<br>P1439 【模板】最长公共子序列<br>P3386 【模板】二分图最大匹配<br>P3388 【模板】割点（割顶）<br>P5656 【模板】二元一次不定方程 (exgcd)<br>提高+ / 省选-<br>P3377 【模板】左偏树（可并堆）<br>P3381 【模板】最小费用最大流<br>P3369 【模板】普通平衡树<br>P6091 【模板】原根<br>P4781 【模板】拉格朗日插值<br>P5903 【模板】树上 k 级祖先<br>P5854 【模板】笛卡尔树<br>P6086 【模板】Prufer 序列<br>P1368 【模板】最小表示法<br>P5632 【模板】Stoer-Wagner算法<br>P5490 【模板】扫描线<br>P3805 【模板】manacher 算法<br>P1495 【模板】中国剩余定理(CRT)/曹冲养猪<br>P2742 【模板】二维凸包 / [USACO5.1]圈奶牛Fencing the Cows<br>P3389 【模板】高斯消元法<br>P4783 【模板】矩阵求逆<br>P3796 【模板】AC自动机（加强版）<br>P3808 【模板】AC自动机（简单版）<br>P5826 【模板】子序列自动机<br>P3846 【模板】BSGS / [TJOI2007] 可爱的质数<br>P3376 【模板】网络最大流<br>P3391 【模板】文艺平衡树<br>P5091 【模板】扩展欧拉定理<br>P3807 【模板】卢卡斯定理/Lucas 定理<br>P3384 【模板】轻重链剖分/树链剖分<br>P3812 【模板】线性基<br>P3919 【模板】可持久化线段树 1（可持久化数组）<br>P3834 【模板】可持久化线段树 2（主席树）<br>P7112 【模板】行列式求值<br>P1919 【模板】A*B Problem升级版（FFT快速傅里叶）<br>P3803 【模板】多项式乘法（FFT）<br>P4525 【模板】自适应辛普森法1<br>省选 / NOI-<br>P4196 【模板】半平面交 / [CQOI2006]凸多边形<br>P1452 【模板】旋转卡壳 / [USACO03FALL]Beauty Contest G<br>P3809 【模板】后缀排序<br>P6177 【模板】树分块 / Count on a tree II<br>P5906 【模板】回滚莫队&amp;不删除莫队<br>P4782 【模板】2-SAT 问题<br>P5357 【模板】AC自动机（二次加强版）<br>P4719 【模板】”动态 DP”&amp;动态树分治<br>P5055 【模板】可持久化文艺平衡树<br>P5236 【模板】静态仙人掌<br>P5394 【模板】下降幂多项式乘法<br>P5496 【模板】回文自动机（PAM）<br>P5494 【模板】线段树分裂<br>P6136 【模板】普通平衡树（数据加强版）<br>P6114 【模板】Lyndon 分解<br>P5807 【模板】BEST 定理 / Which Dreamed It<br>P6139 【模板】广义后缀自动机（广义 SAM）<br>P6329 【模板】点分树 | 震波<br>P4213 【模板】杜教筛（Sum）<br>P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)<br>P5043 【模板】树同构 / [BJOI2015] 树的同构<br>P5192 【模板】有源汇上下界最大流 / Zoj3229 Shoot the Bullet|东方文花帖|<br>P5491 【模板】二次剩余<br>P3804 【模板】后缀自动机 (SAM)<br>P3810 【模板】三维偏序（陌上花开）<br>P4526 【模板】自适应辛普森法2<br>P4777 【模板】扩展中国剩余定理（EXCRT）<br>P4716 【模板】最小树形图<br>P4718 【模板】Pollard-Rho算法<br>P4725 【模板】多项式对数函数（多项式 ln）<br>P4929 【模板】舞蹈链（DLX）<br>P5787 【模板】线段树分治 / 二分图<br>P6113 【模板】一般图最大匹配<br>P3835 【模板】可持久化平衡树<br>P4195 【模板】扩展 BSGS/exBSGS<br>P6097 【模板】子集卷积<br>P6178 【模板】Matrix-Tree 定理<br>P6164 【模板】后缀平衡树<br>P6242 【模板】线段树 3<br>P3806 【模板】点分治1<br>P4556 【模板】线段树合并 / [Vani有约会]雨天的尾巴<br>P4751 【模板】”动态DP”&amp;动态树分治（加强版）<br>P4721 【模板】分治 FFT<br>P5410 【模板】扩展 KMP（Z 函数）<br>P5829 【模板】失配树<br>P6192 【模板】最小斯坦纳树<br>P4720 【模板】扩展卢卡斯定理/exLucas<br>P3690 【模板】动态树（Link Cut Tree）<br>P4722 【模板】最大流 加强版 / 预流推进<br>P3380 【模板】二逼平衡树（树套树）<br>P4245 【模板】任意模数多项式乘法<br>P7173 【模板】有负圈的费用流<br>P5245 【模板】多项式快速幂<br>P4238 【模板】多项式乘法逆<br>P4897 【模板】最小割树（Gomory-Hu Tree）<br>P4980 【模板】Pólya 定理<br>P6657 【模板】LGV 引理<br>P5205 【模板】多项式开根<br>P4512 【模板】多项式除法<br>P5277 【模板】多项式开根（加强版）<br>P4726 【模板】多项式指数函数（多项式 exp）<br>P5273 【模板】多项式幂函数 (加强版)<br>P6577 【模板】二分图最大权完美匹配<br>P6800 【模板】Chirp Z-Transform<br>NOI / NOI+ / CTSC<br>P4724 【模板】三维凸包<br>P5180 【模板】支配树<br>P4723 【模板】常系数齐次线性递推<br>P2483 【模板】k短路 / [SDOI2010]魔法猪学院<br>P5050 【模板】多项式多点求值<br>P5282 【模板】快速阶乘算法<br>P5325 【模板】Min_25筛<br>P5247 【模板】动态图完全连通性<br>P5809 【模板】多项式复合逆<br>P5056 【模板】插头dp<br>P5373 【模板】多项式复合函数<br>P5808 【模板】常系数非齐次线性递推<br>P5487 【模板】Berlekamp-Massey算法<br>P5668 【模板】N次剩余<br>P5158 【模板】多项式快速插值<br>P4887 【模板】莫队二次离线（第十四分块(前体)）<br>P5170 【模板】类欧几里得算法<br>P6699 【模板】一般图最大权匹配<br>P6656 【模板】Runs<br>P6115 【模板】整式递推</p>\n"},{"title":"LeetCode 双周赛 65","date":"2021-11-14T15:22:25.000Z","_content":"\n-----------\n\n# LeetCode 双周赛 65\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-65/problems/check-whether-two-strings-are-almost-equivalent/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-65/problems/walking-robot-simulation-ii/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-65/problems/most-beautiful-item-for-each-query/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-65/problems/maximum-number-of-tasks-you-can-assign/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 634 / 2676 | MiracleSNeko | 8    | 0:50:07  | 0:04:52                                                      |                                                              | 0:45:07 1                                                    |                                                              |\n\n## T1 5910. 检查两个字符串是否几乎相等\n\n-   **通过的用户数**1956\n-   **尝试过的用户数**1988\n-   **用户总通过次数**1977\n-   **用户总提交次数**2707\n-   **题目难度** **Easy**\n\n如果两个字符串 `word1` 和 `word2` 中从 `'a'` 到 `'z'` 每一个字母出现频率之差都 **不超过** `3` ，那么我们称这两个字符串 `word1` 和 `word2` **几乎相等** 。\n\n给你两个长度都为 `n` 的字符串 `word1` 和 `word2` ，如果 `word1` 和 `word2` **几乎相等** ，请你返回 `true` ，否则返回 `false` 。\n\n一个字母 `x` 的出现 **频率** 指的是它在字符串中出现的次数。\n\n \n\n**示例 1：**\n\n```\n输入：word1 = \"aaaa\", word2 = \"bccb\"\n输出：false\n解释：字符串 \"aaaa\" 中有 4 个 'a' ，但是 \"bccb\" 中有 0 个 'a' 。\n两者之差为 4 ，大于上限 3 。\n```\n\n**示例 2：**\n\n```\n输入：word1 = \"abcdeef\", word2 = \"abaaacc\"\n输出：true\n解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。\n- 'b' 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。\n- 'c' 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。\n- 'd' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n- 'e' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n- 'f' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n```\n\n**示例 3：**\n\n```\n输入：word1 = \"cccddabba\", word2 = \"babababab\"\n输出：true\n解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。\n- 'b' 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。\n- 'c' 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。\n- 'd' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n```\n\n \n\n**提示：**\n\n-   `n == word1.length == word2.length`\n-   `1 <= n <= 100`\n-   `word1` 和 `word2` 都只包含小写英文字母。\n\n**提交：**\n\n>   简单模拟\n\n```rust\nimpl Solution {\n    pub fn check_almost_equivalent(word1: String, word2: String) -> bool {\n        fn str_to_freq(word: &String) -> Vec<i32> {\n            let mut ret = vec![0; 26];\n            word.bytes().for_each(|ch| ret[(ch - b'a') as usize] += 1);\n            ret\n        }\n        let vec1 = str_to_freq(&word1);\n        let vec2 = str_to_freq(&word2);\n        vec1.iter().zip(vec2.iter()).all(|(v1, v2)| (*v1 - *v2).abs() <= 3)\n    }\n}\n```\n\n\n\n## T2 5911. 模拟行走机器人 II\n\n-   **通过的用户数**694\n-   **尝试过的用户数**1532\n-   **用户总通过次数**711\n-   **用户总提交次数**6760\n-   **题目难度** **Medium**\n\n给你一个在 XY 平面上的 `width x height` 的网格图，**左下角** 的格子为 `(0, 0)` ，**右上角** 的格子为 `(width - 1, height - 1)` 。网格图中相邻格子为四个基本方向之一（`\"North\"`，`\"East\"`，`\"South\"` 和 `\"West\"`）。一个机器人 **初始** 在格子 `(0, 0)` ，方向为 `\"East\"` 。\n\n机器人可以根据指令移动指定的 **步数** 。每一步，它可以执行以下操作。\n\n1.  沿着当前方向尝试 **往前一步** 。\n2.  如果机器人下一步将到达的格子 **超出了边界** ，机器人会 **逆时针** 转 90 度，然后再尝试往前一步。\n\n如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。\n\n请你实现 `Robot` 类：\n\n-   `Robot(int width, int height)` 初始化一个 `width x height` 的网格图，机器人初始在 `(0, 0)` ，方向朝 `\"East\"` 。\n-   `void move(int num)` 给机器人下达前进 `num` 步的指令。\n-   `int[] getPos()` 返回机器人当前所处的格子位置，用一个长度为 2 的数组 `[x, y]` 表示。\n-   `String getDir()` 返回当前机器人的朝向，为 `\"North\"` ，`\"East\"` ，`\"South\"` 或者 `\"West\"` 。\n\n \n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/10/09/example-1.png)\n\n```\n输入：\n[\"Robot\", \"move\", \"move\", \"getPos\", \"getDir\", \"move\", \"move\", \"move\", \"getPos\", \"getDir\"]\n[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]\n输出：\n[null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"]\n\n解释：\nRobot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。\nrobot.move(2);  // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。\nrobot.move(2);  // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。\nrobot.getPos(); // 返回 [4, 0]\nrobot.getDir(); // 返回 \"East\"\nrobot.move(2);  // 朝东移动 1 步到达 (5, 0) ，并朝东。\n                // 下一步继续往东移动将出界，所以逆时针转变方向朝北。\n                // 然后，往北移动 1 步到达 (5, 1) ，并朝北。\nrobot.move(1);  // 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。\nrobot.move(4);  // 下一步继续往北移动将出界，所以逆时针转变方向朝西。\n                // 然后，移动 4 步到 (1, 2) ，并朝西。\nrobot.getPos(); // 返回 [1, 2]\nrobot.getDir(); // 返回 \"West\"\n```\n\n \n\n**提示：**\n\n-   `2 <= width, height <= 100`\n-   `1 <= num <= 105`\n-   `move` ，`getPos` 和 `getDir` **总共** 调用次数不超过 `104` 次。\n\n**答案：**\n\n>   脑筋急转弯，机器人只会在外环转悠。这题 Rust 没法写，move 是个关键字\n\n```c++\nconst int DIR_R[] = {0, 1, 0, -1};\nconst int DIR_C[] = {1, 0, -1, 0};\nvector<string> NAMES = {\"East\", \"North\", \"West\", \"South\"};\n\nclass Robot {\npublic:\n    Robot(int width, int height) {\n        this->width = width;\n        this->height = height;\n        x = y = d = 0;\n    }\n    \n    void move(int num) {\n        int sx = -1, sy = -1, step = 0;\n        while (num--) {\n            if (step && x == sx && y == sy) {\n                num %= step;\n            }\n            if (sx == -1) {\n                if (x == 0 || y == 0 || x == height - 1 || y == width - 1) {\n                    sx = x;\n                    sy = y;\n                    step = 0;\n                }\n            }\n            while (true) {\n                int tx = x + DIR_R[d];\n                int ty = y + DIR_C[d];\n                if (!(0 <= tx && tx < height && 0 <= ty && ty < width)) {\n                    d = (d + 1) % 4;\n                    continue;\n                }\n                x = tx;\n                y = ty;\n                ++step;\n                break;\n            }\n        }\n    }\n    \n    vector<int> getPos() {\n        return {y, x};\n    }\n    \n    string getDir() {\n        return NAMES[d];\n    }\n    \nprivate:\n    int width, height;\n    int x, y, d;\n};\n```\n\n\n\n## T3 5912. 每一个查询的最大美丽值\n\n-   **通过的用户数**870\n-   **尝试过的用户数**1264\n-   **用户总通过次数**876\n-   **用户总提交次数**2596\n-   **题目难度** **Medium**\n\n给你一个二维整数数组 `items` ，其中 `items[i] = [pricei, beautyi]` 分别表示每一个物品的 **价格** 和 **美丽值** 。\n\n同时给你一个下标从 **0** 开始的整数数组 `queries` 。对于每个查询 `queries[j]` ，你想求出价格小于等于 `queries[j]` 的物品中，**最大的美丽值** 是多少。如果不存在符合条件的物品，那么查询的结果为 `0` 。\n\n请你返回一个长度与 `queries` 相同的数组 `answer`，其中 `answer[j]`是第 `j` 个查询的答案。\n\n**示例 1：**\n\n```\n输入：items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\n输出：[2,4,5,5,6,6]\n解释：\n- queries[0]=1 ，[1,2] 是唯一价格 <= 1 的物品。所以这个查询的答案为 2 。\n- queries[1]=2 ，符合条件的物品有 [1,2] 和 [2,4] 。\n  它们中的最大美丽值为 4 。\n- queries[2]=3 和 queries[3]=4 ，符合条件的物品都为 [1,2] ，[3,2] ，[2,4] 和 [3,5] 。\n  它们中的最大美丽值为 5 。\n- queries[4]=5 和 queries[5]=6 ，所有物品都符合条件。\n  所以，答案为所有物品中的最大美丽值，为 6 。\n```\n\n**示例 2：**\n\n```\n输入：items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\n输出：[4]\n解释：\n每个物品的价格均为 1 ，所以我们选择最大美丽值 4 。\n注意，多个物品可能有相同的价格和美丽值。\n```\n\n**示例 3：**\n\n```\n输入：items = [[10,1000]], queries = [5]\n输出：[0]\n解释：\n没有物品的价格小于等于 5 ，所以没有物品可以选择。\n因此，查询的结果为 0 。\n```\n\n**提示：**\n\n-   `1 <= items.length, queries.length <= 105`\n-   `items[i].length == 2`\n-   `1 <= pricei, beautyi, queries[j] <= 109`\n\n**提交：**\n\n>   离线查询，其实只需要前缀最大值即可。哪怕写个树状数组也比 ST 表简单啊……\n\n```rust\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::convert::{From, Into, TryFrom, TryInto};\n// use std::io::{self, BufRead, BufReader, BufWriter, Write};\nuse std::marker::PhantomData;\nuse std::rc::Rc;\n\nmacro_rules! new_bufio {\n    () => {{\n        (io::stdin(), io::stdout(), String::new())\n    }};\n}\nmacro_rules! init_stdio {\n    ($cin: expr, $cout: expr) => {{\n        (BufReader::new($cin.lock()), BufWriter::new($cout.lock()))\n    }};\n}\nmacro_rules! scanf {\n    ($buf: expr, $div: expr, $($x: ty), +) => {{\n        let mut iter = $buf.split($div);\n        ($(iter.next().and_then(|token| token.parse::<$x>().ok()),)*)\n    }};\n}\nmacro_rules! getline {\n    ($cin: expr, $buf: expr) => {{\n        $buf.clear();\n        $cin.read_line(&mut $buf)?;\n    }};\n}\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\nmacro_rules! lowbit {\n    ($x: expr) => {{\n        $x & (!$x + 1)\n    }};\n}\n\nimpl Solution {\n    pub fn maximum_beauty(mut items: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\n        // discrete\n        items.sort_by(|v1, v2| v1[0].cmp(&v2[0]));\n        let mut pris = vec![];\n        let mut btys = vec![];\n        items.iter().for_each(|v| {\n            pris.push(v[0]);\n            btys.push(v[1]);\n        });\n        // println!(\"{:?}, {:?}\", pris, btys);\n        // sparse table\n        let mut st = vec![vec![0; 20]; 100010];\n        let mut prelog = vec![0; 100010];\n        let n = items.len();\n        for i in 2..100010 {\n            prelog[i] = prelog[i - 1] + if (1 << prelog[i - 1] + 1) == i { 1 } else { 0 };\n        }\n        for i in (0..n).rev() {\n            st[i][0] = btys[i];\n            for j in 1..20 {\n                if i + (1 << j - 1) >= n {\n                    break;\n                }\n                st[i][j] = st[i][j - 1].max(st[i + (1 << j - 1)][j - 1]);\n            }\n        }\n        // println!(\"{:?},{:?},{:?},{:?}\", st[0], st[1], st[2], st[3]);\n        // query\n        let mut ans = vec![];\n        for q in queries {\n            if q < pris[0] {\n                ans.push(0);\n            } else {\n                let mut pos = 0;\n                if q >= pris[n - 1] {\n                    pos = n - 1;\n                } else {\n                    pos = Solution::upper_bound(&pris, q) - 1;\n                }\n                // println!(\"{:?}\", pos);\n                let k = prelog[pos + 1];\n                // 这个地方 l 恒为 0，但是比赛的时候把 ST 表的查询写成了 l = k ……\n                ans.push(st[0][k].max(st[pos + 1 - (1 << k)][k]));\n            }\n        }\n        ans\n    }\n\n    fn upper_bound(vals: &Vec<i32>, tar: i32) -> usize {\n        let mut l = 0;\n        let mut r = vals.len() - 1;\n        while l < r {\n            let m = (l + r) >> 1;\n            if vals[m] > tar {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n}\n```\n\n\n\n## T4 5913. 你可以安排的最多任务数目\n\n-   **通过的用户数**84\n-   **尝试过的用户数**254\n-   **用户总通过次数**93\n-   **用户总提交次数**526\n-   **题目难度** **Hard**\n\n给你 `n` 个任务和 `m` 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 **0** 开始的整数数组 `tasks` 中，第 `i` 个任务需要 `tasks[i]` 的力量才能完成。每个工人的力量值保存在下标从 **0** 开始的整数数组 `workers` 中，第 `j` 个工人的力量值为 `workers[j]` 。每个工人只能完成 **一个** 任务，且力量值需要 **大于等于** 该任务的力量要求值（即 `workers[j] >= tasks[i]` ）。\n\n除此以外，你还有 `pills` 个神奇药丸，可以给 **一个工人的力量值** 增加 `strength` 。你可以决定给哪些工人使用药丸，但每个工人 **最多** 只能使用 **一片** 药丸。\n\n给你下标从 **0** 开始的整数数组`tasks` 和 `workers` 以及两个整数 `pills` 和 `strength` ，请你返回 **最多** 有多少个任务可以被完成。\n\n**示例 1：**\n\n```\n输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1\n输出：3\n解释：\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 2（0 + 1 >= 1）\n- 1 号工人完成任务 1（3 >= 2）\n- 2 号工人完成任务 0（3 >= 3）\n```\n\n**示例 2：**\n\n```\n输入：tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5\n输出：1\n解释：\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 0（0 + 5 >= 5）\n```\n\n**示例 3：**\n\n```\n输入：tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\n输出：2\n解释：\n我们可以按照如下方案安排药丸：\n- 给 0 号和 1 号工人药丸。\n- 0 号工人完成任务 0（0 + 10 >= 10）\n- 1 号工人完成任务 1（10 + 10 >= 15）\n```\n\n**示例 4：**\n\n```\n输入：tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5\n输出：3\n解释：\n我们可以按照如下方案安排药丸：\n- 给 2 号工人药丸。\n- 1 号工人完成任务 0（6 >= 5）\n- 2 号工人完成任务 2（4 + 5 >= 8）\n- 4 号工人完成任务 3（6 >= 5）\n```\n\n**提示：**\n\n-   `n == tasks.length`\n-   `m == workers.length`\n-   `1 <= n, m <= 5 * 104`\n-   `0 <= pills <= m`\n-   `0 <= tasks[i], workers[j], strength <= 109`\n\n**思路：**\n\n>   二分答案+贪心\n>   本题显然具有决策单调性：如果能安排K个任务，一定能安排K-1个任务；如果不能安排K个任务，一定不能安排K+1个任务，因此可以二分答案。\n>\n>   现在考虑安排K个任务。显然，我们应该选择最容易的K个任务，同时选择最强的K个人。\n>\n>   我们从难到易来考虑这K个任务。\n>\n>   一种贪心策略是：\n>\n>   如果有人能完成当前任务，我们就安排其中能力值最小的那个人去做这一任务。\n>   如果没有人能完成当前任务，但当前有药，并且有人能在服药后完成这一任务，我们就安排其中能力值最小的那个人去做这一任务。\n>   否则说明无法完成K个任务。\n>   另一种贪心策略是：\n>\n>   如果当前有药，我们就安排服药后能够完成任务的人中能力值最小的那个人去做这一任务。但要注意这个人可能不吃药也能完成任务，此时就不必吃药了。\n>   如果当前没有药，我们就安排能完成任务的人中能力值最小的那个人去做这一任务。\n>   否则说明无法完成K个任务。\n>   这两种贪心策略都是正确的。我们可以这样考虑：在有药丸的情况下，可能会存在A服药能完成任务，B不服药也能完成任务这样的情形。此时我们应该选择谁呢？实际上，因为后面的任务只会更简单，所以A+药或B都一定能完成后面的任务，因此此时使用A+药或使用B其实对后面的任务没有影响。\n>\n>   时间复杂度\\mathcal{O}(N\\log^2N)。\n>   空间复杂度\\mathcal{O}(N)。\n>\n>   作者：吴自华\n>   链接：https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\n>   来源：力扣（LeetCode）\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```c++\nclass Solution {\npublic:\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\n        int n = tasks.size(), m = workers.size();\n        \n        sort(tasks.begin(), tasks.end());\n        sort(workers.begin(), workers.end());\n        \n        auto check = [&](int k) {\n            if (m < k)\n                return false;\n            \n            multiset<int> ms(workers.rbegin(), workers.rbegin() + k);\n            int rem = pills;\n            for (int i = k - 1; i >= 0; --i) {\n                // 贪心策略1\n                auto it = ms.lower_bound(tasks[i]);\n                if (it == ms.end()) {\n                    if (rem == 0)\n                        return false;\n                    it = ms.lower_bound(tasks[i] - strength);\n                    if (it == ms.end())\n                        return false;\n                    rem--;\n                    ms.erase(it);\n                } else {\n                    ms.erase(it);\n                }\n                \n                // 贪心策略2\n                // if (rem) {\n                //     auto it = ms.lower_bound(tasks[i] - strength);\n                //     if (it == ms.end())\n                //         return false;\n                //     if (*it < tasks[i])\n                //         rem--;\n                //     ms.erase(it);\n                // } else {\n                //     auto it = ms.lower_bound(tasks[i]);\n                //     if (it == ms.end())\n                //         return false;\n                //     ms.erase(it);\n                // }\n            }\n            \n            return true;\n        };\n        \n        int lo = 1, hi = n;\n        while (lo <= hi) {\n            int mid = (lo + hi) >> 1;\n                        \n            if (check(mid))\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        \n        return hi;\n    }\n};\n\n作者：吴自华\n链接：https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n>   单调队列\n>   在二分的大框架下，我们也可以从弱到强来考虑选出的K个工人。\n>\n>   显然，每个工人都必须做一个任务，否则总共做不到K个。对于第ii个工人，我们将所有难度值不超过workers[i] + strength的任务维护在一个双端队列中。由于我们已经对任务进行排序，这个队列天然就是一个单调队列。\n>\n>   首先考虑这个工人不吃药的情况。此时我们看队列最前面，也即当前最容易的任务是否能够被完成。如果可以，则让该工人做这个最容易的任务。因为任务是必须要做的，而后面的人能力都比当前这个人要强，所以安排当前这个人来做任务是不亏的。\n>   如果他不吃药就做不了任务，那就必须吃药。吃药之后，我们应该让他做当前最难的任务，也即队尾的任务。\n>   如果吃了药也做不了任何任务，则说明无法完成K个任务。\n>   这样，时间复杂度就优化掉了一个log。\n>\n>   时间复杂度\\mathcal{O}(N\\log N)。\n>   空间复杂度\\mathcal{O}(N)。\n>\n>   作者：吴自华\n>   链接：https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\n>   来源：力扣（LeetCode）\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```c++\nclass Solution {\npublic:\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\n        int n = tasks.size(), m = workers.size();\n        \n        sort(tasks.begin(), tasks.end());\n        sort(workers.begin(), workers.end());\n        \n        auto check = [&](int k) {\n            if (m < k)\n                return false;\n \n            int ptr = -1, rem = pills;\n            deque<int> dq;\n            for (int i = m - k; i < m; ++i) {\n                while (ptr + 1 < k && tasks[ptr + 1] <= workers[i] + strength)\n                    dq.push_back(tasks[++ptr]);\n                if (dq.empty())\n                    return false;\n                if (dq.front() <= workers[i])\n                    dq.pop_front();\n                else if (rem > 0) {\n                    rem--;\n                    dq.pop_back();\n                } else \n                    return false;\n            }\n\n            return true;\n        };\n        \n        int lo = 1, hi = n;\n        while (lo <= hi) {\n            int mid = (lo + hi) >> 1;\n                        \n            if (check(mid))\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        \n        return hi;\n    }\n};\n\n作者：吴自华\n链接：https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","source":"_posts/biweekly-contest-65.md","raw":"---\ntitle: LeetCode 双周赛 65\ndate: 2021-11-14 23:22:25\ntags: LeetCode 周赛总结\n---\n\n-----------\n\n# LeetCode 双周赛 65\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/biweekly-contest-65/problems/check-whether-two-strings-are-almost-equivalent/) | [题目2 (4)](https://leetcode-cn.com/contest/biweekly-contest-65/problems/walking-robot-simulation-ii/) | [题目3 (5)](https://leetcode-cn.com/contest/biweekly-contest-65/problems/most-beautiful-item-for-each-query/) | [题目4 (6)](https://leetcode-cn.com/contest/biweekly-contest-65/problems/maximum-number-of-tasks-you-can-assign/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 634 / 2676 | MiracleSNeko | 8    | 0:50:07  | 0:04:52                                                      |                                                              | 0:45:07 1                                                    |                                                              |\n\n## T1 5910. 检查两个字符串是否几乎相等\n\n-   **通过的用户数**1956\n-   **尝试过的用户数**1988\n-   **用户总通过次数**1977\n-   **用户总提交次数**2707\n-   **题目难度** **Easy**\n\n如果两个字符串 `word1` 和 `word2` 中从 `'a'` 到 `'z'` 每一个字母出现频率之差都 **不超过** `3` ，那么我们称这两个字符串 `word1` 和 `word2` **几乎相等** 。\n\n给你两个长度都为 `n` 的字符串 `word1` 和 `word2` ，如果 `word1` 和 `word2` **几乎相等** ，请你返回 `true` ，否则返回 `false` 。\n\n一个字母 `x` 的出现 **频率** 指的是它在字符串中出现的次数。\n\n \n\n**示例 1：**\n\n```\n输入：word1 = \"aaaa\", word2 = \"bccb\"\n输出：false\n解释：字符串 \"aaaa\" 中有 4 个 'a' ，但是 \"bccb\" 中有 0 个 'a' 。\n两者之差为 4 ，大于上限 3 。\n```\n\n**示例 2：**\n\n```\n输入：word1 = \"abcdeef\", word2 = \"abaaacc\"\n输出：true\n解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。\n- 'b' 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。\n- 'c' 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。\n- 'd' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n- 'e' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n- 'f' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n```\n\n**示例 3：**\n\n```\n输入：word1 = \"cccddabba\", word2 = \"babababab\"\n输出：true\n解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。\n- 'b' 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。\n- 'c' 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。\n- 'd' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n```\n\n \n\n**提示：**\n\n-   `n == word1.length == word2.length`\n-   `1 <= n <= 100`\n-   `word1` 和 `word2` 都只包含小写英文字母。\n\n**提交：**\n\n>   简单模拟\n\n```rust\nimpl Solution {\n    pub fn check_almost_equivalent(word1: String, word2: String) -> bool {\n        fn str_to_freq(word: &String) -> Vec<i32> {\n            let mut ret = vec![0; 26];\n            word.bytes().for_each(|ch| ret[(ch - b'a') as usize] += 1);\n            ret\n        }\n        let vec1 = str_to_freq(&word1);\n        let vec2 = str_to_freq(&word2);\n        vec1.iter().zip(vec2.iter()).all(|(v1, v2)| (*v1 - *v2).abs() <= 3)\n    }\n}\n```\n\n\n\n## T2 5911. 模拟行走机器人 II\n\n-   **通过的用户数**694\n-   **尝试过的用户数**1532\n-   **用户总通过次数**711\n-   **用户总提交次数**6760\n-   **题目难度** **Medium**\n\n给你一个在 XY 平面上的 `width x height` 的网格图，**左下角** 的格子为 `(0, 0)` ，**右上角** 的格子为 `(width - 1, height - 1)` 。网格图中相邻格子为四个基本方向之一（`\"North\"`，`\"East\"`，`\"South\"` 和 `\"West\"`）。一个机器人 **初始** 在格子 `(0, 0)` ，方向为 `\"East\"` 。\n\n机器人可以根据指令移动指定的 **步数** 。每一步，它可以执行以下操作。\n\n1.  沿着当前方向尝试 **往前一步** 。\n2.  如果机器人下一步将到达的格子 **超出了边界** ，机器人会 **逆时针** 转 90 度，然后再尝试往前一步。\n\n如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。\n\n请你实现 `Robot` 类：\n\n-   `Robot(int width, int height)` 初始化一个 `width x height` 的网格图，机器人初始在 `(0, 0)` ，方向朝 `\"East\"` 。\n-   `void move(int num)` 给机器人下达前进 `num` 步的指令。\n-   `int[] getPos()` 返回机器人当前所处的格子位置，用一个长度为 2 的数组 `[x, y]` 表示。\n-   `String getDir()` 返回当前机器人的朝向，为 `\"North\"` ，`\"East\"` ，`\"South\"` 或者 `\"West\"` 。\n\n \n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/10/09/example-1.png)\n\n```\n输入：\n[\"Robot\", \"move\", \"move\", \"getPos\", \"getDir\", \"move\", \"move\", \"move\", \"getPos\", \"getDir\"]\n[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]\n输出：\n[null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"]\n\n解释：\nRobot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。\nrobot.move(2);  // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。\nrobot.move(2);  // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。\nrobot.getPos(); // 返回 [4, 0]\nrobot.getDir(); // 返回 \"East\"\nrobot.move(2);  // 朝东移动 1 步到达 (5, 0) ，并朝东。\n                // 下一步继续往东移动将出界，所以逆时针转变方向朝北。\n                // 然后，往北移动 1 步到达 (5, 1) ，并朝北。\nrobot.move(1);  // 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。\nrobot.move(4);  // 下一步继续往北移动将出界，所以逆时针转变方向朝西。\n                // 然后，移动 4 步到 (1, 2) ，并朝西。\nrobot.getPos(); // 返回 [1, 2]\nrobot.getDir(); // 返回 \"West\"\n```\n\n \n\n**提示：**\n\n-   `2 <= width, height <= 100`\n-   `1 <= num <= 105`\n-   `move` ，`getPos` 和 `getDir` **总共** 调用次数不超过 `104` 次。\n\n**答案：**\n\n>   脑筋急转弯，机器人只会在外环转悠。这题 Rust 没法写，move 是个关键字\n\n```c++\nconst int DIR_R[] = {0, 1, 0, -1};\nconst int DIR_C[] = {1, 0, -1, 0};\nvector<string> NAMES = {\"East\", \"North\", \"West\", \"South\"};\n\nclass Robot {\npublic:\n    Robot(int width, int height) {\n        this->width = width;\n        this->height = height;\n        x = y = d = 0;\n    }\n    \n    void move(int num) {\n        int sx = -1, sy = -1, step = 0;\n        while (num--) {\n            if (step && x == sx && y == sy) {\n                num %= step;\n            }\n            if (sx == -1) {\n                if (x == 0 || y == 0 || x == height - 1 || y == width - 1) {\n                    sx = x;\n                    sy = y;\n                    step = 0;\n                }\n            }\n            while (true) {\n                int tx = x + DIR_R[d];\n                int ty = y + DIR_C[d];\n                if (!(0 <= tx && tx < height && 0 <= ty && ty < width)) {\n                    d = (d + 1) % 4;\n                    continue;\n                }\n                x = tx;\n                y = ty;\n                ++step;\n                break;\n            }\n        }\n    }\n    \n    vector<int> getPos() {\n        return {y, x};\n    }\n    \n    string getDir() {\n        return NAMES[d];\n    }\n    \nprivate:\n    int width, height;\n    int x, y, d;\n};\n```\n\n\n\n## T3 5912. 每一个查询的最大美丽值\n\n-   **通过的用户数**870\n-   **尝试过的用户数**1264\n-   **用户总通过次数**876\n-   **用户总提交次数**2596\n-   **题目难度** **Medium**\n\n给你一个二维整数数组 `items` ，其中 `items[i] = [pricei, beautyi]` 分别表示每一个物品的 **价格** 和 **美丽值** 。\n\n同时给你一个下标从 **0** 开始的整数数组 `queries` 。对于每个查询 `queries[j]` ，你想求出价格小于等于 `queries[j]` 的物品中，**最大的美丽值** 是多少。如果不存在符合条件的物品，那么查询的结果为 `0` 。\n\n请你返回一个长度与 `queries` 相同的数组 `answer`，其中 `answer[j]`是第 `j` 个查询的答案。\n\n**示例 1：**\n\n```\n输入：items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\n输出：[2,4,5,5,6,6]\n解释：\n- queries[0]=1 ，[1,2] 是唯一价格 <= 1 的物品。所以这个查询的答案为 2 。\n- queries[1]=2 ，符合条件的物品有 [1,2] 和 [2,4] 。\n  它们中的最大美丽值为 4 。\n- queries[2]=3 和 queries[3]=4 ，符合条件的物品都为 [1,2] ，[3,2] ，[2,4] 和 [3,5] 。\n  它们中的最大美丽值为 5 。\n- queries[4]=5 和 queries[5]=6 ，所有物品都符合条件。\n  所以，答案为所有物品中的最大美丽值，为 6 。\n```\n\n**示例 2：**\n\n```\n输入：items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\n输出：[4]\n解释：\n每个物品的价格均为 1 ，所以我们选择最大美丽值 4 。\n注意，多个物品可能有相同的价格和美丽值。\n```\n\n**示例 3：**\n\n```\n输入：items = [[10,1000]], queries = [5]\n输出：[0]\n解释：\n没有物品的价格小于等于 5 ，所以没有物品可以选择。\n因此，查询的结果为 0 。\n```\n\n**提示：**\n\n-   `1 <= items.length, queries.length <= 105`\n-   `items[i].length == 2`\n-   `1 <= pricei, beautyi, queries[j] <= 109`\n\n**提交：**\n\n>   离线查询，其实只需要前缀最大值即可。哪怕写个树状数组也比 ST 表简单啊……\n\n```rust\nuse std::cell::RefCell;\nuse std::cmp::{max, min, Reverse};\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::convert::{From, Into, TryFrom, TryInto};\n// use std::io::{self, BufRead, BufReader, BufWriter, Write};\nuse std::marker::PhantomData;\nuse std::rc::Rc;\n\nmacro_rules! new_bufio {\n    () => {{\n        (io::stdin(), io::stdout(), String::new())\n    }};\n}\nmacro_rules! init_stdio {\n    ($cin: expr, $cout: expr) => {{\n        (BufReader::new($cin.lock()), BufWriter::new($cout.lock()))\n    }};\n}\nmacro_rules! scanf {\n    ($buf: expr, $div: expr, $($x: ty), +) => {{\n        let mut iter = $buf.split($div);\n        ($(iter.next().and_then(|token| token.parse::<$x>().ok()),)*)\n    }};\n}\nmacro_rules! getline {\n    ($cin: expr, $buf: expr) => {{\n        $buf.clear();\n        $cin.read_line(&mut $buf)?;\n    }};\n}\nmacro_rules! map_or_insert {\n    ($map: expr, $key: expr, $fn: expr, $val: expr) => {{\n        match $map.get_mut(&$key) {\n            Some(v) => {\n                $fn(v);\n            }\n            None => {\n                $map.insert($key, $val);\n            }\n        }\n    }};\n}\nmacro_rules! lowbit {\n    ($x: expr) => {{\n        $x & (!$x + 1)\n    }};\n}\n\nimpl Solution {\n    pub fn maximum_beauty(mut items: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\n        // discrete\n        items.sort_by(|v1, v2| v1[0].cmp(&v2[0]));\n        let mut pris = vec![];\n        let mut btys = vec![];\n        items.iter().for_each(|v| {\n            pris.push(v[0]);\n            btys.push(v[1]);\n        });\n        // println!(\"{:?}, {:?}\", pris, btys);\n        // sparse table\n        let mut st = vec![vec![0; 20]; 100010];\n        let mut prelog = vec![0; 100010];\n        let n = items.len();\n        for i in 2..100010 {\n            prelog[i] = prelog[i - 1] + if (1 << prelog[i - 1] + 1) == i { 1 } else { 0 };\n        }\n        for i in (0..n).rev() {\n            st[i][0] = btys[i];\n            for j in 1..20 {\n                if i + (1 << j - 1) >= n {\n                    break;\n                }\n                st[i][j] = st[i][j - 1].max(st[i + (1 << j - 1)][j - 1]);\n            }\n        }\n        // println!(\"{:?},{:?},{:?},{:?}\", st[0], st[1], st[2], st[3]);\n        // query\n        let mut ans = vec![];\n        for q in queries {\n            if q < pris[0] {\n                ans.push(0);\n            } else {\n                let mut pos = 0;\n                if q >= pris[n - 1] {\n                    pos = n - 1;\n                } else {\n                    pos = Solution::upper_bound(&pris, q) - 1;\n                }\n                // println!(\"{:?}\", pos);\n                let k = prelog[pos + 1];\n                // 这个地方 l 恒为 0，但是比赛的时候把 ST 表的查询写成了 l = k ……\n                ans.push(st[0][k].max(st[pos + 1 - (1 << k)][k]));\n            }\n        }\n        ans\n    }\n\n    fn upper_bound(vals: &Vec<i32>, tar: i32) -> usize {\n        let mut l = 0;\n        let mut r = vals.len() - 1;\n        while l < r {\n            let m = (l + r) >> 1;\n            if vals[m] > tar {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n}\n```\n\n\n\n## T4 5913. 你可以安排的最多任务数目\n\n-   **通过的用户数**84\n-   **尝试过的用户数**254\n-   **用户总通过次数**93\n-   **用户总提交次数**526\n-   **题目难度** **Hard**\n\n给你 `n` 个任务和 `m` 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 **0** 开始的整数数组 `tasks` 中，第 `i` 个任务需要 `tasks[i]` 的力量才能完成。每个工人的力量值保存在下标从 **0** 开始的整数数组 `workers` 中，第 `j` 个工人的力量值为 `workers[j]` 。每个工人只能完成 **一个** 任务，且力量值需要 **大于等于** 该任务的力量要求值（即 `workers[j] >= tasks[i]` ）。\n\n除此以外，你还有 `pills` 个神奇药丸，可以给 **一个工人的力量值** 增加 `strength` 。你可以决定给哪些工人使用药丸，但每个工人 **最多** 只能使用 **一片** 药丸。\n\n给你下标从 **0** 开始的整数数组`tasks` 和 `workers` 以及两个整数 `pills` 和 `strength` ，请你返回 **最多** 有多少个任务可以被完成。\n\n**示例 1：**\n\n```\n输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1\n输出：3\n解释：\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 2（0 + 1 >= 1）\n- 1 号工人完成任务 1（3 >= 2）\n- 2 号工人完成任务 0（3 >= 3）\n```\n\n**示例 2：**\n\n```\n输入：tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5\n输出：1\n解释：\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 0（0 + 5 >= 5）\n```\n\n**示例 3：**\n\n```\n输入：tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\n输出：2\n解释：\n我们可以按照如下方案安排药丸：\n- 给 0 号和 1 号工人药丸。\n- 0 号工人完成任务 0（0 + 10 >= 10）\n- 1 号工人完成任务 1（10 + 10 >= 15）\n```\n\n**示例 4：**\n\n```\n输入：tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5\n输出：3\n解释：\n我们可以按照如下方案安排药丸：\n- 给 2 号工人药丸。\n- 1 号工人完成任务 0（6 >= 5）\n- 2 号工人完成任务 2（4 + 5 >= 8）\n- 4 号工人完成任务 3（6 >= 5）\n```\n\n**提示：**\n\n-   `n == tasks.length`\n-   `m == workers.length`\n-   `1 <= n, m <= 5 * 104`\n-   `0 <= pills <= m`\n-   `0 <= tasks[i], workers[j], strength <= 109`\n\n**思路：**\n\n>   二分答案+贪心\n>   本题显然具有决策单调性：如果能安排K个任务，一定能安排K-1个任务；如果不能安排K个任务，一定不能安排K+1个任务，因此可以二分答案。\n>\n>   现在考虑安排K个任务。显然，我们应该选择最容易的K个任务，同时选择最强的K个人。\n>\n>   我们从难到易来考虑这K个任务。\n>\n>   一种贪心策略是：\n>\n>   如果有人能完成当前任务，我们就安排其中能力值最小的那个人去做这一任务。\n>   如果没有人能完成当前任务，但当前有药，并且有人能在服药后完成这一任务，我们就安排其中能力值最小的那个人去做这一任务。\n>   否则说明无法完成K个任务。\n>   另一种贪心策略是：\n>\n>   如果当前有药，我们就安排服药后能够完成任务的人中能力值最小的那个人去做这一任务。但要注意这个人可能不吃药也能完成任务，此时就不必吃药了。\n>   如果当前没有药，我们就安排能完成任务的人中能力值最小的那个人去做这一任务。\n>   否则说明无法完成K个任务。\n>   这两种贪心策略都是正确的。我们可以这样考虑：在有药丸的情况下，可能会存在A服药能完成任务，B不服药也能完成任务这样的情形。此时我们应该选择谁呢？实际上，因为后面的任务只会更简单，所以A+药或B都一定能完成后面的任务，因此此时使用A+药或使用B其实对后面的任务没有影响。\n>\n>   时间复杂度\\mathcal{O}(N\\log^2N)。\n>   空间复杂度\\mathcal{O}(N)。\n>\n>   作者：吴自华\n>   链接：https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\n>   来源：力扣（LeetCode）\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```c++\nclass Solution {\npublic:\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\n        int n = tasks.size(), m = workers.size();\n        \n        sort(tasks.begin(), tasks.end());\n        sort(workers.begin(), workers.end());\n        \n        auto check = [&](int k) {\n            if (m < k)\n                return false;\n            \n            multiset<int> ms(workers.rbegin(), workers.rbegin() + k);\n            int rem = pills;\n            for (int i = k - 1; i >= 0; --i) {\n                // 贪心策略1\n                auto it = ms.lower_bound(tasks[i]);\n                if (it == ms.end()) {\n                    if (rem == 0)\n                        return false;\n                    it = ms.lower_bound(tasks[i] - strength);\n                    if (it == ms.end())\n                        return false;\n                    rem--;\n                    ms.erase(it);\n                } else {\n                    ms.erase(it);\n                }\n                \n                // 贪心策略2\n                // if (rem) {\n                //     auto it = ms.lower_bound(tasks[i] - strength);\n                //     if (it == ms.end())\n                //         return false;\n                //     if (*it < tasks[i])\n                //         rem--;\n                //     ms.erase(it);\n                // } else {\n                //     auto it = ms.lower_bound(tasks[i]);\n                //     if (it == ms.end())\n                //         return false;\n                //     ms.erase(it);\n                // }\n            }\n            \n            return true;\n        };\n        \n        int lo = 1, hi = n;\n        while (lo <= hi) {\n            int mid = (lo + hi) >> 1;\n                        \n            if (check(mid))\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        \n        return hi;\n    }\n};\n\n作者：吴自华\n链接：https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n>   单调队列\n>   在二分的大框架下，我们也可以从弱到强来考虑选出的K个工人。\n>\n>   显然，每个工人都必须做一个任务，否则总共做不到K个。对于第ii个工人，我们将所有难度值不超过workers[i] + strength的任务维护在一个双端队列中。由于我们已经对任务进行排序，这个队列天然就是一个单调队列。\n>\n>   首先考虑这个工人不吃药的情况。此时我们看队列最前面，也即当前最容易的任务是否能够被完成。如果可以，则让该工人做这个最容易的任务。因为任务是必须要做的，而后面的人能力都比当前这个人要强，所以安排当前这个人来做任务是不亏的。\n>   如果他不吃药就做不了任务，那就必须吃药。吃药之后，我们应该让他做当前最难的任务，也即队尾的任务。\n>   如果吃了药也做不了任何任务，则说明无法完成K个任务。\n>   这样，时间复杂度就优化掉了一个log。\n>\n>   时间复杂度\\mathcal{O}(N\\log N)。\n>   空间复杂度\\mathcal{O}(N)。\n>\n>   作者：吴自华\n>   链接：https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\n>   来源：力扣（LeetCode）\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```c++\nclass Solution {\npublic:\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\n        int n = tasks.size(), m = workers.size();\n        \n        sort(tasks.begin(), tasks.end());\n        sort(workers.begin(), workers.end());\n        \n        auto check = [&](int k) {\n            if (m < k)\n                return false;\n \n            int ptr = -1, rem = pills;\n            deque<int> dq;\n            for (int i = m - k; i < m; ++i) {\n                while (ptr + 1 < k && tasks[ptr + 1] <= workers[i] + strength)\n                    dq.push_back(tasks[++ptr]);\n                if (dq.empty())\n                    return false;\n                if (dq.front() <= workers[i])\n                    dq.pop_front();\n                else if (rem > 0) {\n                    rem--;\n                    dq.pop_back();\n                } else \n                    return false;\n            }\n\n            return true;\n        };\n        \n        int lo = 1, hi = n;\n        while (lo <= hi) {\n            int mid = (lo + hi) >> 1;\n                        \n            if (check(mid))\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        \n        return hi;\n    }\n};\n\n作者：吴自华\n链接：https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","slug":"biweekly-contest-65","published":1,"updated":"2021-11-17T05:21:51.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8q4000p1cy5c24cgv4b","content":"<hr>\n<h1 id=\"LeetCode-双周赛-65\"><a href=\"#LeetCode-双周赛-65\" class=\"headerlink\" title=\"LeetCode 双周赛 65\"></a>LeetCode 双周赛 65</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-65/problems/check-whether-two-strings-are-almost-equivalent/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-65/problems/walking-robot-simulation-ii/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-65/problems/most-beautiful-item-for-each-query/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-65/problems/maximum-number-of-tasks-you-can-assign/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>634 / 2676</td>\n<td>MiracleSNeko</td>\n<td>8</td>\n<td>0:50:07</td>\n<td>0:04:52</td>\n<td></td>\n<td>0:45:07 1</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5910-检查两个字符串是否几乎相等\"><a href=\"#T1-5910-检查两个字符串是否几乎相等\" class=\"headerlink\" title=\"T1 5910. 检查两个字符串是否几乎相等\"></a>T1 5910. 检查两个字符串是否几乎相等</h2><ul>\n<li>  <strong>通过的用户数</strong>1956</li>\n<li>  <strong>尝试过的用户数</strong>1988</li>\n<li>  <strong>用户总通过次数</strong>1977</li>\n<li>  <strong>用户总提交次数</strong>2707</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>如果两个字符串 <code>word1</code> 和 <code>word2</code> 中从 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 每一个字母出现频率之差都 <strong>不超过</strong> <code>3</code> ，那么我们称这两个字符串 <code>word1</code> 和 <code>word2</code> <strong>几乎相等</strong> 。</p>\n<p>给你两个长度都为 <code>n</code> 的字符串 <code>word1</code> 和 <code>word2</code> ，如果 <code>word1</code> 和 <code>word2</code> <strong>几乎相等</strong> ，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p>一个字母 <code>x</code> 的出现 <strong>频率</strong> 指的是它在字符串中出现的次数。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 = &quot;aaaa&quot;, word2 = &quot;bccb&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：字符串 &quot;aaaa&quot; 中有 4 个 &#x27;a&#x27; ，但是 &quot;bccb&quot; 中有 0 个 &#x27;a&#x27; 。</span><br><span class=\"line\">两者之差为 4 ，大于上限 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 = &quot;abcdeef&quot;, word2 = &quot;abaaacc&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：</span><br><span class=\"line\">- &#x27;a&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。</span><br><span class=\"line\">- &#x27;b&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。</span><br><span class=\"line\">- &#x27;c&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。</span><br><span class=\"line\">- &#x27;d&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。</span><br><span class=\"line\">- &#x27;e&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。</span><br><span class=\"line\">- &#x27;f&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 = &quot;cccddabba&quot;, word2 = &quot;babababab&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：</span><br><span class=\"line\">- &#x27;a&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。</span><br><span class=\"line\">- &#x27;b&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。</span><br><span class=\"line\">- &#x27;c&#x27; 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。</span><br><span class=\"line\">- &#x27;d&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == word1.length == word2.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 100</code></li>\n<li>  <code>word1</code> 和 <code>word2</code> 都只包含小写英文字母。</li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  简单模拟</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_almost_equivalent</span></span>(word1: <span class=\"built_in\">String</span>, word2: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">str_to_freq</span></span>(word: &amp;<span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ret = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">26</span>];</span><br><span class=\"line\">            word.bytes().for_each(|ch| ret[(ch - <span class=\"string\">b&#x27;a&#x27;</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] += <span class=\"number\">1</span>);</span><br><span class=\"line\">            ret</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vec1 = str_to_freq(&amp;word1);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vec2 = str_to_freq(&amp;word2);</span><br><span class=\"line\">        vec1.iter().zip(vec2.iter()).all(|(v1, v2)| (*v1 - *v2).abs() &lt;= <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5911-模拟行走机器人-II\"><a href=\"#T2-5911-模拟行走机器人-II\" class=\"headerlink\" title=\"T2 5911. 模拟行走机器人 II\"></a>T2 5911. 模拟行走机器人 II</h2><ul>\n<li>  <strong>通过的用户数</strong>694</li>\n<li>  <strong>尝试过的用户数</strong>1532</li>\n<li>  <strong>用户总通过次数</strong>711</li>\n<li>  <strong>用户总提交次数</strong>6760</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个在 XY 平面上的 <code>width x height</code> 的网格图，<strong>左下角</strong> 的格子为 <code>(0, 0)</code> ，<strong>右上角</strong> 的格子为 <code>(width - 1, height - 1)</code> 。网格图中相邻格子为四个基本方向之一（<code>&quot;North&quot;</code>，<code>&quot;East&quot;</code>，<code>&quot;South&quot;</code> 和 <code>&quot;West&quot;</code>）。一个机器人 <strong>初始</strong> 在格子 <code>(0, 0)</code> ，方向为 <code>&quot;East&quot;</code> 。</p>\n<p>机器人可以根据指令移动指定的 <strong>步数</strong> 。每一步，它可以执行以下操作。</p>\n<ol>\n<li> 沿着当前方向尝试 <strong>往前一步</strong> 。</li>\n<li> 如果机器人下一步将到达的格子 <strong>超出了边界</strong> ，机器人会 <strong>逆时针</strong> 转 90 度，然后再尝试往前一步。</li>\n</ol>\n<p>如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。</p>\n<p>请你实现 <code>Robot</code> 类：</p>\n<ul>\n<li>  <code>Robot(int width, int height)</code> 初始化一个 <code>width x height</code> 的网格图，机器人初始在 <code>(0, 0)</code> ，方向朝 <code>&quot;East&quot;</code> 。</li>\n<li>  <code>void move(int num)</code> 给机器人下达前进 <code>num</code> 步的指令。</li>\n<li>  <code>int[] getPos()</code> 返回机器人当前所处的格子位置，用一个长度为 2 的数组 <code>[x, y]</code> 表示。</li>\n<li><code>String getDir()</code> 返回当前机器人的朝向，为 <code>&quot;North&quot;</code> ，<code>&quot;East&quot;</code> ，<code>&quot;South&quot;</code> 或者 <code>&quot;West&quot;</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/09/example-1.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;Robot&quot;, &quot;move&quot;, &quot;move&quot;, &quot;getPos&quot;, &quot;getDir&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;getPos&quot;, &quot;getDir&quot;]</span><br><span class=\"line\">[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, [4, 0], &quot;East&quot;, null, null, null, [1, 2], &quot;West&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">Robot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。</span><br><span class=\"line\">robot.move(2);  // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。</span><br><span class=\"line\">robot.move(2);  // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。</span><br><span class=\"line\">robot.getPos(); // 返回 [4, 0]</span><br><span class=\"line\">robot.getDir(); // 返回 &quot;East&quot;</span><br><span class=\"line\">robot.move(2);  // 朝东移动 1 步到达 (5, 0) ，并朝东。</span><br><span class=\"line\">                // 下一步继续往东移动将出界，所以逆时针转变方向朝北。</span><br><span class=\"line\">                // 然后，往北移动 1 步到达 (5, 1) ，并朝北。</span><br><span class=\"line\">robot.move(1);  // 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。</span><br><span class=\"line\">robot.move(4);  // 下一步继续往北移动将出界，所以逆时针转变方向朝西。</span><br><span class=\"line\">                // 然后，移动 4 步到 (1, 2) ，并朝西。</span><br><span class=\"line\">robot.getPos(); // 返回 [1, 2]</span><br><span class=\"line\">robot.getDir(); // 返回 &quot;West&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= width, height &lt;= 100</code></li>\n<li>  <code>1 &lt;= num &lt;= 105</code></li>\n<li>  <code>move</code> ，<code>getPos</code> 和 <code>getDir</code> <strong>总共</strong> 调用次数不超过 <code>104</code> 次。</li>\n</ul>\n<p><strong>答案：</strong></p>\n<blockquote>\n<p>  脑筋急转弯，机器人只会在外环转悠。这题 Rust 没法写，move 是个关键字</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> DIR_R[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> DIR_C[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">vector&lt;string&gt; NAMES = &#123;<span class=\"string\">&quot;East&quot;</span>, <span class=\"string\">&quot;North&quot;</span>, <span class=\"string\">&quot;West&quot;</span>, <span class=\"string\">&quot;South&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Robot</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Robot</span>(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;width = width;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;height = height;</span><br><span class=\"line\">        x = y = d = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sx = <span class=\"number\">-1</span>, sy = <span class=\"number\">-1</span>, step = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (num--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (step &amp;&amp; x == sx &amp;&amp; y == sy) &#123;</span><br><span class=\"line\">                num %= step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sx == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span> || y == <span class=\"number\">0</span> || x == height - <span class=\"number\">1</span> || y == width - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    sx = x;</span><br><span class=\"line\">                    sy = y;</span><br><span class=\"line\">                    step = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tx = x + DIR_R[d];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ty = y + DIR_C[d];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!(<span class=\"number\">0</span> &lt;= tx &amp;&amp; tx &lt; height &amp;&amp; <span class=\"number\">0</span> &lt;= ty &amp;&amp; ty &lt; width)) &#123;</span><br><span class=\"line\">                    d = (d + <span class=\"number\">1</span>) % <span class=\"number\">4</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                x = tx;</span><br><span class=\"line\">                y = ty;</span><br><span class=\"line\">                ++step;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">getPos</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;y, x&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">getDir</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> NAMES[d];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width, height;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y, d;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-5912-每一个查询的最大美丽值\"><a href=\"#T3-5912-每一个查询的最大美丽值\" class=\"headerlink\" title=\"T3 5912. 每一个查询的最大美丽值\"></a>T3 5912. 每一个查询的最大美丽值</h2><ul>\n<li>  <strong>通过的用户数</strong>870</li>\n<li>  <strong>尝试过的用户数</strong>1264</li>\n<li>  <strong>用户总通过次数</strong>876</li>\n<li>  <strong>用户总提交次数</strong>2596</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个二维整数数组 <code>items</code> ，其中 <code>items[i] = [pricei, beautyi]</code> 分别表示每一个物品的 <strong>价格</strong> 和 <strong>美丽值</strong> 。</p>\n<p>同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>queries</code> 。对于每个查询 <code>queries[j]</code> ，你想求出价格小于等于 <code>queries[j]</code> 的物品中，<strong>最大的美丽值</strong> 是多少。如果不存在符合条件的物品，那么查询的结果为 <code>0</code> 。</p>\n<p>请你返回一个长度与 <code>queries</code> 相同的数组 <code>answer</code>，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]</span><br><span class=\"line\">输出：[2,4,5,5,6,6]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- queries[0]=1 ，[1,2] 是唯一价格 &lt;= 1 的物品。所以这个查询的答案为 2 。</span><br><span class=\"line\">- queries[1]=2 ，符合条件的物品有 [1,2] 和 [2,4] 。</span><br><span class=\"line\">  它们中的最大美丽值为 4 。</span><br><span class=\"line\">- queries[2]=3 和 queries[3]=4 ，符合条件的物品都为 [1,2] ，[3,2] ，[2,4] 和 [3,5] 。</span><br><span class=\"line\">  它们中的最大美丽值为 5 。</span><br><span class=\"line\">- queries[4]=5 和 queries[5]=6 ，所有物品都符合条件。</span><br><span class=\"line\">  所以，答案为所有物品中的最大美丽值，为 6 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]</span><br><span class=\"line\">输出：[4]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">每个物品的价格均为 1 ，所以我们选择最大美丽值 4 。</span><br><span class=\"line\">注意，多个物品可能有相同的价格和美丽值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：items = [[10,1000]], queries = [5]</span><br><span class=\"line\">输出：[0]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">没有物品的价格小于等于 5 ，所以没有物品可以选择。</span><br><span class=\"line\">因此，查询的结果为 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= items.length, queries.length &lt;= 105</code></li>\n<li>  <code>items[i].length == 2</code></li>\n<li>  <code>1 &lt;= pricei, beautyi, queries[j] &lt;= 109</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  离线查询，其实只需要前缀最大值即可。哪怕写个树状数组也比 ST 表简单啊……</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::convert::&#123;<span class=\"built_in\">From</span>, <span class=\"built_in\">Into</span>, TryFrom, TryInto&#125;;</span><br><span class=\"line\"><span class=\"comment\">// use std::io::&#123;self, BufRead, BufReader, BufWriter, Write&#125;;</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> new_bufio &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#123;</span><br><span class=\"line\">        (io::stdin(), io::stdout(), <span class=\"built_in\">String</span>::new())</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> init_stdio &#123;</span><br><span class=\"line\">    ($cin: expr, $cout: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        (BufReader::new($cin.lock()), BufWriter::new($cout.lock()))</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> scanf &#123;</span><br><span class=\"line\">    ($buf: expr, $div: expr, $($x: ty), +) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> iter = $buf.split($div);</span><br><span class=\"line\">        ($(iter.next().and_then(|token| token.parse::&lt;$x&gt;().ok()),)*)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> getline &#123;</span><br><span class=\"line\">    ($cin: expr, $buf: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $buf.clear();</span><br><span class=\"line\">        $cin.read_line(&amp;<span class=\"keyword\">mut</span> $buf)?;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> lowbit &#123;</span><br><span class=\"line\">    ($x: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $x &amp; (!$x + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">maximum_beauty</span></span>(<span class=\"keyword\">mut</span> items: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;, queries: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// discrete</span></span><br><span class=\"line\">        items.sort_by(|v1, v2| v1[<span class=\"number\">0</span>].cmp(&amp;v2[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> pris = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> btys = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">        items.iter().for_each(|v| &#123;</span><br><span class=\"line\">            pris.push(v[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            btys.push(v[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, pris, btys);</span></span><br><span class=\"line\">        <span class=\"comment\">// sparse table</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> st = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">20</span>]; <span class=\"number\">100010</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> prelog = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">100010</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = items.len();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">2</span>..<span class=\"number\">100010</span> &#123;</span><br><span class=\"line\">            prelog[i] = prelog[i - <span class=\"number\">1</span>] + <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &lt;&lt; prelog[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>) == i &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> (<span class=\"number\">0</span>..n).rev() &#123;</span><br><span class=\"line\">            st[i][<span class=\"number\">0</span>] = btys[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">20</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i + (<span class=\"number\">1</span> &lt;&lt; j - <span class=\"number\">1</span>) &gt;= n &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                st[i][j] = st[i][j - <span class=\"number\">1</span>].max(st[i + (<span class=\"number\">1</span> &lt;&lt; j - <span class=\"number\">1</span>)][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// println!(&quot;&#123;:?&#125;,&#123;:?&#125;,&#123;:?&#125;,&#123;:?&#125;&quot;, st[0], st[1], st[2], st[3]);</span></span><br><span class=\"line\">        <span class=\"comment\">// query</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> q <span class=\"keyword\">in</span> queries &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> q &lt; pris[<span class=\"number\">0</span>] &#123;</span><br><span class=\"line\">                ans.push(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> q &gt;= pris[n - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">                    pos = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    pos = Solution::upper_bound(&amp;pris, q) - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// println!(&quot;&#123;:?&#125;&quot;, pos);</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> k = prelog[pos + <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"comment\">// 这个地方 l 恒为 0，但是比赛的时候把 ST 表的查询写成了 l = k ……</span></span><br><span class=\"line\">                ans.push(st[<span class=\"number\">0</span>][k].max(st[pos + <span class=\"number\">1</span> - (<span class=\"number\">1</span> &lt;&lt; k)][k]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">upper_bound</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, tar: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> r = vals.len() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> vals[m] &gt; tar &#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5913-你可以安排的最多任务数目\"><a href=\"#T4-5913-你可以安排的最多任务数目\" class=\"headerlink\" title=\"T4 5913. 你可以安排的最多任务数目\"></a>T4 5913. 你可以安排的最多任务数目</h2><ul>\n<li>  <strong>通过的用户数</strong>84</li>\n<li>  <strong>尝试过的用户数</strong>254</li>\n<li>  <strong>用户总通过次数</strong>93</li>\n<li>  <strong>用户总提交次数</strong>526</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你 <code>n</code> 个任务和 <code>m</code> 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> 中，第 <code>i</code> 个任务需要 <code>tasks[i]</code> 的力量才能完成。每个工人的力量值保存在下标从 <strong>0</strong> 开始的整数数组 <code>workers</code> 中，第 <code>j</code> 个工人的力量值为 <code>workers[j]</code> 。每个工人只能完成 <strong>一个</strong> 任务，且力量值需要 <strong>大于等于</strong> 该任务的力量要求值（即 <code>workers[j] &gt;= tasks[i]</code> ）。</p>\n<p>除此以外，你还有 <code>pills</code> 个神奇药丸，可以给 <strong>一个工人的力量值</strong> 增加 <code>strength</code> 。你可以决定给哪些工人使用药丸，但每个工人 <strong>最多</strong> 只能使用 <strong>一片</strong> 药丸。</p>\n<p>给你下标从 <strong>0</strong> 开始的整数数组<code>tasks</code> 和 <code>workers</code> 以及两个整数 <code>pills</code> 和 <code>strength</code> ，请你返回 <strong>最多</strong> 有多少个任务可以被完成。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以按照如下方案安排药丸：</span><br><span class=\"line\">- 给 0 号工人药丸。</span><br><span class=\"line\">- 0 号工人完成任务 2（0 + 1 &gt;= 1）</span><br><span class=\"line\">- 1 号工人完成任务 1（3 &gt;= 2）</span><br><span class=\"line\">- 2 号工人完成任务 0（3 &gt;= 3）</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以按照如下方案安排药丸：</span><br><span class=\"line\">- 给 0 号工人药丸。</span><br><span class=\"line\">- 0 号工人完成任务 0（0 + 5 &gt;= 5）</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以按照如下方案安排药丸：</span><br><span class=\"line\">- 给 0 号和 1 号工人药丸。</span><br><span class=\"line\">- 0 号工人完成任务 0（0 + 10 &gt;= 10）</span><br><span class=\"line\">- 1 号工人完成任务 1（10 + 10 &gt;= 15）</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以按照如下方案安排药丸：</span><br><span class=\"line\">- 给 2 号工人药丸。</span><br><span class=\"line\">- 1 号工人完成任务 0（6 &gt;= 5）</span><br><span class=\"line\">- 2 号工人完成任务 2（4 + 5 &gt;= 8）</span><br><span class=\"line\">- 4 号工人完成任务 3（6 &gt;= 5）</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == tasks.length</code></li>\n<li>  <code>m == workers.length</code></li>\n<li>  <code>1 &lt;= n, m &lt;= 5 * 104</code></li>\n<li>  <code>0 &lt;= pills &lt;= m</code></li>\n<li>  <code>0 &lt;= tasks[i], workers[j], strength &lt;= 109</code></li>\n</ul>\n<p><strong>思路：</strong></p>\n<blockquote>\n<p>  二分答案+贪心<br>  本题显然具有决策单调性：如果能安排K个任务，一定能安排K-1个任务；如果不能安排K个任务，一定不能安排K+1个任务，因此可以二分答案。</p>\n<p>  现在考虑安排K个任务。显然，我们应该选择最容易的K个任务，同时选择最强的K个人。</p>\n<p>  我们从难到易来考虑这K个任务。</p>\n<p>  一种贪心策略是：</p>\n<p>  如果有人能完成当前任务，我们就安排其中能力值最小的那个人去做这一任务。<br>  如果没有人能完成当前任务，但当前有药，并且有人能在服药后完成这一任务，我们就安排其中能力值最小的那个人去做这一任务。<br>  否则说明无法完成K个任务。<br>  另一种贪心策略是：</p>\n<p>  如果当前有药，我们就安排服药后能够完成任务的人中能力值最小的那个人去做这一任务。但要注意这个人可能不吃药也能完成任务，此时就不必吃药了。<br>  如果当前没有药，我们就安排能完成任务的人中能力值最小的那个人去做这一任务。<br>  否则说明无法完成K个任务。<br>  这两种贪心策略都是正确的。我们可以这样考虑：在有药丸的情况下，可能会存在A服药能完成任务，B不服药也能完成任务这样的情形。此时我们应该选择谁呢？实际上，因为后面的任务只会更简单，所以A+药或B都一定能完成后面的任务，因此此时使用A+药或使用B其实对后面的任务没有影响。</p>\n<p>  时间复杂度\\mathcal{O}(N\\log^2N)。<br>  空间复杂度\\mathcal{O}(N)。</p>\n<p>  作者：吴自华<br>  链接：<a href=\"https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\">https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxTaskAssign</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; tasks, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; workers, <span class=\"keyword\">int</span> pills, <span class=\"keyword\">int</span> strength)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = tasks.<span class=\"built_in\">size</span>(), m = workers.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(tasks.<span class=\"built_in\">begin</span>(), tasks.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(workers.<span class=\"built_in\">begin</span>(), workers.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m &lt; k)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\">multiset&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ms</span><span class=\"params\">(workers.rbegin(), workers.rbegin() + k)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rem = pills;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = k - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 贪心策略1</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> it = ms.<span class=\"built_in\">lower_bound</span>(tasks[i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (it == ms.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (rem == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    it = ms.<span class=\"built_in\">lower_bound</span>(tasks[i] - strength);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (it == ms.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    rem--;</span><br><span class=\"line\">                    ms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 贪心策略2</span></span><br><span class=\"line\">                <span class=\"comment\">// if (rem) &#123;</span></span><br><span class=\"line\">                <span class=\"comment\">//     auto it = ms.lower_bound(tasks[i] - strength);</span></span><br><span class=\"line\">                <span class=\"comment\">//     if (it == ms.end())</span></span><br><span class=\"line\">                <span class=\"comment\">//         return false;</span></span><br><span class=\"line\">                <span class=\"comment\">//     if (*it &lt; tasks[i])</span></span><br><span class=\"line\">                <span class=\"comment\">//         rem--;</span></span><br><span class=\"line\">                <span class=\"comment\">//     ms.erase(it);</span></span><br><span class=\"line\">                <span class=\"comment\">// &#125; else &#123;</span></span><br><span class=\"line\">                <span class=\"comment\">//     auto it = ms.lower_bound(tasks[i]);</span></span><br><span class=\"line\">                <span class=\"comment\">//     if (it == ms.end())</span></span><br><span class=\"line\">                <span class=\"comment\">//         return false;</span></span><br><span class=\"line\">                <span class=\"comment\">//     ms.erase(it);</span></span><br><span class=\"line\">                <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">1</span>, hi = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (lo &lt;= hi) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid))</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> hi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：吴自华</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  单调队列<br>  在二分的大框架下，我们也可以从弱到强来考虑选出的K个工人。</p>\n<p>  显然，每个工人都必须做一个任务，否则总共做不到K个。对于第ii个工人，我们将所有难度值不超过workers[i] + strength的任务维护在一个双端队列中。由于我们已经对任务进行排序，这个队列天然就是一个单调队列。</p>\n<p>  首先考虑这个工人不吃药的情况。此时我们看队列最前面，也即当前最容易的任务是否能够被完成。如果可以，则让该工人做这个最容易的任务。因为任务是必须要做的，而后面的人能力都比当前这个人要强，所以安排当前这个人来做任务是不亏的。<br>  如果他不吃药就做不了任务，那就必须吃药。吃药之后，我们应该让他做当前最难的任务，也即队尾的任务。<br>  如果吃了药也做不了任何任务，则说明无法完成K个任务。<br>  这样，时间复杂度就优化掉了一个log。</p>\n<p>  时间复杂度\\mathcal{O}(N\\log N)。<br>  空间复杂度\\mathcal{O}(N)。</p>\n<p>  作者：吴自华<br>  链接：<a href=\"https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\">https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxTaskAssign</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; tasks, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; workers, <span class=\"keyword\">int</span> pills, <span class=\"keyword\">int</span> strength)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = tasks.<span class=\"built_in\">size</span>(), m = workers.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(tasks.<span class=\"built_in\">begin</span>(), tasks.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(workers.<span class=\"built_in\">begin</span>(), workers.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m &lt; k)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">int</span> ptr = <span class=\"number\">-1</span>, rem = pills;</span><br><span class=\"line\">            deque&lt;<span class=\"keyword\">int</span>&gt; dq;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - k; i &lt; m; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (ptr + <span class=\"number\">1</span> &lt; k &amp;&amp; tasks[ptr + <span class=\"number\">1</span>] &lt;= workers[i] + strength)</span><br><span class=\"line\">                    dq.<span class=\"built_in\">push_back</span>(tasks[++ptr]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dq.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dq.<span class=\"built_in\">front</span>() &lt;= workers[i])</span><br><span class=\"line\">                    dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rem &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    rem--;</span><br><span class=\"line\">                    dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">1</span>, hi = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (lo &lt;= hi) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid))</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> hi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：吴自华</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-双周赛-65\"><a href=\"#LeetCode-双周赛-65\" class=\"headerlink\" title=\"LeetCode 双周赛 65\"></a>LeetCode 双周赛 65</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-65/problems/check-whether-two-strings-are-almost-equivalent/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-65/problems/walking-robot-simulation-ii/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-65/problems/most-beautiful-item-for-each-query/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/biweekly-contest-65/problems/maximum-number-of-tasks-you-can-assign/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>634 / 2676</td>\n<td>MiracleSNeko</td>\n<td>8</td>\n<td>0:50:07</td>\n<td>0:04:52</td>\n<td></td>\n<td>0:45:07 1</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5910-检查两个字符串是否几乎相等\"><a href=\"#T1-5910-检查两个字符串是否几乎相等\" class=\"headerlink\" title=\"T1 5910. 检查两个字符串是否几乎相等\"></a>T1 5910. 检查两个字符串是否几乎相等</h2><ul>\n<li>  <strong>通过的用户数</strong>1956</li>\n<li>  <strong>尝试过的用户数</strong>1988</li>\n<li>  <strong>用户总通过次数</strong>1977</li>\n<li>  <strong>用户总提交次数</strong>2707</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>如果两个字符串 <code>word1</code> 和 <code>word2</code> 中从 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 每一个字母出现频率之差都 <strong>不超过</strong> <code>3</code> ，那么我们称这两个字符串 <code>word1</code> 和 <code>word2</code> <strong>几乎相等</strong> 。</p>\n<p>给你两个长度都为 <code>n</code> 的字符串 <code>word1</code> 和 <code>word2</code> ，如果 <code>word1</code> 和 <code>word2</code> <strong>几乎相等</strong> ，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p>一个字母 <code>x</code> 的出现 <strong>频率</strong> 指的是它在字符串中出现的次数。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 = &quot;aaaa&quot;, word2 = &quot;bccb&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：字符串 &quot;aaaa&quot; 中有 4 个 &#x27;a&#x27; ，但是 &quot;bccb&quot; 中有 0 个 &#x27;a&#x27; 。</span><br><span class=\"line\">两者之差为 4 ，大于上限 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 = &quot;abcdeef&quot;, word2 = &quot;abaaacc&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：</span><br><span class=\"line\">- &#x27;a&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。</span><br><span class=\"line\">- &#x27;b&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。</span><br><span class=\"line\">- &#x27;c&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。</span><br><span class=\"line\">- &#x27;d&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。</span><br><span class=\"line\">- &#x27;e&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。</span><br><span class=\"line\">- &#x27;f&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word1 = &quot;cccddabba&quot;, word2 = &quot;babababab&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：</span><br><span class=\"line\">- &#x27;a&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。</span><br><span class=\"line\">- &#x27;b&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。</span><br><span class=\"line\">- &#x27;c&#x27; 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。</span><br><span class=\"line\">- &#x27;d&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == word1.length == word2.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 100</code></li>\n<li>  <code>word1</code> 和 <code>word2</code> 都只包含小写英文字母。</li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  简单模拟</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_almost_equivalent</span></span>(word1: <span class=\"built_in\">String</span>, word2: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">str_to_freq</span></span>(word: &amp;<span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ret = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">26</span>];</span><br><span class=\"line\">            word.bytes().for_each(|ch| ret[(ch - <span class=\"string\">b&#x27;a&#x27;</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] += <span class=\"number\">1</span>);</span><br><span class=\"line\">            ret</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vec1 = str_to_freq(&amp;word1);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vec2 = str_to_freq(&amp;word2);</span><br><span class=\"line\">        vec1.iter().zip(vec2.iter()).all(|(v1, v2)| (*v1 - *v2).abs() &lt;= <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5911-模拟行走机器人-II\"><a href=\"#T2-5911-模拟行走机器人-II\" class=\"headerlink\" title=\"T2 5911. 模拟行走机器人 II\"></a>T2 5911. 模拟行走机器人 II</h2><ul>\n<li>  <strong>通过的用户数</strong>694</li>\n<li>  <strong>尝试过的用户数</strong>1532</li>\n<li>  <strong>用户总通过次数</strong>711</li>\n<li>  <strong>用户总提交次数</strong>6760</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个在 XY 平面上的 <code>width x height</code> 的网格图，<strong>左下角</strong> 的格子为 <code>(0, 0)</code> ，<strong>右上角</strong> 的格子为 <code>(width - 1, height - 1)</code> 。网格图中相邻格子为四个基本方向之一（<code>&quot;North&quot;</code>，<code>&quot;East&quot;</code>，<code>&quot;South&quot;</code> 和 <code>&quot;West&quot;</code>）。一个机器人 <strong>初始</strong> 在格子 <code>(0, 0)</code> ，方向为 <code>&quot;East&quot;</code> 。</p>\n<p>机器人可以根据指令移动指定的 <strong>步数</strong> 。每一步，它可以执行以下操作。</p>\n<ol>\n<li> 沿着当前方向尝试 <strong>往前一步</strong> 。</li>\n<li> 如果机器人下一步将到达的格子 <strong>超出了边界</strong> ，机器人会 <strong>逆时针</strong> 转 90 度，然后再尝试往前一步。</li>\n</ol>\n<p>如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。</p>\n<p>请你实现 <code>Robot</code> 类：</p>\n<ul>\n<li>  <code>Robot(int width, int height)</code> 初始化一个 <code>width x height</code> 的网格图，机器人初始在 <code>(0, 0)</code> ，方向朝 <code>&quot;East&quot;</code> 。</li>\n<li>  <code>void move(int num)</code> 给机器人下达前进 <code>num</code> 步的指令。</li>\n<li>  <code>int[] getPos()</code> 返回机器人当前所处的格子位置，用一个长度为 2 的数组 <code>[x, y]</code> 表示。</li>\n<li><code>String getDir()</code> 返回当前机器人的朝向，为 <code>&quot;North&quot;</code> ，<code>&quot;East&quot;</code> ，<code>&quot;South&quot;</code> 或者 <code>&quot;West&quot;</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/09/example-1.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;Robot&quot;, &quot;move&quot;, &quot;move&quot;, &quot;getPos&quot;, &quot;getDir&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;getPos&quot;, &quot;getDir&quot;]</span><br><span class=\"line\">[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, [4, 0], &quot;East&quot;, null, null, null, [1, 2], &quot;West&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">Robot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。</span><br><span class=\"line\">robot.move(2);  // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。</span><br><span class=\"line\">robot.move(2);  // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。</span><br><span class=\"line\">robot.getPos(); // 返回 [4, 0]</span><br><span class=\"line\">robot.getDir(); // 返回 &quot;East&quot;</span><br><span class=\"line\">robot.move(2);  // 朝东移动 1 步到达 (5, 0) ，并朝东。</span><br><span class=\"line\">                // 下一步继续往东移动将出界，所以逆时针转变方向朝北。</span><br><span class=\"line\">                // 然后，往北移动 1 步到达 (5, 1) ，并朝北。</span><br><span class=\"line\">robot.move(1);  // 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。</span><br><span class=\"line\">robot.move(4);  // 下一步继续往北移动将出界，所以逆时针转变方向朝西。</span><br><span class=\"line\">                // 然后，移动 4 步到 (1, 2) ，并朝西。</span><br><span class=\"line\">robot.getPos(); // 返回 [1, 2]</span><br><span class=\"line\">robot.getDir(); // 返回 &quot;West&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= width, height &lt;= 100</code></li>\n<li>  <code>1 &lt;= num &lt;= 105</code></li>\n<li>  <code>move</code> ，<code>getPos</code> 和 <code>getDir</code> <strong>总共</strong> 调用次数不超过 <code>104</code> 次。</li>\n</ul>\n<p><strong>答案：</strong></p>\n<blockquote>\n<p>  脑筋急转弯，机器人只会在外环转悠。这题 Rust 没法写，move 是个关键字</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> DIR_R[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> DIR_C[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">vector&lt;string&gt; NAMES = &#123;<span class=\"string\">&quot;East&quot;</span>, <span class=\"string\">&quot;North&quot;</span>, <span class=\"string\">&quot;West&quot;</span>, <span class=\"string\">&quot;South&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Robot</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Robot</span>(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;width = width;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;height = height;</span><br><span class=\"line\">        x = y = d = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sx = <span class=\"number\">-1</span>, sy = <span class=\"number\">-1</span>, step = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (num--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (step &amp;&amp; x == sx &amp;&amp; y == sy) &#123;</span><br><span class=\"line\">                num %= step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sx == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span> || y == <span class=\"number\">0</span> || x == height - <span class=\"number\">1</span> || y == width - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    sx = x;</span><br><span class=\"line\">                    sy = y;</span><br><span class=\"line\">                    step = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tx = x + DIR_R[d];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ty = y + DIR_C[d];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!(<span class=\"number\">0</span> &lt;= tx &amp;&amp; tx &lt; height &amp;&amp; <span class=\"number\">0</span> &lt;= ty &amp;&amp; ty &lt; width)) &#123;</span><br><span class=\"line\">                    d = (d + <span class=\"number\">1</span>) % <span class=\"number\">4</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                x = tx;</span><br><span class=\"line\">                y = ty;</span><br><span class=\"line\">                ++step;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">getPos</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;y, x&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">getDir</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> NAMES[d];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width, height;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y, d;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T3-5912-每一个查询的最大美丽值\"><a href=\"#T3-5912-每一个查询的最大美丽值\" class=\"headerlink\" title=\"T3 5912. 每一个查询的最大美丽值\"></a>T3 5912. 每一个查询的最大美丽值</h2><ul>\n<li>  <strong>通过的用户数</strong>870</li>\n<li>  <strong>尝试过的用户数</strong>1264</li>\n<li>  <strong>用户总通过次数</strong>876</li>\n<li>  <strong>用户总提交次数</strong>2596</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个二维整数数组 <code>items</code> ，其中 <code>items[i] = [pricei, beautyi]</code> 分别表示每一个物品的 <strong>价格</strong> 和 <strong>美丽值</strong> 。</p>\n<p>同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>queries</code> 。对于每个查询 <code>queries[j]</code> ，你想求出价格小于等于 <code>queries[j]</code> 的物品中，<strong>最大的美丽值</strong> 是多少。如果不存在符合条件的物品，那么查询的结果为 <code>0</code> 。</p>\n<p>请你返回一个长度与 <code>queries</code> 相同的数组 <code>answer</code>，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]</span><br><span class=\"line\">输出：[2,4,5,5,6,6]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- queries[0]=1 ，[1,2] 是唯一价格 &lt;= 1 的物品。所以这个查询的答案为 2 。</span><br><span class=\"line\">- queries[1]=2 ，符合条件的物品有 [1,2] 和 [2,4] 。</span><br><span class=\"line\">  它们中的最大美丽值为 4 。</span><br><span class=\"line\">- queries[2]=3 和 queries[3]=4 ，符合条件的物品都为 [1,2] ，[3,2] ，[2,4] 和 [3,5] 。</span><br><span class=\"line\">  它们中的最大美丽值为 5 。</span><br><span class=\"line\">- queries[4]=5 和 queries[5]=6 ，所有物品都符合条件。</span><br><span class=\"line\">  所以，答案为所有物品中的最大美丽值，为 6 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]</span><br><span class=\"line\">输出：[4]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">每个物品的价格均为 1 ，所以我们选择最大美丽值 4 。</span><br><span class=\"line\">注意，多个物品可能有相同的价格和美丽值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：items = [[10,1000]], queries = [5]</span><br><span class=\"line\">输出：[0]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">没有物品的价格小于等于 5 ，所以没有物品可以选择。</span><br><span class=\"line\">因此，查询的结果为 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= items.length, queries.length &lt;= 105</code></li>\n<li>  <code>items[i].length == 2</code></li>\n<li>  <code>1 &lt;= pricei, beautyi, queries[j] &lt;= 109</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  离线查询，其实只需要前缀最大值即可。哪怕写个树状数组也比 ST 表简单啊……</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cmp::&#123;max, min, Reverse&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::&#123;BinaryHeap, HashMap, HashSet, VecDeque&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::convert::&#123;<span class=\"built_in\">From</span>, <span class=\"built_in\">Into</span>, TryFrom, TryInto&#125;;</span><br><span class=\"line\"><span class=\"comment\">// use std::io::&#123;self, BufRead, BufReader, BufWriter, Write&#125;;</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> new_bufio &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#123;</span><br><span class=\"line\">        (io::stdin(), io::stdout(), <span class=\"built_in\">String</span>::new())</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> init_stdio &#123;</span><br><span class=\"line\">    ($cin: expr, $cout: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        (BufReader::new($cin.lock()), BufWriter::new($cout.lock()))</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> scanf &#123;</span><br><span class=\"line\">    ($buf: expr, $div: expr, $($x: ty), +) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> iter = $buf.split($div);</span><br><span class=\"line\">        ($(iter.next().and_then(|token| token.parse::&lt;$x&gt;().ok()),)*)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> getline &#123;</span><br><span class=\"line\">    ($cin: expr, $buf: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $buf.clear();</span><br><span class=\"line\">        $cin.read_line(&amp;<span class=\"keyword\">mut</span> $buf)?;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map_or_insert &#123;</span><br><span class=\"line\">    ($map: expr, $key: expr, $<span class=\"function\"><span class=\"keyword\">fn</span>: <span class=\"title\">expr</span>, $<span class=\"title\">val</span>: <span class=\"title\">expr</span>) =&gt; &#123;&#123;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">match</span> $<span class=\"title\">map</span>.<span class=\"title\">get_mut</span></span>(&amp;$key) &#123;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(v) =&gt; &#123;</span><br><span class=\"line\">                $<span class=\"function\"><span class=\"keyword\">fn</span></span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">                $map.insert($key, $val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> lowbit &#123;</span><br><span class=\"line\">    ($x: expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        $x &amp; (!$x + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">maximum_beauty</span></span>(<span class=\"keyword\">mut</span> items: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;, queries: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// discrete</span></span><br><span class=\"line\">        items.sort_by(|v1, v2| v1[<span class=\"number\">0</span>].cmp(&amp;v2[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> pris = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> btys = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">        items.iter().for_each(|v| &#123;</span><br><span class=\"line\">            pris.push(v[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            btys.push(v[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, pris, btys);</span></span><br><span class=\"line\">        <span class=\"comment\">// sparse table</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> st = <span class=\"built_in\">vec!</span>[<span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">20</span>]; <span class=\"number\">100010</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> prelog = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">100010</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = items.len();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">2</span>..<span class=\"number\">100010</span> &#123;</span><br><span class=\"line\">            prelog[i] = prelog[i - <span class=\"number\">1</span>] + <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &lt;&lt; prelog[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>) == i &#123; <span class=\"number\">1</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> (<span class=\"number\">0</span>..n).rev() &#123;</span><br><span class=\"line\">            st[i][<span class=\"number\">0</span>] = btys[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">20</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i + (<span class=\"number\">1</span> &lt;&lt; j - <span class=\"number\">1</span>) &gt;= n &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                st[i][j] = st[i][j - <span class=\"number\">1</span>].max(st[i + (<span class=\"number\">1</span> &lt;&lt; j - <span class=\"number\">1</span>)][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// println!(&quot;&#123;:?&#125;,&#123;:?&#125;,&#123;:?&#125;,&#123;:?&#125;&quot;, st[0], st[1], st[2], st[3]);</span></span><br><span class=\"line\">        <span class=\"comment\">// query</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> q <span class=\"keyword\">in</span> queries &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> q &lt; pris[<span class=\"number\">0</span>] &#123;</span><br><span class=\"line\">                ans.push(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> q &gt;= pris[n - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">                    pos = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    pos = Solution::upper_bound(&amp;pris, q) - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// println!(&quot;&#123;:?&#125;&quot;, pos);</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> k = prelog[pos + <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"comment\">// 这个地方 l 恒为 0，但是比赛的时候把 ST 表的查询写成了 l = k ……</span></span><br><span class=\"line\">                ans.push(st[<span class=\"number\">0</span>][k].max(st[pos + <span class=\"number\">1</span> - (<span class=\"number\">1</span> &lt;&lt; k)][k]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">upper_bound</span></span>(vals: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, tar: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> r = vals.len() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> vals[m] &gt; tar &#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5913-你可以安排的最多任务数目\"><a href=\"#T4-5913-你可以安排的最多任务数目\" class=\"headerlink\" title=\"T4 5913. 你可以安排的最多任务数目\"></a>T4 5913. 你可以安排的最多任务数目</h2><ul>\n<li>  <strong>通过的用户数</strong>84</li>\n<li>  <strong>尝试过的用户数</strong>254</li>\n<li>  <strong>用户总通过次数</strong>93</li>\n<li>  <strong>用户总提交次数</strong>526</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你 <code>n</code> 个任务和 <code>m</code> 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> 中，第 <code>i</code> 个任务需要 <code>tasks[i]</code> 的力量才能完成。每个工人的力量值保存在下标从 <strong>0</strong> 开始的整数数组 <code>workers</code> 中，第 <code>j</code> 个工人的力量值为 <code>workers[j]</code> 。每个工人只能完成 <strong>一个</strong> 任务，且力量值需要 <strong>大于等于</strong> 该任务的力量要求值（即 <code>workers[j] &gt;= tasks[i]</code> ）。</p>\n<p>除此以外，你还有 <code>pills</code> 个神奇药丸，可以给 <strong>一个工人的力量值</strong> 增加 <code>strength</code> 。你可以决定给哪些工人使用药丸，但每个工人 <strong>最多</strong> 只能使用 <strong>一片</strong> 药丸。</p>\n<p>给你下标从 <strong>0</strong> 开始的整数数组<code>tasks</code> 和 <code>workers</code> 以及两个整数 <code>pills</code> 和 <code>strength</code> ，请你返回 <strong>最多</strong> 有多少个任务可以被完成。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以按照如下方案安排药丸：</span><br><span class=\"line\">- 给 0 号工人药丸。</span><br><span class=\"line\">- 0 号工人完成任务 2（0 + 1 &gt;= 1）</span><br><span class=\"line\">- 1 号工人完成任务 1（3 &gt;= 2）</span><br><span class=\"line\">- 2 号工人完成任务 0（3 &gt;= 3）</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以按照如下方案安排药丸：</span><br><span class=\"line\">- 给 0 号工人药丸。</span><br><span class=\"line\">- 0 号工人完成任务 0（0 + 5 &gt;= 5）</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以按照如下方案安排药丸：</span><br><span class=\"line\">- 给 0 号和 1 号工人药丸。</span><br><span class=\"line\">- 0 号工人完成任务 0（0 + 10 &gt;= 10）</span><br><span class=\"line\">- 1 号工人完成任务 1（10 + 10 &gt;= 15）</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以按照如下方案安排药丸：</span><br><span class=\"line\">- 给 2 号工人药丸。</span><br><span class=\"line\">- 1 号工人完成任务 0（6 &gt;= 5）</span><br><span class=\"line\">- 2 号工人完成任务 2（4 + 5 &gt;= 8）</span><br><span class=\"line\">- 4 号工人完成任务 3（6 &gt;= 5）</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == tasks.length</code></li>\n<li>  <code>m == workers.length</code></li>\n<li>  <code>1 &lt;= n, m &lt;= 5 * 104</code></li>\n<li>  <code>0 &lt;= pills &lt;= m</code></li>\n<li>  <code>0 &lt;= tasks[i], workers[j], strength &lt;= 109</code></li>\n</ul>\n<p><strong>思路：</strong></p>\n<blockquote>\n<p>  二分答案+贪心<br>  本题显然具有决策单调性：如果能安排K个任务，一定能安排K-1个任务；如果不能安排K个任务，一定不能安排K+1个任务，因此可以二分答案。</p>\n<p>  现在考虑安排K个任务。显然，我们应该选择最容易的K个任务，同时选择最强的K个人。</p>\n<p>  我们从难到易来考虑这K个任务。</p>\n<p>  一种贪心策略是：</p>\n<p>  如果有人能完成当前任务，我们就安排其中能力值最小的那个人去做这一任务。<br>  如果没有人能完成当前任务，但当前有药，并且有人能在服药后完成这一任务，我们就安排其中能力值最小的那个人去做这一任务。<br>  否则说明无法完成K个任务。<br>  另一种贪心策略是：</p>\n<p>  如果当前有药，我们就安排服药后能够完成任务的人中能力值最小的那个人去做这一任务。但要注意这个人可能不吃药也能完成任务，此时就不必吃药了。<br>  如果当前没有药，我们就安排能完成任务的人中能力值最小的那个人去做这一任务。<br>  否则说明无法完成K个任务。<br>  这两种贪心策略都是正确的。我们可以这样考虑：在有药丸的情况下，可能会存在A服药能完成任务，B不服药也能完成任务这样的情形。此时我们应该选择谁呢？实际上，因为后面的任务只会更简单，所以A+药或B都一定能完成后面的任务，因此此时使用A+药或使用B其实对后面的任务没有影响。</p>\n<p>  时间复杂度\\mathcal{O}(N\\log^2N)。<br>  空间复杂度\\mathcal{O}(N)。</p>\n<p>  作者：吴自华<br>  链接：<a href=\"https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\">https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxTaskAssign</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; tasks, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; workers, <span class=\"keyword\">int</span> pills, <span class=\"keyword\">int</span> strength)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = tasks.<span class=\"built_in\">size</span>(), m = workers.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(tasks.<span class=\"built_in\">begin</span>(), tasks.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(workers.<span class=\"built_in\">begin</span>(), workers.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m &lt; k)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\">multiset&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ms</span><span class=\"params\">(workers.rbegin(), workers.rbegin() + k)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rem = pills;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = k - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 贪心策略1</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> it = ms.<span class=\"built_in\">lower_bound</span>(tasks[i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (it == ms.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (rem == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    it = ms.<span class=\"built_in\">lower_bound</span>(tasks[i] - strength);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (it == ms.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    rem--;</span><br><span class=\"line\">                    ms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 贪心策略2</span></span><br><span class=\"line\">                <span class=\"comment\">// if (rem) &#123;</span></span><br><span class=\"line\">                <span class=\"comment\">//     auto it = ms.lower_bound(tasks[i] - strength);</span></span><br><span class=\"line\">                <span class=\"comment\">//     if (it == ms.end())</span></span><br><span class=\"line\">                <span class=\"comment\">//         return false;</span></span><br><span class=\"line\">                <span class=\"comment\">//     if (*it &lt; tasks[i])</span></span><br><span class=\"line\">                <span class=\"comment\">//         rem--;</span></span><br><span class=\"line\">                <span class=\"comment\">//     ms.erase(it);</span></span><br><span class=\"line\">                <span class=\"comment\">// &#125; else &#123;</span></span><br><span class=\"line\">                <span class=\"comment\">//     auto it = ms.lower_bound(tasks[i]);</span></span><br><span class=\"line\">                <span class=\"comment\">//     if (it == ms.end())</span></span><br><span class=\"line\">                <span class=\"comment\">//         return false;</span></span><br><span class=\"line\">                <span class=\"comment\">//     ms.erase(it);</span></span><br><span class=\"line\">                <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">1</span>, hi = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (lo &lt;= hi) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid))</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> hi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：吴自华</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  单调队列<br>  在二分的大框架下，我们也可以从弱到强来考虑选出的K个工人。</p>\n<p>  显然，每个工人都必须做一个任务，否则总共做不到K个。对于第ii个工人，我们将所有难度值不超过workers[i] + strength的任务维护在一个双端队列中。由于我们已经对任务进行排序，这个队列天然就是一个单调队列。</p>\n<p>  首先考虑这个工人不吃药的情况。此时我们看队列最前面，也即当前最容易的任务是否能够被完成。如果可以，则让该工人做这个最容易的任务。因为任务是必须要做的，而后面的人能力都比当前这个人要强，所以安排当前这个人来做任务是不亏的。<br>  如果他不吃药就做不了任务，那就必须吃药。吃药之后，我们应该让他做当前最难的任务，也即队尾的任务。<br>  如果吃了药也做不了任何任务，则说明无法完成K个任务。<br>  这样，时间复杂度就优化掉了一个log。</p>\n<p>  时间复杂度\\mathcal{O}(N\\log N)。<br>  空间复杂度\\mathcal{O}(N)。</p>\n<p>  作者：吴自华<br>  链接：<a href=\"https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/\">https://leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxTaskAssign</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; tasks, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; workers, <span class=\"keyword\">int</span> pills, <span class=\"keyword\">int</span> strength)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = tasks.<span class=\"built_in\">size</span>(), m = workers.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(tasks.<span class=\"built_in\">begin</span>(), tasks.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(workers.<span class=\"built_in\">begin</span>(), workers.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m &lt; k)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">int</span> ptr = <span class=\"number\">-1</span>, rem = pills;</span><br><span class=\"line\">            deque&lt;<span class=\"keyword\">int</span>&gt; dq;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - k; i &lt; m; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (ptr + <span class=\"number\">1</span> &lt; k &amp;&amp; tasks[ptr + <span class=\"number\">1</span>] &lt;= workers[i] + strength)</span><br><span class=\"line\">                    dq.<span class=\"built_in\">push_back</span>(tasks[++ptr]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dq.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dq.<span class=\"built_in\">front</span>() &lt;= workers[i])</span><br><span class=\"line\">                    dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rem &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    rem--;</span><br><span class=\"line\">                    dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">1</span>, hi = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (lo &lt;= hi) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid))</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> hi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：吴自华</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/circle/discuss/cj4dO9/view/Mwspom/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LeetCode 周赛 258","date":"2021-09-12T08:51:09.000Z","_content":"\n---\n\n# LeetCode 周赛 258\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-258/problems/reverse-prefix-of-word/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-258/problems/number-of-pairs-of-interchangeable-rectangles/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-258/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-258/problems/smallest-missing-genetic-value-in-each-subtree/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 738 / 4518 | MiracleSNeko | 12   | 1:09:58  | 0:20:57                                                      | 0:33:48 1                                                    | 0:59:58 1                                                    |                                                              |\n\n## T1 5867. 反转单词前缀\n\n-   **通过的用户数**3464\n-   **尝试过的用户数**3498\n-   **用户总通过次数**3507\n-   **用户总提交次数**4264\n-   **题目难度** **Easy**\n\n给你一个下标从 **0** 开始的字符串 `word` 和一个字符 `ch` 。找出 `ch` 第一次出现的下标 `i` ，**反转** `word` 中从下标 `0` 开始、直到下标 `i` 结束（含下标 `i` ）的那段字符。如果 `word` 中不存在字符 `ch` ，则无需进行任何操作。\n\n-   例如，如果 `word = \"abcdefd\"` 且 `ch = \"d\"` ，那么你应该 **反转** 从下标 0 开始、直到下标 `3` 结束（含下标 `3` ）。结果字符串将会是 `\"***dcba***efd\"` 。\n\n返回 **结果字符串** 。\n\n**示例 1：**\n\n```\n输入：word = \"abcdefd\", ch = \"d\"\n输出：\"dcbaefd\"\n解释：\"d\" 第一次出现在下标 3 。 \n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"dcbaefd\" 。\n```\n\n**示例 2：**\n\n```\n输入：word = \"xyxzxe\", ch = \"z\"\n输出：\"zxyxxe\"\n解释：\"z\" 第一次也是唯一一次出现是在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"zxyxxe\" 。\n```\n\n**示例 3：**\n\n```\n输入：word = \"abcd\", ch = \"z\"\n输出：\"abcd\"\n解释：\"z\" 不存在于 word 中。\n无需执行反转操作，结果字符串是 \"abcd\" 。\n```\n\n**提示：**\n\n-   `1 <= word.length <= 250`\n-   `word` 由小写英文字母组成\n-   `ch` 是一个小写英文字母\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n    std::string reversePrefix(std::string word, char ch)\n    {\n        CHEATING_HEAD;\n        auto pos = word.find(ch);\n        if (pos != str::npos)\n        {\n            str prv = str(word.begin(), word.begin() + pos + 1);\n            str pst = str(word.begin() + pos + 1, word.end());\n            prv = str(prv.rbegin(), prv.rend());\n            return prv + pst;\n        }\n        return word;\n    }\n};\n```\n\n\n\n## T2 5868. 可互换矩形的组数\n\n-   **通过的用户数**2656\n-   **尝试过的用户数**3291\n-   **用户总通过次数**2705\n-   **用户总提交次数**9238\n-   **题目难度** **Medium**\n\n用一个下标从 **0** 开始的二维整数数组 `rectangles` 来表示 `n` 个矩形，其中 `rectangles[i] = [widthi, heighti]` 表示第 `i` 个矩形的宽度和高度。\n\n如果两个矩形 `i` 和 `j`（`i < j`）的宽高比相同，则认为这两个矩形 **可互换** 。更规范的说法是，两个矩形满足 `widthi/heighti == widthj/heightj`（使用实数除法而非整数除法），则认为这两个矩形 **可互换** 。\n\n计算并返回 `rectangles` 中有多少对 **可互换** 矩形。\n\n**示例 1：**\n\n```\n输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]\n输出：6\n解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：\n- 矩形 0 和矩形 1 ：4/8 == 3/6\n- 矩形 0 和矩形 2 ：4/8 == 10/20\n- 矩形 0 和矩形 3 ：4/8 == 15/30\n- 矩形 1 和矩形 2 ：3/6 == 10/20\n- 矩形 1 和矩形 3 ：3/6 == 15/30\n- 矩形 2 和矩形 3 ：10/20 == 15/30\n```\n\n**示例 2：**\n\n```\n输入：rectangles = [[4,5],[7,8]]\n输出：0\n解释：不存在成对的可互换矩形。\n```\n\n**提示：**\n\n-   `n == rectangles.length`\n-   `1 <= n <= 105`\n-   `rectangles[i].length == 2`\n-   `1 <= widthi, heighti <= 105`\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n/*     static constexpr auto Fracs = []()\n    {\n        std::array<i64, 21> fracs({1});\n        for (i64 i = 1; i <= 20; ++i)\n        {\n            fracs[i] = fracs[i - 1] * i;\n        }\n        return fracs;\n    }(); */\n\n    i64 interchangeableRectangles(std::vector<std::vector<int>> &rectangles)\n    {\n        // 找比例相等个数，求组合数 nC2\n        Vecd fracs;\n        for (auto &rect : rectangles)\n        {\n            fracs.emplace_back(static_cast<f64>(rect[0]) / static_cast<f64>(rect[1]));\n        }\n        HashMap<f64, i32> mp;\n        for (auto &f : fracs)\n        {\n            if (mp.count(f) == 0)\n            {\n                mp[f] = 1;\n            }\n            else\n            {\n                mp[f] += 1;\n            }\n        }\n        i64 ans = 0;\n        for (auto &kv : mp)\n        {\n            i64 cnt = kv.second;\n            if (cnt > 1)\n            {\n                ans += cnt * (cnt - 1) / 2;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n>   注：此处用 `double` 类型不涉及加减运算，只涉及判等，所以 `double` 作为 `key` 不会导致精度问题。\n\n-   WA 的原因： 把 $C(n, 2) = n(n - 1) / 2$ 写成了 $n!(n-1)!/2$\n\n\n\n## L3 5869. 两个回文子序列长度的最大乘积\n\n-   **通过的用户数**971\n-   **尝试过的用户数**1189\n-   **用户总通过次数**1017\n-   **用户总提交次数**2093\n-   **题目难度** **Medium**\n\n给你一个字符串 `s` ，请你找到 `s` 中两个 **不相交回文子序列** ，使得它们长度的 **乘积最大** 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 **不相交** 的。\n\n请你返回两个回文子序列长度可以达到的 **最大乘积** 。\n\n**子序列** 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 **回文字符串** 。\n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png)\n\n```\n输入：s = \"leetcodecom\"\n输出：9\n解释：最优方案是选择 \"ete\" 作为第一个子序列，\"cdc\" 作为第二个子序列。\n它们的乘积为 3 * 3 = 9 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"bb\"\n输出：1\n解释：最优方案为选择 \"b\" （第一个字符）作为第一个子序列，\"b\" （第二个字符）作为第二个子序列。\n它们的乘积为 1 * 1 = 1 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"accbcaxxcxx\"\n输出：25\n解释：最优方案为选择 \"accca\" 作为第一个子序列，\"xxcxx\" 作为第二个子序列。\n它们的乘积为 5 * 5 = 25 。\n```\n\n**提示：**\n\n-   `2 <= s.length <= 12`\n-   `s` 只含有小写英文字母。\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n    i32 countOnes(i32 x)\n    {\n        x = ((x >> 1) & 0x55555555) + (x & 0x55555555);\n        x = ((x >> 2) & 0x33333333) + (x & 0x33333333);\n        x = ((x >> 4) & 0x0f0f0f0f) + (x & 0x0f0f0f0f);\n        x = ((x >> 8) & 0x00ff00ff) + (x & 0x00ff00ff);\n        x = ((x >> 16) & 0x0000ffff) + (x & 0x0000ffff);\n        return x;\n    }\n\n    int maxProduct(str s)\n    {\n        auto check = [&s](i32 status) -> bool\n        {\n            Veci pos1({});\n            for (i32 i = 0; i < 13; ++i)\n            {\n                if (status & (1 << i))\n                    pos1.push_back(i);\n            }\n            if (pos1.size() == 1)\n                return true;\n            i32 i = 0, j = pos1.size() - 1;\n            while (i <= j)\n            {\n                if (s[pos1[i]] != s[pos1[j]])\n                    return false;\n                ++i, --j;\n            }\n            return true;\n        };\n        // 预处理所有回文子串\n        i32 sts = 1 << s.size();\n        Veci checked;\n        for (i32 st = 1; st < sts; ++st)\n        {\n            if (check(st))\n                checked.push_back(st);\n        }\n        // 遍历所有回文字串求结果\n        i32 ans = -Inf;\n        i32 clen = checked.size();\n        for (i32 i = 0; i < clen; ++i)\n        {\n            i32 sti = checked[i];\n            for (i32 j = i + 1; j < clen; ++j)\n            {\n                i32 stj = checked[j];\n                if ((sti & stj) == 0) // 无重复\n                {\n                    ans = std::max(ans, countOnes(sti) * countOnes(stj));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n>   注：本质是暴力遍历\n\n-   TLE 的原因：一开始直接暴力二重循环，没预处理回文字符串，遍历了大量的垃圾状态\n\n**其他思路**\n\ndfs 两个子序列。对于位置 i ，两个子序列可以选择用或者不用。\n\n```c++\nclass Solution {\npublic:\n    int ans = 0;\n    int maxProduct(string s) {\n        string s1, s2;\n        dfs(s, s1, s2, 0);\n        return ans;\n    }\n    \n    void dfs(string &s, string s1, string s2, int index) {\n        if(check(s1) && check(s2)) ans = max(ans, int(s1.size() * s2.size()));\n        if(index == s.size()) return;\n        dfs(s, s1 + s[index], s2, index + 1);//子序列s1使用该字符\n        dfs(s, s1, s2 + s[index], index + 1);//子序列s2使用该字符\n        dfs(s, s1, s2, index + 1);//子序列都不使用该字符\n    }\n    \n    bool check(string &s) {\n        int l = 0, r = s.size() - 1;\n        while(l < r) {\n            if(s[l++] != s[r--]) return false;\n        }\n        return true;\n    }\n};\n\n作者：ytmartian\n链接：https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/dfsliang-ge-zi-xu-lie-by-ytmartian-svyn/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T4 5870. 每棵子树内缺失的最小基因值\n\n-   **通过的用户数**175\n-   **尝试过的用户数**539\n-   **用户总通过次数**213\n-   **用户总提交次数**1154\n-   **题目难度** **Hard**\n\n有一棵根节点为 `0` 的 **家族树** ，总共包含 `n` 个节点，节点编号为 `0` 到 `n - 1` 。给你一个下标从 **0** 开始的整数数组 `parents` ，其中 `parents[i]` 是节点 `i` 的父节点。由于节点 `0` 是 **根** ，所以 `parents[0] == -1` 。\n\n总共有 `105` 个基因值，每个基因值都用 **闭区间** `[1, 105]` 中的一个整数表示。给你一个下标从 **0** 开始的整数数组 `nums` ，其中 `nums[i]` 是节点 `i` 的基因值，且基因值 **互不相同** 。\n\n请你返回一个数组 `ans` ，长度为 `n` ，其中 `ans[i]` 是以节点 `i` 为根的子树内 **缺失** 的 **最小** 基因值。\n\n节点 `x` 为根的 **子树** 包含节点 `x` 和它所有的 **后代** 节点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/23/case-1.png)\n\n```\n输入：parents = [-1,0,0,2], nums = [1,2,3,4]\n输出：[5,1,1,1]\n解释：每个子树答案计算结果如下：\n- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。\n- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。\n- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。\n- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/23/case-2.png)\n\n```\n输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]\n输出：[7,1,1,4,2,1]\n解释：每个子树答案计算结果如下：\n- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。\n- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。\n- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。\n- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。\n- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。\n- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。\n```\n\n**示例 3：**\n\n```\n输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]\n输出：[1,1,1,1,1,1,1]\n解释：所有子树都缺失基因值 1 。\n```\n\n**提示：**\n\n-   `n == parents.length == nums.length`\n-   `2 <= n <= 105`\n-   对于 `i != 0` ，满足 `0 <= parents[i] <= n - 1`\n-   `parents[0] == -1`\n-   `parents` 表示一棵合法的树。\n-   `1 <= nums[i] <= 105`\n-   `nums[i]` 互不相同。\n\n**解法笔记**\n\n**解法一：启发式合并**\n遍历整棵树，统计每棵子树包含的基因值集合以及缺失的最小基因值，记作 $\\textit{mex}$。合并基因值集合时，总是从小的往大的合并（类似并查集的按秩合并），同时更新当前子树的 $\\textit{mex}$ 的最大值。合并完成后再不断自增子树的 $\\textit{mex}$ 直至其不在基因值集合中。\n\n这一方法同时也适用于有相同基因值的情况。\n\n时间复杂度：$O(n\\log n)$。证明。\n\n```go\nfunc smallestMissingValueSubtree(parents []int, nums []int) []int {\n\tn := len(parents)\n\tg := make([][]int, n)\n\tfor w := 1; w < n; w++ {\n\t\tv := parents[w]\n\t\tg[v] = append(g[v], w)\n\t}\n\tmex := make([]int, n)\n\tvar f func(int) map[int]bool\n\tf = func(v int) map[int]bool {\n\t\tset := map[int]bool{}\n\t\tmex[v] = 1\n\t\tfor _, w := range g[v] {\n\t\t\ts := f(w)\n\t\t\t// 保证总是从小集合合并到大集合上\n\t\t\tif len(s) > len(set) {\n\t\t\t\tset, s = s, set\n\t\t\t}\n\t\t\tfor x := range s {\n\t\t\t\tset[x] = true\n\t\t\t}\n\t\t\tif mex[w] > mex[v] {\n\t\t\t\tmex[v] = mex[w]\n\t\t\t}\n\t\t}\n\t\tset[nums[v]] = true\n\t\tfor set[mex[v]] {\n\t\t\tmex[v]++ // 不断自增 mex 直至其不在基因值集合中\n\t\t}\n\t\treturn set\n\t}\n\tf(0)\n\treturn mex\n}\n\n作者：endlesscheng\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n**解法二：利用无重复基因值的性质**\n由于没有重复基因值，若存在节点 $x$，其基因值等于 $1$，则从 $x$ 到根的这一条链上的所有节点的 $\\textit{mex}$ 均超过 $1$，而其余节点的 $\\textit{mex}$ 值均为 $1$。我们顺着 $x$ 往根上走，同时收集当前子树的基因值到集合中，然后更新当前子树的 $\\textit{mex}$ 值。\n\n时间复杂度：$O(n)$。\n\n```go\nfunc smallestMissingValueSubtree(parents []int, nums []int) []int {\n\tn := len(parents)\n\tg := make([][]int, n)\n\tfor w := 1; w < n; w++ {\n\t\tv := parents[w]\n\t\tg[v] = append(g[v], w)\n\t}\n\n\tmex := make([]int, n)\n\tfor i := range mex {\n\t\tmex[i] = 1\n\t}\n\t\n\tset := map[int]bool{}\n\tvis := make([]bool, n)\n\tvar f func(int)\n\tf = func(v int) {\n\t\tset[nums[v]] = true // 收集基因值到 set 中\n\t\tfor _, w := range g[v] {\n\t\t\tif !vis[w] {\n\t\t\t\tf(w)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 找基因值等于 1 的节点 x\n\tx := -1\n\tfor i, v := range nums {\n\t\tif v == 1 {\n\t\t\tx = i\n\t\t\tbreak\n\t\t}\n\t}\n\t// x 顺着父节点往上走\n\tfor cur := 2; x >= 0; x = parents[x] {\n\t\tf(x)\n\t\tvis[x] = true // 这是保证时间复杂度的关键：之后遍历父节点子树时，就无需再次遍历 x 子树了\n\t\tfor set[cur] {\n\t\t\tcur++ // 不断自增直至不在基因值集合中\n\t\t}\n\t\tmex[x] = cur\n\t}\n\treturn mex\n}\n\n作者：endlesscheng\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n**不一样的思路：主席树+dfs序（突破值互不相同的限制）**\n\n-   看到很多题解是从基因值互不相同的条件入手写的，后来突然发现我的解法不需要考虑这个\n-   可能我的思路比较繁琐，时间复杂度有没有O(n)的优秀，固在此也只是想提供一个与众不同的思路罢了（勿喷）\n-   前置知识：主席树，dfs序\n-   注意到，这题的本质就是求mex，但不同的是，其不是真正的mex，最小的数是1，mex最小的数是0，但不影响做这题。\n-   将问题转化一下，求一个区间的mex，可以线段树、主席树，这里使用主席树做方便\n-   主席树找mex的思路\n    -   利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了\n    -   最终查询 `[L, R]` 区间的mex时，则是在版本 `R` 的权值线段树中找下标小于 `L` 的最小的数即可\n-   再来就是怎么将区间转化成树上查询，显然可以用到dfs序了\n\n```c++\nconst int N = 1e5 + 5;\nstruct pii {\n    int x, y;\n};\npii p[N];\n\nint head[N], cnt, tim;\n\n//初始化\nvoid init(int n) { fill_n(head, n + 5, -1); cnt = -1; tim = 0; }\n\nstruct edges {\n    int to, next;\n    void add(int t, int n) {\n        to = t, next = n;\n    }\n}edge[N << 1]; //无向图则需要乘2\n\ninline void add(int u, int v) {\n    edge[++cnt].add(v, head[u]);\n    head[u] = cnt;\n}\n\nint a[N], ram, root[N], vis[N];\nvoid dfs(int u, vector<int>& num) {\n    p[u].x = ++tim;\n    a[tim] = num[u]; // 重置数组\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        dfs(edge[i].to, num);\n    }\n    p[u].y = tim;\n}\n\n\nstruct nodes {int l, r, minv; } hjt[N * 25];\n\nint modify(int pre, int l, int r, int val, int pos) {\n    int now = ++ram;\n    hjt[now] = hjt[pre];\n    if (l == r) {\n        hjt[now].minv = pos;\n        return now;\n    }\n    int mid = (l + r) >> 1;\n    if (val <= mid) hjt[now].l = modify(hjt[now].l, l, mid, val, pos);\n    else hjt[now].r = modify(hjt[now].r, mid + 1, r, val, pos);\n    hjt[now].minv = min(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv);\n    return now;\n}\n\nint query(int tr, int l, int r, int ql) {\n    if (l == r) return l;\n    int mid = (l + r) >> 1;\n    if (hjt[hjt[tr].l].minv < ql) return query(hjt[tr].l, l, mid, ql);\n    return query(hjt[tr].r, mid + 1, r, ql);\n}\n\n\nclass Solution {\npublic:\n    vector<int> smallestMissingValueSubtree(vector<int>& pa, vector<int>& nums) {\n        int n = pa.size();\n        init(n);\n        ram = 0;\n        for (int i = 0; i < n; ++i) {\n            if (pa[i] != -1) {\n                add(pa[i], i);\n            }\n        }\n        dfs(0, nums); // 预处理dfs序\n        vector<int> ans(n, 0);\n        int len = *max_element(nums.begin(), nums.end()) + 1; // 找到最大值，记得+1\n        for (int i = 1; i <= n; ++i) {\n            root[i] = modify(root[i - 1], 1, len, a[i], i); // 主席树插入，注意此时用到的数组是a，不是nums了\n        }\n        for (int i = 0; i < n; ++i) {\n            // cout << p[i].x << ' ' << p[i].y << endl;\n            ans[i] = query(root[p[i].y], 1, len, p[i].x);// 查询结点i的子树，意味在查询dfs序中区间[p[i].x, p[i].y]的答案\n        }\n        return ans;\n    }\n};\n\n作者：haoboy\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/zhu-xi-shu-dfsxu-tu-po-zhi-hu-bu-xiang-t-7nh8/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","source":"_posts/weekly-contest-258.md","raw":"---\ntitle: LeetCode 周赛 258\ndate: 2021-09-12 16:51:09\ntags: LeetCode 周赛总结\n---\n\n---\n\n# LeetCode 周赛 258\n\n| 排名       | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-258/problems/reverse-prefix-of-word/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-258/problems/number-of-pairs-of-interchangeable-rectangles/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-258/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-258/problems/smallest-missing-genetic-value-in-each-subtree/) |\n| ---------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 738 / 4518 | MiracleSNeko | 12   | 1:09:58  | 0:20:57                                                      | 0:33:48 1                                                    | 0:59:58 1                                                    |                                                              |\n\n## T1 5867. 反转单词前缀\n\n-   **通过的用户数**3464\n-   **尝试过的用户数**3498\n-   **用户总通过次数**3507\n-   **用户总提交次数**4264\n-   **题目难度** **Easy**\n\n给你一个下标从 **0** 开始的字符串 `word` 和一个字符 `ch` 。找出 `ch` 第一次出现的下标 `i` ，**反转** `word` 中从下标 `0` 开始、直到下标 `i` 结束（含下标 `i` ）的那段字符。如果 `word` 中不存在字符 `ch` ，则无需进行任何操作。\n\n-   例如，如果 `word = \"abcdefd\"` 且 `ch = \"d\"` ，那么你应该 **反转** 从下标 0 开始、直到下标 `3` 结束（含下标 `3` ）。结果字符串将会是 `\"***dcba***efd\"` 。\n\n返回 **结果字符串** 。\n\n**示例 1：**\n\n```\n输入：word = \"abcdefd\", ch = \"d\"\n输出：\"dcbaefd\"\n解释：\"d\" 第一次出现在下标 3 。 \n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"dcbaefd\" 。\n```\n\n**示例 2：**\n\n```\n输入：word = \"xyxzxe\", ch = \"z\"\n输出：\"zxyxxe\"\n解释：\"z\" 第一次也是唯一一次出现是在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"zxyxxe\" 。\n```\n\n**示例 3：**\n\n```\n输入：word = \"abcd\", ch = \"z\"\n输出：\"abcd\"\n解释：\"z\" 不存在于 word 中。\n无需执行反转操作，结果字符串是 \"abcd\" 。\n```\n\n**提示：**\n\n-   `1 <= word.length <= 250`\n-   `word` 由小写英文字母组成\n-   `ch` 是一个小写英文字母\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n    std::string reversePrefix(std::string word, char ch)\n    {\n        CHEATING_HEAD;\n        auto pos = word.find(ch);\n        if (pos != str::npos)\n        {\n            str prv = str(word.begin(), word.begin() + pos + 1);\n            str pst = str(word.begin() + pos + 1, word.end());\n            prv = str(prv.rbegin(), prv.rend());\n            return prv + pst;\n        }\n        return word;\n    }\n};\n```\n\n\n\n## T2 5868. 可互换矩形的组数\n\n-   **通过的用户数**2656\n-   **尝试过的用户数**3291\n-   **用户总通过次数**2705\n-   **用户总提交次数**9238\n-   **题目难度** **Medium**\n\n用一个下标从 **0** 开始的二维整数数组 `rectangles` 来表示 `n` 个矩形，其中 `rectangles[i] = [widthi, heighti]` 表示第 `i` 个矩形的宽度和高度。\n\n如果两个矩形 `i` 和 `j`（`i < j`）的宽高比相同，则认为这两个矩形 **可互换** 。更规范的说法是，两个矩形满足 `widthi/heighti == widthj/heightj`（使用实数除法而非整数除法），则认为这两个矩形 **可互换** 。\n\n计算并返回 `rectangles` 中有多少对 **可互换** 矩形。\n\n**示例 1：**\n\n```\n输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]\n输出：6\n解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：\n- 矩形 0 和矩形 1 ：4/8 == 3/6\n- 矩形 0 和矩形 2 ：4/8 == 10/20\n- 矩形 0 和矩形 3 ：4/8 == 15/30\n- 矩形 1 和矩形 2 ：3/6 == 10/20\n- 矩形 1 和矩形 3 ：3/6 == 15/30\n- 矩形 2 和矩形 3 ：10/20 == 15/30\n```\n\n**示例 2：**\n\n```\n输入：rectangles = [[4,5],[7,8]]\n输出：0\n解释：不存在成对的可互换矩形。\n```\n\n**提示：**\n\n-   `n == rectangles.length`\n-   `1 <= n <= 105`\n-   `rectangles[i].length == 2`\n-   `1 <= widthi, heighti <= 105`\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n/*     static constexpr auto Fracs = []()\n    {\n        std::array<i64, 21> fracs({1});\n        for (i64 i = 1; i <= 20; ++i)\n        {\n            fracs[i] = fracs[i - 1] * i;\n        }\n        return fracs;\n    }(); */\n\n    i64 interchangeableRectangles(std::vector<std::vector<int>> &rectangles)\n    {\n        // 找比例相等个数，求组合数 nC2\n        Vecd fracs;\n        for (auto &rect : rectangles)\n        {\n            fracs.emplace_back(static_cast<f64>(rect[0]) / static_cast<f64>(rect[1]));\n        }\n        HashMap<f64, i32> mp;\n        for (auto &f : fracs)\n        {\n            if (mp.count(f) == 0)\n            {\n                mp[f] = 1;\n            }\n            else\n            {\n                mp[f] += 1;\n            }\n        }\n        i64 ans = 0;\n        for (auto &kv : mp)\n        {\n            i64 cnt = kv.second;\n            if (cnt > 1)\n            {\n                ans += cnt * (cnt - 1) / 2;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n>   注：此处用 `double` 类型不涉及加减运算，只涉及判等，所以 `double` 作为 `key` 不会导致精度问题。\n\n-   WA 的原因： 把 $C(n, 2) = n(n - 1) / 2$ 写成了 $n!(n-1)!/2$\n\n\n\n## L3 5869. 两个回文子序列长度的最大乘积\n\n-   **通过的用户数**971\n-   **尝试过的用户数**1189\n-   **用户总通过次数**1017\n-   **用户总提交次数**2093\n-   **题目难度** **Medium**\n\n给你一个字符串 `s` ，请你找到 `s` 中两个 **不相交回文子序列** ，使得它们长度的 **乘积最大** 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 **不相交** 的。\n\n请你返回两个回文子序列长度可以达到的 **最大乘积** 。\n\n**子序列** 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 **回文字符串** 。\n\n**示例 1：**\n\n![example-1](https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png)\n\n```\n输入：s = \"leetcodecom\"\n输出：9\n解释：最优方案是选择 \"ete\" 作为第一个子序列，\"cdc\" 作为第二个子序列。\n它们的乘积为 3 * 3 = 9 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"bb\"\n输出：1\n解释：最优方案为选择 \"b\" （第一个字符）作为第一个子序列，\"b\" （第二个字符）作为第二个子序列。\n它们的乘积为 1 * 1 = 1 。\n```\n\n**示例 3：**\n\n```\n输入：s = \"accbcaxxcxx\"\n输出：25\n解释：最优方案为选择 \"accca\" 作为第一个子序列，\"xxcxx\" 作为第二个子序列。\n它们的乘积为 5 * 5 = 25 。\n```\n\n**提示：**\n\n-   `2 <= s.length <= 12`\n-   `s` 只含有小写英文字母。\n\n**我提交的代码**\n\n```c++\nclass Solution\n{\npublic:\n    i32 countOnes(i32 x)\n    {\n        x = ((x >> 1) & 0x55555555) + (x & 0x55555555);\n        x = ((x >> 2) & 0x33333333) + (x & 0x33333333);\n        x = ((x >> 4) & 0x0f0f0f0f) + (x & 0x0f0f0f0f);\n        x = ((x >> 8) & 0x00ff00ff) + (x & 0x00ff00ff);\n        x = ((x >> 16) & 0x0000ffff) + (x & 0x0000ffff);\n        return x;\n    }\n\n    int maxProduct(str s)\n    {\n        auto check = [&s](i32 status) -> bool\n        {\n            Veci pos1({});\n            for (i32 i = 0; i < 13; ++i)\n            {\n                if (status & (1 << i))\n                    pos1.push_back(i);\n            }\n            if (pos1.size() == 1)\n                return true;\n            i32 i = 0, j = pos1.size() - 1;\n            while (i <= j)\n            {\n                if (s[pos1[i]] != s[pos1[j]])\n                    return false;\n                ++i, --j;\n            }\n            return true;\n        };\n        // 预处理所有回文子串\n        i32 sts = 1 << s.size();\n        Veci checked;\n        for (i32 st = 1; st < sts; ++st)\n        {\n            if (check(st))\n                checked.push_back(st);\n        }\n        // 遍历所有回文字串求结果\n        i32 ans = -Inf;\n        i32 clen = checked.size();\n        for (i32 i = 0; i < clen; ++i)\n        {\n            i32 sti = checked[i];\n            for (i32 j = i + 1; j < clen; ++j)\n            {\n                i32 stj = checked[j];\n                if ((sti & stj) == 0) // 无重复\n                {\n                    ans = std::max(ans, countOnes(sti) * countOnes(stj));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n>   注：本质是暴力遍历\n\n-   TLE 的原因：一开始直接暴力二重循环，没预处理回文字符串，遍历了大量的垃圾状态\n\n**其他思路**\n\ndfs 两个子序列。对于位置 i ，两个子序列可以选择用或者不用。\n\n```c++\nclass Solution {\npublic:\n    int ans = 0;\n    int maxProduct(string s) {\n        string s1, s2;\n        dfs(s, s1, s2, 0);\n        return ans;\n    }\n    \n    void dfs(string &s, string s1, string s2, int index) {\n        if(check(s1) && check(s2)) ans = max(ans, int(s1.size() * s2.size()));\n        if(index == s.size()) return;\n        dfs(s, s1 + s[index], s2, index + 1);//子序列s1使用该字符\n        dfs(s, s1, s2 + s[index], index + 1);//子序列s2使用该字符\n        dfs(s, s1, s2, index + 1);//子序列都不使用该字符\n    }\n    \n    bool check(string &s) {\n        int l = 0, r = s.size() - 1;\n        while(l < r) {\n            if(s[l++] != s[r--]) return false;\n        }\n        return true;\n    }\n};\n\n作者：ytmartian\n链接：https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/dfsliang-ge-zi-xu-lie-by-ytmartian-svyn/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n## T4 5870. 每棵子树内缺失的最小基因值\n\n-   **通过的用户数**175\n-   **尝试过的用户数**539\n-   **用户总通过次数**213\n-   **用户总提交次数**1154\n-   **题目难度** **Hard**\n\n有一棵根节点为 `0` 的 **家族树** ，总共包含 `n` 个节点，节点编号为 `0` 到 `n - 1` 。给你一个下标从 **0** 开始的整数数组 `parents` ，其中 `parents[i]` 是节点 `i` 的父节点。由于节点 `0` 是 **根** ，所以 `parents[0] == -1` 。\n\n总共有 `105` 个基因值，每个基因值都用 **闭区间** `[1, 105]` 中的一个整数表示。给你一个下标从 **0** 开始的整数数组 `nums` ，其中 `nums[i]` 是节点 `i` 的基因值，且基因值 **互不相同** 。\n\n请你返回一个数组 `ans` ，长度为 `n` ，其中 `ans[i]` 是以节点 `i` 为根的子树内 **缺失** 的 **最小** 基因值。\n\n节点 `x` 为根的 **子树** 包含节点 `x` 和它所有的 **后代** 节点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/23/case-1.png)\n\n```\n输入：parents = [-1,0,0,2], nums = [1,2,3,4]\n输出：[5,1,1,1]\n解释：每个子树答案计算结果如下：\n- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。\n- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。\n- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。\n- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/08/23/case-2.png)\n\n```\n输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]\n输出：[7,1,1,4,2,1]\n解释：每个子树答案计算结果如下：\n- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。\n- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。\n- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。\n- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。\n- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。\n- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。\n```\n\n**示例 3：**\n\n```\n输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]\n输出：[1,1,1,1,1,1,1]\n解释：所有子树都缺失基因值 1 。\n```\n\n**提示：**\n\n-   `n == parents.length == nums.length`\n-   `2 <= n <= 105`\n-   对于 `i != 0` ，满足 `0 <= parents[i] <= n - 1`\n-   `parents[0] == -1`\n-   `parents` 表示一棵合法的树。\n-   `1 <= nums[i] <= 105`\n-   `nums[i]` 互不相同。\n\n**解法笔记**\n\n**解法一：启发式合并**\n遍历整棵树，统计每棵子树包含的基因值集合以及缺失的最小基因值，记作 $\\textit{mex}$。合并基因值集合时，总是从小的往大的合并（类似并查集的按秩合并），同时更新当前子树的 $\\textit{mex}$ 的最大值。合并完成后再不断自增子树的 $\\textit{mex}$ 直至其不在基因值集合中。\n\n这一方法同时也适用于有相同基因值的情况。\n\n时间复杂度：$O(n\\log n)$。证明。\n\n```go\nfunc smallestMissingValueSubtree(parents []int, nums []int) []int {\n\tn := len(parents)\n\tg := make([][]int, n)\n\tfor w := 1; w < n; w++ {\n\t\tv := parents[w]\n\t\tg[v] = append(g[v], w)\n\t}\n\tmex := make([]int, n)\n\tvar f func(int) map[int]bool\n\tf = func(v int) map[int]bool {\n\t\tset := map[int]bool{}\n\t\tmex[v] = 1\n\t\tfor _, w := range g[v] {\n\t\t\ts := f(w)\n\t\t\t// 保证总是从小集合合并到大集合上\n\t\t\tif len(s) > len(set) {\n\t\t\t\tset, s = s, set\n\t\t\t}\n\t\t\tfor x := range s {\n\t\t\t\tset[x] = true\n\t\t\t}\n\t\t\tif mex[w] > mex[v] {\n\t\t\t\tmex[v] = mex[w]\n\t\t\t}\n\t\t}\n\t\tset[nums[v]] = true\n\t\tfor set[mex[v]] {\n\t\t\tmex[v]++ // 不断自增 mex 直至其不在基因值集合中\n\t\t}\n\t\treturn set\n\t}\n\tf(0)\n\treturn mex\n}\n\n作者：endlesscheng\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n**解法二：利用无重复基因值的性质**\n由于没有重复基因值，若存在节点 $x$，其基因值等于 $1$，则从 $x$ 到根的这一条链上的所有节点的 $\\textit{mex}$ 均超过 $1$，而其余节点的 $\\textit{mex}$ 值均为 $1$。我们顺着 $x$ 往根上走，同时收集当前子树的基因值到集合中，然后更新当前子树的 $\\textit{mex}$ 值。\n\n时间复杂度：$O(n)$。\n\n```go\nfunc smallestMissingValueSubtree(parents []int, nums []int) []int {\n\tn := len(parents)\n\tg := make([][]int, n)\n\tfor w := 1; w < n; w++ {\n\t\tv := parents[w]\n\t\tg[v] = append(g[v], w)\n\t}\n\n\tmex := make([]int, n)\n\tfor i := range mex {\n\t\tmex[i] = 1\n\t}\n\t\n\tset := map[int]bool{}\n\tvis := make([]bool, n)\n\tvar f func(int)\n\tf = func(v int) {\n\t\tset[nums[v]] = true // 收集基因值到 set 中\n\t\tfor _, w := range g[v] {\n\t\t\tif !vis[w] {\n\t\t\t\tf(w)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 找基因值等于 1 的节点 x\n\tx := -1\n\tfor i, v := range nums {\n\t\tif v == 1 {\n\t\t\tx = i\n\t\t\tbreak\n\t\t}\n\t}\n\t// x 顺着父节点往上走\n\tfor cur := 2; x >= 0; x = parents[x] {\n\t\tf(x)\n\t\tvis[x] = true // 这是保证时间复杂度的关键：之后遍历父节点子树时，就无需再次遍历 x 子树了\n\t\tfor set[cur] {\n\t\t\tcur++ // 不断自增直至不在基因值集合中\n\t\t}\n\t\tmex[x] = cur\n\t}\n\treturn mex\n}\n\n作者：endlesscheng\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n**不一样的思路：主席树+dfs序（突破值互不相同的限制）**\n\n-   看到很多题解是从基因值互不相同的条件入手写的，后来突然发现我的解法不需要考虑这个\n-   可能我的思路比较繁琐，时间复杂度有没有O(n)的优秀，固在此也只是想提供一个与众不同的思路罢了（勿喷）\n-   前置知识：主席树，dfs序\n-   注意到，这题的本质就是求mex，但不同的是，其不是真正的mex，最小的数是1，mex最小的数是0，但不影响做这题。\n-   将问题转化一下，求一个区间的mex，可以线段树、主席树，这里使用主席树做方便\n-   主席树找mex的思路\n    -   利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了\n    -   最终查询 `[L, R]` 区间的mex时，则是在版本 `R` 的权值线段树中找下标小于 `L` 的最小的数即可\n-   再来就是怎么将区间转化成树上查询，显然可以用到dfs序了\n\n```c++\nconst int N = 1e5 + 5;\nstruct pii {\n    int x, y;\n};\npii p[N];\n\nint head[N], cnt, tim;\n\n//初始化\nvoid init(int n) { fill_n(head, n + 5, -1); cnt = -1; tim = 0; }\n\nstruct edges {\n    int to, next;\n    void add(int t, int n) {\n        to = t, next = n;\n    }\n}edge[N << 1]; //无向图则需要乘2\n\ninline void add(int u, int v) {\n    edge[++cnt].add(v, head[u]);\n    head[u] = cnt;\n}\n\nint a[N], ram, root[N], vis[N];\nvoid dfs(int u, vector<int>& num) {\n    p[u].x = ++tim;\n    a[tim] = num[u]; // 重置数组\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        dfs(edge[i].to, num);\n    }\n    p[u].y = tim;\n}\n\n\nstruct nodes {int l, r, minv; } hjt[N * 25];\n\nint modify(int pre, int l, int r, int val, int pos) {\n    int now = ++ram;\n    hjt[now] = hjt[pre];\n    if (l == r) {\n        hjt[now].minv = pos;\n        return now;\n    }\n    int mid = (l + r) >> 1;\n    if (val <= mid) hjt[now].l = modify(hjt[now].l, l, mid, val, pos);\n    else hjt[now].r = modify(hjt[now].r, mid + 1, r, val, pos);\n    hjt[now].minv = min(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv);\n    return now;\n}\n\nint query(int tr, int l, int r, int ql) {\n    if (l == r) return l;\n    int mid = (l + r) >> 1;\n    if (hjt[hjt[tr].l].minv < ql) return query(hjt[tr].l, l, mid, ql);\n    return query(hjt[tr].r, mid + 1, r, ql);\n}\n\n\nclass Solution {\npublic:\n    vector<int> smallestMissingValueSubtree(vector<int>& pa, vector<int>& nums) {\n        int n = pa.size();\n        init(n);\n        ram = 0;\n        for (int i = 0; i < n; ++i) {\n            if (pa[i] != -1) {\n                add(pa[i], i);\n            }\n        }\n        dfs(0, nums); // 预处理dfs序\n        vector<int> ans(n, 0);\n        int len = *max_element(nums.begin(), nums.end()) + 1; // 找到最大值，记得+1\n        for (int i = 1; i <= n; ++i) {\n            root[i] = modify(root[i - 1], 1, len, a[i], i); // 主席树插入，注意此时用到的数组是a，不是nums了\n        }\n        for (int i = 0; i < n; ++i) {\n            // cout << p[i].x << ' ' << p[i].y << endl;\n            ans[i] = query(root[p[i].y], 1, len, p[i].x);// 查询结点i的子树，意味在查询dfs序中区间[p[i].x, p[i].y]的答案\n        }\n        return ans;\n    }\n};\n\n作者：haoboy\n链接：https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/zhu-xi-shu-dfsxu-tu-po-zhi-hu-bu-xiang-t-7nh8/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","slug":"weekly-contest-258","published":1,"updated":"2021-11-17T05:21:51.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3kx8q5000r1cy573zuf48j","content":"<hr>\n<h1 id=\"LeetCode-周赛-258\"><a href=\"#LeetCode-周赛-258\" class=\"headerlink\" title=\"LeetCode 周赛 258\"></a>LeetCode 周赛 258</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/reverse-prefix-of-word/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/number-of-pairs-of-interchangeable-rectangles/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/smallest-missing-genetic-value-in-each-subtree/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>738 / 4518</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:09:58</td>\n<td>0:20:57</td>\n<td>0:33:48 1</td>\n<td>0:59:58 1</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5867-反转单词前缀\"><a href=\"#T1-5867-反转单词前缀\" class=\"headerlink\" title=\"T1 5867. 反转单词前缀\"></a>T1 5867. 反转单词前缀</h2><ul>\n<li>  <strong>通过的用户数</strong>3464</li>\n<li>  <strong>尝试过的用户数</strong>3498</li>\n<li>  <strong>用户总通过次数</strong>3507</li>\n<li>  <strong>用户总提交次数</strong>4264</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个字符 <code>ch</code> 。找出 <code>ch</code> 第一次出现的下标 <code>i</code> ，<strong>反转</strong> <code>word</code> 中从下标 <code>0</code> 开始、直到下标 <code>i</code> 结束（含下标 <code>i</code> ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p>\n<ul>\n<li>  例如，如果 <code>word = &quot;abcdefd&quot;</code> 且 <code>ch = &quot;d&quot;</code> ，那么你应该 <strong>反转</strong> 从下标 0 开始、直到下标 <code>3</code> 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>&quot;***dcba***efd&quot;</code> 。</li>\n</ul>\n<p>返回 <strong>结果字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;abcdefd&quot;, ch = &quot;d&quot;</span><br><span class=\"line\">输出：&quot;dcbaefd&quot;</span><br><span class=\"line\">解释：&quot;d&quot; 第一次出现在下标 3 。 </span><br><span class=\"line\">反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;dcbaefd&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;xyxzxe&quot;, ch = &quot;z&quot;</span><br><span class=\"line\">输出：&quot;zxyxxe&quot;</span><br><span class=\"line\">解释：&quot;z&quot; 第一次也是唯一一次出现是在下标 3 。</span><br><span class=\"line\">反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;zxyxxe&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;abcd&quot;, ch = &quot;z&quot;</span><br><span class=\"line\">输出：&quot;abcd&quot;</span><br><span class=\"line\">解释：&quot;z&quot; 不存在于 word 中。</span><br><span class=\"line\">无需执行反转操作，结果字符串是 &quot;abcd&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= word.length &lt;= 250</code></li>\n<li>  <code>word</code> 由小写英文字母组成</li>\n<li>  <code>ch</code> 是一个小写英文字母</li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">reversePrefix</span><span class=\"params\">(std::string word, <span class=\"keyword\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        CHEATING_HEAD;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> pos = word.<span class=\"built_in\">find</span>(ch);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos != str::npos)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            str prv = <span class=\"built_in\">str</span>(word.<span class=\"built_in\">begin</span>(), word.<span class=\"built_in\">begin</span>() + pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">            str pst = <span class=\"built_in\">str</span>(word.<span class=\"built_in\">begin</span>() + pos + <span class=\"number\">1</span>, word.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            prv = <span class=\"built_in\">str</span>(prv.<span class=\"built_in\">rbegin</span>(), prv.<span class=\"built_in\">rend</span>());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> prv + pst;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5868-可互换矩形的组数\"><a href=\"#T2-5868-可互换矩形的组数\" class=\"headerlink\" title=\"T2 5868. 可互换矩形的组数\"></a>T2 5868. 可互换矩形的组数</h2><ul>\n<li>  <strong>通过的用户数</strong>2656</li>\n<li>  <strong>尝试过的用户数</strong>3291</li>\n<li>  <strong>用户总通过次数</strong>2705</li>\n<li>  <strong>用户总提交次数</strong>9238</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>用一个下标从 <strong>0</strong> 开始的二维整数数组 <code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [widthi, heighti]</code> 表示第 <code>i</code> 个矩形的宽度和高度。</p>\n<p>如果两个矩形 <code>i</code> 和 <code>j</code>（<code>i &lt; j</code>）的宽高比相同，则认为这两个矩形 <strong>可互换</strong> 。更规范的说法是，两个矩形满足 <code>widthi/heighti == widthj/heightj</code>（使用实数除法而非整数除法），则认为这两个矩形 <strong>可互换</strong> 。</p>\n<p>计算并返回 <code>rectangles</code> 中有多少对 <strong>可互换</strong> 矩形。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：</span><br><span class=\"line\">- 矩形 0 和矩形 1 ：4/8 == 3/6</span><br><span class=\"line\">- 矩形 0 和矩形 2 ：4/8 == 10/20</span><br><span class=\"line\">- 矩形 0 和矩形 3 ：4/8 == 15/30</span><br><span class=\"line\">- 矩形 1 和矩形 2 ：3/6 == 10/20</span><br><span class=\"line\">- 矩形 1 和矩形 3 ：3/6 == 15/30</span><br><span class=\"line\">- 矩形 2 和矩形 3 ：10/20 == 15/30</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[4,5],[7,8]]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：不存在成对的可互换矩形。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == rectangles.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>rectangles[i].length == 2</code></li>\n<li>  <code>1 &lt;= widthi, heighti &lt;= 105</code></li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">/*     static constexpr auto Fracs = []()</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        std::array&lt;i64, 21&gt; fracs(&#123;1&#125;);</span></span><br><span class=\"line\"><span class=\"comment\">        for (i64 i = 1; i &lt;= 20; ++i)</span></span><br><span class=\"line\"><span class=\"comment\">        &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            fracs[i] = fracs[i - 1] * i;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        return fracs;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;(); */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">i64 <span class=\"title\">interchangeableRectangles</span><span class=\"params\">(std::vector&lt;std::vector&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;rectangles)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找比例相等个数，求组合数 nC2</span></span><br><span class=\"line\">        Vecd fracs;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;rect : rectangles)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fracs.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">static_cast</span>&lt;f64&gt;(rect[<span class=\"number\">0</span>]) / <span class=\"keyword\">static_cast</span>&lt;f64&gt;(rect[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HashMap&lt;f64, i32&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;f : fracs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(f) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[f] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[f] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i64 ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;kv : mp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i64 cnt = kv.second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += cnt * (cnt - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  注：此处用 <code>double</code> 类型不涉及加减运算，只涉及判等，所以 <code>double</code> 作为 <code>key</code> 不会导致精度问题。</p>\n</blockquote>\n<ul>\n<li>  WA 的原因： 把 $C(n, 2) = n(n - 1) / 2$ 写成了 $n!(n-1)!/2$</li>\n</ul>\n<h2 id=\"L3-5869-两个回文子序列长度的最大乘积\"><a href=\"#L3-5869-两个回文子序列长度的最大乘积\" class=\"headerlink\" title=\"L3 5869. 两个回文子序列长度的最大乘积\"></a>L3 5869. 两个回文子序列长度的最大乘积</h2><ul>\n<li>  <strong>通过的用户数</strong>971</li>\n<li>  <strong>尝试过的用户数</strong>1189</li>\n<li>  <strong>用户总通过次数</strong>1017</li>\n<li>  <strong>用户总提交次数</strong>2093</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个字符串 <code>s</code> ，请你找到 <code>s</code> 中两个 <strong>不相交回文子序列</strong> ，使得它们长度的 <strong>乘积最大</strong> 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 <strong>不相交</strong> 的。</p>\n<p>请你返回两个回文子序列长度可以达到的 <strong>最大乘积</strong> 。</p>\n<p><strong>子序列</strong> 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 <strong>回文字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;leetcodecom&quot;</span><br><span class=\"line\">输出：9</span><br><span class=\"line\">解释：最优方案是选择 &quot;ete&quot; 作为第一个子序列，&quot;cdc&quot; 作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 3 * 3 = 9 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bb&quot;</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：最优方案为选择 &quot;b&quot; （第一个字符）作为第一个子序列，&quot;b&quot; （第二个字符）作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 1 * 1 = 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;accbcaxxcxx&quot;</span><br><span class=\"line\">输出：25</span><br><span class=\"line\">解释：最优方案为选择 &quot;accca&quot; 作为第一个子序列，&quot;xxcxx&quot; 作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 5 * 5 = 25 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= s.length &lt;= 12</code></li>\n<li>  <code>s</code> 只含有小写英文字母。</li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">i32 <span class=\"title\">countOnes</span><span class=\"params\">(i32 x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">1</span>) &amp; <span class=\"number\">0x55555555</span>) + (x &amp; <span class=\"number\">0x55555555</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">2</span>) &amp; <span class=\"number\">0x33333333</span>) + (x &amp; <span class=\"number\">0x33333333</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0x0f0f0f0f</span>) + (x &amp; <span class=\"number\">0x0f0f0f0f</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0x00ff00ff</span>) + (x &amp; <span class=\"number\">0x00ff00ff</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0x0000ffff</span>) + (x &amp; <span class=\"number\">0x0000ffff</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(str s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;s](i32 status) -&gt; <span class=\"keyword\">bool</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Veci <span class=\"built_in\">pos1</span>(&#123;&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i32 i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">13</span>; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (status &amp; (<span class=\"number\">1</span> &lt;&lt; i))</span><br><span class=\"line\">                    pos1.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos1.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i32 i = <span class=\"number\">0</span>, j = pos1.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[pos1[i]] != s[pos1[j]])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                ++i, --j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 预处理所有回文子串</span></span><br><span class=\"line\">        i32 sts = <span class=\"number\">1</span> &lt;&lt; s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        Veci checked;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i32 st = <span class=\"number\">1</span>; st &lt; sts; ++st)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(st))</span><br><span class=\"line\">                checked.<span class=\"built_in\">push_back</span>(st);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有回文字串求结果</span></span><br><span class=\"line\">        i32 ans = -Inf;</span><br><span class=\"line\">        i32 clen = checked.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i32 i = <span class=\"number\">0</span>; i &lt; clen; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i32 sti = checked[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i32 j = i + <span class=\"number\">1</span>; j &lt; clen; ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i32 stj = checked[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sti &amp; stj) == <span class=\"number\">0</span>) <span class=\"comment\">// 无重复</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ans = std::<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">countOnes</span>(sti) * <span class=\"built_in\">countOnes</span>(stj));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  注：本质是暴力遍历</p>\n</blockquote>\n<ul>\n<li>  TLE 的原因：一开始直接暴力二重循环，没预处理回文字符串，遍历了大量的垃圾状态</li>\n</ul>\n<p><strong>其他思路</strong></p>\n<p>dfs 两个子序列。对于位置 i ，两个子序列可以选择用或者不用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        string s1, s2;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(string &amp;s, string s1, string s2, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(s1) &amp;&amp; <span class=\"built_in\">check</span>(s2)) ans = <span class=\"built_in\">max</span>(ans, <span class=\"built_in\"><span class=\"keyword\">int</span></span>(s1.<span class=\"built_in\">size</span>() * s2.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index == s.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1 + s[index], s2, index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列s1使用该字符</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2 + s[index], index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列s2使用该字符</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2, index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列都不使用该字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(string &amp;s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[l++] != s[r--]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：ytmartian</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/dfsliang-ge-zi-xu-lie-by-ytmartian-svyn/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5870-每棵子树内缺失的最小基因值\"><a href=\"#T4-5870-每棵子树内缺失的最小基因值\" class=\"headerlink\" title=\"T4 5870. 每棵子树内缺失的最小基因值\"></a>T4 5870. 每棵子树内缺失的最小基因值</h2><ul>\n<li>  <strong>通过的用户数</strong>175</li>\n<li>  <strong>尝试过的用户数</strong>539</li>\n<li>  <strong>用户总通过次数</strong>213</li>\n<li>  <strong>用户总提交次数</strong>1154</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>有一棵根节点为 <code>0</code> 的 <strong>家族树</strong> ，总共包含 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是 <strong>根</strong> ，所以 <code>parents[0] == -1</code> 。</p>\n<p>总共有 <code>105</code> 个基因值，每个基因值都用 <strong>闭区间</strong> <code>[1, 105]</code> 中的一个整数表示。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是节点 <code>i</code> 的基因值，且基因值 <strong>互不相同</strong> 。</p>\n<p>请你返回一个数组 <code>ans</code> ，长度为 <code>n</code> ，其中 <code>ans[i]</code> 是以节点 <code>i</code> 为根的子树内 <strong>缺失</strong> 的 <strong>最小</strong> 基因值。</p>\n<p>节点 <code>x</code> 为根的 <strong>子树</strong> 包含节点 <code>x</code> 和它所有的 <strong>后代</strong> 节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/23/case-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,0,0,2], nums = [1,2,3,4]</span><br><span class=\"line\">输出：[5,1,1,1]</span><br><span class=\"line\">解释：每个子树答案计算结果如下：</span><br><span class=\"line\">- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。</span><br><span class=\"line\">- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/23/case-2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]</span><br><span class=\"line\">输出：[7,1,1,4,2,1]</span><br><span class=\"line\">解释：每个子树答案计算结果如下：</span><br><span class=\"line\">- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。</span><br><span class=\"line\">- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。</span><br><span class=\"line\">- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。</span><br><span class=\"line\">- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。</span><br><span class=\"line\">- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]</span><br><span class=\"line\">输出：[1,1,1,1,1,1,1]</span><br><span class=\"line\">解释：所有子树都缺失基因值 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == parents.length == nums.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  对于 <code>i != 0</code> ，满足 <code>0 &lt;= parents[i] &lt;= n - 1</code></li>\n<li>  <code>parents[0] == -1</code></li>\n<li>  <code>parents</code> 表示一棵合法的树。</li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n<li>  <code>nums[i]</code> 互不相同。</li>\n</ul>\n<p><strong>解法笔记</strong></p>\n<p><strong>解法一：启发式合并</strong><br>遍历整棵树，统计每棵子树包含的基因值集合以及缺失的最小基因值，记作 $\\textit{mex}$。合并基因值集合时，总是从小的往大的合并（类似并查集的按秩合并），同时更新当前子树的 $\\textit{mex}$ 的最大值。合并完成后再不断自增子树的 $\\textit{mex}$ 直至其不在基因值集合中。</p>\n<p>这一方法同时也适用于有相同基因值的情况。</p>\n<p>时间复杂度：$O(n\\log n)$。证明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(parents []<span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(parents)</span><br><span class=\"line\">\tg := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt; n; w++ &#123;</span><br><span class=\"line\">\t\tv := parents[w]</span><br><span class=\"line\">\t\tg[v] = <span class=\"built_in\">append</span>(g[v], w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmex := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">int</span>]<span class=\"title\">bool</span></span></span><br><span class=\"line\">\tf = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">int</span>]<span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\tset := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>&#123;&#125;</span><br><span class=\"line\">\t\tmex[v] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> g[v] &#123;</span><br><span class=\"line\">\t\t\ts := f(w)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 保证总是从小集合合并到大集合上</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &gt; <span class=\"built_in\">len</span>(set) &#123;</span><br><span class=\"line\">\t\t\t\tset, s = s, set</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\t\t\tset[x] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> mex[w] &gt; mex[v] &#123;</span><br><span class=\"line\">\t\t\t\tmex[v] = mex[w]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tset[nums[v]] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> set[mex[v]] &#123;</span><br><span class=\"line\">\t\t\tmex[v]++ <span class=\"comment\">// 不断自增 mex 直至其不在基因值集合中</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> set</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：endlesscheng</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<p><strong>解法二：利用无重复基因值的性质</strong><br>由于没有重复基因值，若存在节点 $x$，其基因值等于 $1$，则从 $x$ 到根的这一条链上的所有节点的 $\\textit{mex}$ 均超过 $1$，而其余节点的 $\\textit{mex}$ 值均为 $1$。我们顺着 $x$ 往根上走，同时收集当前子树的基因值到集合中，然后更新当前子树的 $\\textit{mex}$ 值。</p>\n<p>时间复杂度：$O(n)$。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(parents []<span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(parents)</span><br><span class=\"line\">\tg := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt; n; w++ &#123;</span><br><span class=\"line\">\t\tv := parents[w]</span><br><span class=\"line\">\t\tg[v] = <span class=\"built_in\">append</span>(g[v], w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmex := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> mex &#123;</span><br><span class=\"line\">\t\tmex[i] = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tset := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>&#123;&#125;</span><br><span class=\"line\">\tvis := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span></span><br><span class=\"line\">\tf = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tset[nums[v]] = <span class=\"literal\">true</span> <span class=\"comment\">// 收集基因值到 set 中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> g[v] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !vis[w] &#123;</span><br><span class=\"line\">\t\t\t\tf(w)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 找基因值等于 1 的节点 x</span></span><br><span class=\"line\">\tx := <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tx = i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// x 顺着父节点往上走</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> cur := <span class=\"number\">2</span>; x &gt;= <span class=\"number\">0</span>; x = parents[x] &#123;</span><br><span class=\"line\">\t\tf(x)</span><br><span class=\"line\">\t\tvis[x] = <span class=\"literal\">true</span> <span class=\"comment\">// 这是保证时间复杂度的关键：之后遍历父节点子树时，就无需再次遍历 x 子树了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> set[cur] &#123;</span><br><span class=\"line\">\t\t\tcur++ <span class=\"comment\">// 不断自增直至不在基因值集合中</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmex[x] = cur</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：endlesscheng</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<p><strong>不一样的思路：主席树+dfs序（突破值互不相同的限制）</strong></p>\n<ul>\n<li>  看到很多题解是从基因值互不相同的条件入手写的，后来突然发现我的解法不需要考虑这个</li>\n<li>  可能我的思路比较繁琐，时间复杂度有没有O(n)的优秀，固在此也只是想提供一个与众不同的思路罢了（勿喷）</li>\n<li>  前置知识：主席树，dfs序</li>\n<li>  注意到，这题的本质就是求mex，但不同的是，其不是真正的mex，最小的数是1，mex最小的数是0，但不影响做这题。</li>\n<li>  将问题转化一下，求一个区间的mex，可以线段树、主席树，这里使用主席树做方便</li>\n<li>主席树找mex的思路<ul>\n<li>  利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了</li>\n<li>  最终查询 <code>[L, R]</code> 区间的mex时，则是在版本 <code>R</code> 的权值线段树中找下标小于 <code>L</code> 的最小的数即可</li>\n</ul>\n</li>\n<li>  再来就是怎么将区间转化成树上查询，显然可以用到dfs序了</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pii</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">pii p[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> head[N], cnt, tim;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"built_in\">fill_n</span>(head, n + <span class=\"number\">5</span>, <span class=\"number\">-1</span>); cnt = <span class=\"number\">-1</span>; tim = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edges</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to, next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        to = t, next = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;edge[N &lt;&lt; <span class=\"number\">1</span>]; <span class=\"comment\">//无向图则需要乘2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">    edge[++cnt].<span class=\"built_in\">add</span>(v, head[u]);</span><br><span class=\"line\">    head[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[N], ram, root[N], vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; num)</span> </span>&#123;</span><br><span class=\"line\">    p[u].x = ++tim;</span><br><span class=\"line\">    a[tim] = num[u]; <span class=\"comment\">// 重置数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].next) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(edge[i].to, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p[u].y = tim;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nodes</span> &#123;</span><span class=\"keyword\">int</span> l, r, minv; &#125; hjt[N * <span class=\"number\">25</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> pre, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = ++ram;</span><br><span class=\"line\">    hjt[now] = hjt[pre];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">        hjt[now].minv = pos;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (val &lt;= mid) hjt[now].l = <span class=\"built_in\">modify</span>(hjt[now].l, l, mid, val, pos);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> hjt[now].r = <span class=\"built_in\">modify</span>(hjt[now].r, mid + <span class=\"number\">1</span>, r, val, pos);</span><br><span class=\"line\">    hjt[now].minv = <span class=\"built_in\">min</span>(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> tr, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hjt[hjt[tr].l].minv &lt; ql) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(hjt[tr].l, l, mid, ql);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(hjt[tr].r, mid + <span class=\"number\">1</span>, r, ql);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; pa, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = pa.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">init</span>(n);</span><br><span class=\"line\">        ram = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pa[i] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">add</span>(pa[i], i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, nums); <span class=\"comment\">// 预处理dfs序</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = *<span class=\"built_in\">max_element</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()) + <span class=\"number\">1</span>; <span class=\"comment\">// 找到最大值，记得+1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            root[i] = <span class=\"built_in\">modify</span>(root[i - <span class=\"number\">1</span>], <span class=\"number\">1</span>, len, a[i], i); <span class=\"comment\">// 主席树插入，注意此时用到的数组是a，不是nums了</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; p[i].x &lt;&lt; &#x27; &#x27; &lt;&lt; p[i].y &lt;&lt; endl;</span></span><br><span class=\"line\">            ans[i] = <span class=\"built_in\">query</span>(root[p[i].y], <span class=\"number\">1</span>, len, p[i].x);<span class=\"comment\">// 查询结点i的子树，意味在查询dfs序中区间[p[i].x, p[i].y]的答案</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：haoboy</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/zhu-xi-shu-dfsxu-tu-po-zhi-hu-bu-xiang-t-7nh8/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-258\"><a href=\"#LeetCode-周赛-258\" class=\"headerlink\" title=\"LeetCode 周赛 258\"></a>LeetCode 周赛 258</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/reverse-prefix-of-word/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/number-of-pairs-of-interchangeable-rectangles/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-258/problems/smallest-missing-genetic-value-in-each-subtree/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>738 / 4518</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:09:58</td>\n<td>0:20:57</td>\n<td>0:33:48 1</td>\n<td>0:59:58 1</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"T1-5867-反转单词前缀\"><a href=\"#T1-5867-反转单词前缀\" class=\"headerlink\" title=\"T1 5867. 反转单词前缀\"></a>T1 5867. 反转单词前缀</h2><ul>\n<li>  <strong>通过的用户数</strong>3464</li>\n<li>  <strong>尝试过的用户数</strong>3498</li>\n<li>  <strong>用户总通过次数</strong>3507</li>\n<li>  <strong>用户总提交次数</strong>4264</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个字符 <code>ch</code> 。找出 <code>ch</code> 第一次出现的下标 <code>i</code> ，<strong>反转</strong> <code>word</code> 中从下标 <code>0</code> 开始、直到下标 <code>i</code> 结束（含下标 <code>i</code> ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p>\n<ul>\n<li>  例如，如果 <code>word = &quot;abcdefd&quot;</code> 且 <code>ch = &quot;d&quot;</code> ，那么你应该 <strong>反转</strong> 从下标 0 开始、直到下标 <code>3</code> 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>&quot;***dcba***efd&quot;</code> 。</li>\n</ul>\n<p>返回 <strong>结果字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;abcdefd&quot;, ch = &quot;d&quot;</span><br><span class=\"line\">输出：&quot;dcbaefd&quot;</span><br><span class=\"line\">解释：&quot;d&quot; 第一次出现在下标 3 。 </span><br><span class=\"line\">反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;dcbaefd&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;xyxzxe&quot;, ch = &quot;z&quot;</span><br><span class=\"line\">输出：&quot;zxyxxe&quot;</span><br><span class=\"line\">解释：&quot;z&quot; 第一次也是唯一一次出现是在下标 3 。</span><br><span class=\"line\">反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;zxyxxe&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：word = &quot;abcd&quot;, ch = &quot;z&quot;</span><br><span class=\"line\">输出：&quot;abcd&quot;</span><br><span class=\"line\">解释：&quot;z&quot; 不存在于 word 中。</span><br><span class=\"line\">无需执行反转操作，结果字符串是 &quot;abcd&quot; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= word.length &lt;= 250</code></li>\n<li>  <code>word</code> 由小写英文字母组成</li>\n<li>  <code>ch</code> 是一个小写英文字母</li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">reversePrefix</span><span class=\"params\">(std::string word, <span class=\"keyword\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        CHEATING_HEAD;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> pos = word.<span class=\"built_in\">find</span>(ch);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos != str::npos)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            str prv = <span class=\"built_in\">str</span>(word.<span class=\"built_in\">begin</span>(), word.<span class=\"built_in\">begin</span>() + pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">            str pst = <span class=\"built_in\">str</span>(word.<span class=\"built_in\">begin</span>() + pos + <span class=\"number\">1</span>, word.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            prv = <span class=\"built_in\">str</span>(prv.<span class=\"built_in\">rbegin</span>(), prv.<span class=\"built_in\">rend</span>());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> prv + pst;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T2-5868-可互换矩形的组数\"><a href=\"#T2-5868-可互换矩形的组数\" class=\"headerlink\" title=\"T2 5868. 可互换矩形的组数\"></a>T2 5868. 可互换矩形的组数</h2><ul>\n<li>  <strong>通过的用户数</strong>2656</li>\n<li>  <strong>尝试过的用户数</strong>3291</li>\n<li>  <strong>用户总通过次数</strong>2705</li>\n<li>  <strong>用户总提交次数</strong>9238</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>用一个下标从 <strong>0</strong> 开始的二维整数数组 <code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [widthi, heighti]</code> 表示第 <code>i</code> 个矩形的宽度和高度。</p>\n<p>如果两个矩形 <code>i</code> 和 <code>j</code>（<code>i &lt; j</code>）的宽高比相同，则认为这两个矩形 <strong>可互换</strong> 。更规范的说法是，两个矩形满足 <code>widthi/heighti == widthj/heightj</code>（使用实数除法而非整数除法），则认为这两个矩形 <strong>可互换</strong> 。</p>\n<p>计算并返回 <code>rectangles</code> 中有多少对 <strong>可互换</strong> 矩形。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：下面按下标（从 0 开始）列出可互换矩形的配对情况：</span><br><span class=\"line\">- 矩形 0 和矩形 1 ：4/8 == 3/6</span><br><span class=\"line\">- 矩形 0 和矩形 2 ：4/8 == 10/20</span><br><span class=\"line\">- 矩形 0 和矩形 3 ：4/8 == 15/30</span><br><span class=\"line\">- 矩形 1 和矩形 2 ：3/6 == 10/20</span><br><span class=\"line\">- 矩形 1 和矩形 3 ：3/6 == 15/30</span><br><span class=\"line\">- 矩形 2 和矩形 3 ：10/20 == 15/30</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[4,5],[7,8]]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：不存在成对的可互换矩形。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == rectangles.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>rectangles[i].length == 2</code></li>\n<li>  <code>1 &lt;= widthi, heighti &lt;= 105</code></li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">/*     static constexpr auto Fracs = []()</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        std::array&lt;i64, 21&gt; fracs(&#123;1&#125;);</span></span><br><span class=\"line\"><span class=\"comment\">        for (i64 i = 1; i &lt;= 20; ++i)</span></span><br><span class=\"line\"><span class=\"comment\">        &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            fracs[i] = fracs[i - 1] * i;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        return fracs;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;(); */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">i64 <span class=\"title\">interchangeableRectangles</span><span class=\"params\">(std::vector&lt;std::vector&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;rectangles)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找比例相等个数，求组合数 nC2</span></span><br><span class=\"line\">        Vecd fracs;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;rect : rectangles)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fracs.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">static_cast</span>&lt;f64&gt;(rect[<span class=\"number\">0</span>]) / <span class=\"keyword\">static_cast</span>&lt;f64&gt;(rect[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HashMap&lt;f64, i32&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;f : fracs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(f) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[f] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[f] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i64 ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;kv : mp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i64 cnt = kv.second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans += cnt * (cnt - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  注：此处用 <code>double</code> 类型不涉及加减运算，只涉及判等，所以 <code>double</code> 作为 <code>key</code> 不会导致精度问题。</p>\n</blockquote>\n<ul>\n<li>  WA 的原因： 把 $C(n, 2) = n(n - 1) / 2$ 写成了 $n!(n-1)!/2$</li>\n</ul>\n<h2 id=\"L3-5869-两个回文子序列长度的最大乘积\"><a href=\"#L3-5869-两个回文子序列长度的最大乘积\" class=\"headerlink\" title=\"L3 5869. 两个回文子序列长度的最大乘积\"></a>L3 5869. 两个回文子序列长度的最大乘积</h2><ul>\n<li>  <strong>通过的用户数</strong>971</li>\n<li>  <strong>尝试过的用户数</strong>1189</li>\n<li>  <strong>用户总通过次数</strong>1017</li>\n<li>  <strong>用户总提交次数</strong>2093</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个字符串 <code>s</code> ，请你找到 <code>s</code> 中两个 <strong>不相交回文子序列</strong> ，使得它们长度的 <strong>乘积最大</strong> 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 <strong>不相交</strong> 的。</p>\n<p>请你返回两个回文子序列长度可以达到的 <strong>最大乘积</strong> 。</p>\n<p><strong>子序列</strong> 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 <strong>回文字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png\" alt=\"example-1\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;leetcodecom&quot;</span><br><span class=\"line\">输出：9</span><br><span class=\"line\">解释：最优方案是选择 &quot;ete&quot; 作为第一个子序列，&quot;cdc&quot; 作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 3 * 3 = 9 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;bb&quot;</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：最优方案为选择 &quot;b&quot; （第一个字符）作为第一个子序列，&quot;b&quot; （第二个字符）作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 1 * 1 = 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;accbcaxxcxx&quot;</span><br><span class=\"line\">输出：25</span><br><span class=\"line\">解释：最优方案为选择 &quot;accca&quot; 作为第一个子序列，&quot;xxcxx&quot; 作为第二个子序列。</span><br><span class=\"line\">它们的乘积为 5 * 5 = 25 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= s.length &lt;= 12</code></li>\n<li>  <code>s</code> 只含有小写英文字母。</li>\n</ul>\n<p><strong>我提交的代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">i32 <span class=\"title\">countOnes</span><span class=\"params\">(i32 x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">1</span>) &amp; <span class=\"number\">0x55555555</span>) + (x &amp; <span class=\"number\">0x55555555</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">2</span>) &amp; <span class=\"number\">0x33333333</span>) + (x &amp; <span class=\"number\">0x33333333</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0x0f0f0f0f</span>) + (x &amp; <span class=\"number\">0x0f0f0f0f</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0x00ff00ff</span>) + (x &amp; <span class=\"number\">0x00ff00ff</span>);</span><br><span class=\"line\">        x = ((x &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0x0000ffff</span>) + (x &amp; <span class=\"number\">0x0000ffff</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(str s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;s](i32 status) -&gt; <span class=\"keyword\">bool</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Veci <span class=\"built_in\">pos1</span>(&#123;&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i32 i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">13</span>; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (status &amp; (<span class=\"number\">1</span> &lt;&lt; i))</span><br><span class=\"line\">                    pos1.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos1.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i32 i = <span class=\"number\">0</span>, j = pos1.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[pos1[i]] != s[pos1[j]])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                ++i, --j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 预处理所有回文子串</span></span><br><span class=\"line\">        i32 sts = <span class=\"number\">1</span> &lt;&lt; s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        Veci checked;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i32 st = <span class=\"number\">1</span>; st &lt; sts; ++st)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(st))</span><br><span class=\"line\">                checked.<span class=\"built_in\">push_back</span>(st);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有回文字串求结果</span></span><br><span class=\"line\">        i32 ans = -Inf;</span><br><span class=\"line\">        i32 clen = checked.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i32 i = <span class=\"number\">0</span>; i &lt; clen; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i32 sti = checked[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i32 j = i + <span class=\"number\">1</span>; j &lt; clen; ++j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i32 stj = checked[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sti &amp; stj) == <span class=\"number\">0</span>) <span class=\"comment\">// 无重复</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ans = std::<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">countOnes</span>(sti) * <span class=\"built_in\">countOnes</span>(stj));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  注：本质是暴力遍历</p>\n</blockquote>\n<ul>\n<li>  TLE 的原因：一开始直接暴力二重循环，没预处理回文字符串，遍历了大量的垃圾状态</li>\n</ul>\n<p><strong>其他思路</strong></p>\n<p>dfs 两个子序列。对于位置 i ，两个子序列可以选择用或者不用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        string s1, s2;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(string &amp;s, string s1, string s2, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(s1) &amp;&amp; <span class=\"built_in\">check</span>(s2)) ans = <span class=\"built_in\">max</span>(ans, <span class=\"built_in\"><span class=\"keyword\">int</span></span>(s1.<span class=\"built_in\">size</span>() * s2.<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index == s.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1 + s[index], s2, index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列s1使用该字符</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2 + s[index], index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列s2使用该字符</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(s, s1, s2, index + <span class=\"number\">1</span>);<span class=\"comment\">//子序列都不使用该字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(string &amp;s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[l++] != s[r--]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：ytmartian</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/dfsliang-ge-zi-xu-lie-by-ytmartian-svyn/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"T4-5870-每棵子树内缺失的最小基因值\"><a href=\"#T4-5870-每棵子树内缺失的最小基因值\" class=\"headerlink\" title=\"T4 5870. 每棵子树内缺失的最小基因值\"></a>T4 5870. 每棵子树内缺失的最小基因值</h2><ul>\n<li>  <strong>通过的用户数</strong>175</li>\n<li>  <strong>尝试过的用户数</strong>539</li>\n<li>  <strong>用户总通过次数</strong>213</li>\n<li>  <strong>用户总提交次数</strong>1154</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>有一棵根节点为 <code>0</code> 的 <strong>家族树</strong> ，总共包含 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是 <strong>根</strong> ，所以 <code>parents[0] == -1</code> 。</p>\n<p>总共有 <code>105</code> 个基因值，每个基因值都用 <strong>闭区间</strong> <code>[1, 105]</code> 中的一个整数表示。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是节点 <code>i</code> 的基因值，且基因值 <strong>互不相同</strong> 。</p>\n<p>请你返回一个数组 <code>ans</code> ，长度为 <code>n</code> ，其中 <code>ans[i]</code> 是以节点 <code>i</code> 为根的子树内 <strong>缺失</strong> 的 <strong>最小</strong> 基因值。</p>\n<p>节点 <code>x</code> 为根的 <strong>子树</strong> 包含节点 <code>x</code> 和它所有的 <strong>后代</strong> 节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/23/case-1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,0,0,2], nums = [1,2,3,4]</span><br><span class=\"line\">输出：[5,1,1,1]</span><br><span class=\"line\">解释：每个子树答案计算结果如下：</span><br><span class=\"line\">- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。</span><br><span class=\"line\">- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/23/case-2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]</span><br><span class=\"line\">输出：[7,1,1,4,2,1]</span><br><span class=\"line\">解释：每个子树答案计算结果如下：</span><br><span class=\"line\">- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。</span><br><span class=\"line\">- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。</span><br><span class=\"line\">- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。</span><br><span class=\"line\">- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。</span><br><span class=\"line\">- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。</span><br><span class=\"line\">- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]</span><br><span class=\"line\">输出：[1,1,1,1,1,1,1]</span><br><span class=\"line\">解释：所有子树都缺失基因值 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == parents.length == nums.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  对于 <code>i != 0</code> ，满足 <code>0 &lt;= parents[i] &lt;= n - 1</code></li>\n<li>  <code>parents[0] == -1</code></li>\n<li>  <code>parents</code> 表示一棵合法的树。</li>\n<li>  <code>1 &lt;= nums[i] &lt;= 105</code></li>\n<li>  <code>nums[i]</code> 互不相同。</li>\n</ul>\n<p><strong>解法笔记</strong></p>\n<p><strong>解法一：启发式合并</strong><br>遍历整棵树，统计每棵子树包含的基因值集合以及缺失的最小基因值，记作 $\\textit{mex}$。合并基因值集合时，总是从小的往大的合并（类似并查集的按秩合并），同时更新当前子树的 $\\textit{mex}$ 的最大值。合并完成后再不断自增子树的 $\\textit{mex}$ 直至其不在基因值集合中。</p>\n<p>这一方法同时也适用于有相同基因值的情况。</p>\n<p>时间复杂度：$O(n\\log n)$。证明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(parents []<span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(parents)</span><br><span class=\"line\">\tg := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt; n; w++ &#123;</span><br><span class=\"line\">\t\tv := parents[w]</span><br><span class=\"line\">\t\tg[v] = <span class=\"built_in\">append</span>(g[v], w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmex := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">int</span>]<span class=\"title\">bool</span></span></span><br><span class=\"line\">\tf = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span> <span class=\"title\">map</span>[<span class=\"title\">int</span>]<span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\tset := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>&#123;&#125;</span><br><span class=\"line\">\t\tmex[v] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> g[v] &#123;</span><br><span class=\"line\">\t\t\ts := f(w)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 保证总是从小集合合并到大集合上</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &gt; <span class=\"built_in\">len</span>(set) &#123;</span><br><span class=\"line\">\t\t\t\tset, s = s, set</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\t\t\tset[x] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> mex[w] &gt; mex[v] &#123;</span><br><span class=\"line\">\t\t\t\tmex[v] = mex[w]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tset[nums[v]] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> set[mex[v]] &#123;</span><br><span class=\"line\">\t\t\tmex[v]++ <span class=\"comment\">// 不断自增 mex 直至其不在基因值集合中</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> set</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：endlesscheng</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<p><strong>解法二：利用无重复基因值的性质</strong><br>由于没有重复基因值，若存在节点 $x$，其基因值等于 $1$，则从 $x$ 到根的这一条链上的所有节点的 $\\textit{mex}$ 均超过 $1$，而其余节点的 $\\textit{mex}$ 值均为 $1$。我们顺着 $x$ 往根上走，同时收集当前子树的基因值到集合中，然后更新当前子树的 $\\textit{mex}$ 值。</p>\n<p>时间复杂度：$O(n)$。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(parents []<span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(parents)</span><br><span class=\"line\">\tg := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt; n; w++ &#123;</span><br><span class=\"line\">\t\tv := parents[w]</span><br><span class=\"line\">\t\tg[v] = <span class=\"built_in\">append</span>(g[v], w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmex := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> mex &#123;</span><br><span class=\"line\">\t\tmex[i] = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tset := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>&#123;&#125;</span><br><span class=\"line\">\tvis := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span></span><br><span class=\"line\">\tf = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tset[nums[v]] = <span class=\"literal\">true</span> <span class=\"comment\">// 收集基因值到 set 中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> g[v] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !vis[w] &#123;</span><br><span class=\"line\">\t\t\t\tf(w)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 找基因值等于 1 的节点 x</span></span><br><span class=\"line\">\tx := <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tx = i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// x 顺着父节点往上走</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> cur := <span class=\"number\">2</span>; x &gt;= <span class=\"number\">0</span>; x = parents[x] &#123;</span><br><span class=\"line\">\t\tf(x)</span><br><span class=\"line\">\t\tvis[x] = <span class=\"literal\">true</span> <span class=\"comment\">// 这是保证时间复杂度的关键：之后遍历父节点子树时，就无需再次遍历 x 子树了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> set[cur] &#123;</span><br><span class=\"line\">\t\t\tcur++ <span class=\"comment\">// 不断自增直至不在基因值集合中</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmex[x] = cur</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：endlesscheng</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<p><strong>不一样的思路：主席树+dfs序（突破值互不相同的限制）</strong></p>\n<ul>\n<li>  看到很多题解是从基因值互不相同的条件入手写的，后来突然发现我的解法不需要考虑这个</li>\n<li>  可能我的思路比较繁琐，时间复杂度有没有O(n)的优秀，固在此也只是想提供一个与众不同的思路罢了（勿喷）</li>\n<li>  前置知识：主席树，dfs序</li>\n<li>  注意到，这题的本质就是求mex，但不同的是，其不是真正的mex，最小的数是1，mex最小的数是0，但不影响做这题。</li>\n<li>  将问题转化一下，求一个区间的mex，可以线段树、主席树，这里使用主席树做方便</li>\n<li>主席树找mex的思路<ul>\n<li>  利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了</li>\n<li>  最终查询 <code>[L, R]</code> 区间的mex时，则是在版本 <code>R</code> 的权值线段树中找下标小于 <code>L</code> 的最小的数即可</li>\n</ul>\n</li>\n<li>  再来就是怎么将区间转化成树上查询，显然可以用到dfs序了</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pii</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">pii p[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> head[N], cnt, tim;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"built_in\">fill_n</span>(head, n + <span class=\"number\">5</span>, <span class=\"number\">-1</span>); cnt = <span class=\"number\">-1</span>; tim = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edges</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to, next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        to = t, next = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;edge[N &lt;&lt; <span class=\"number\">1</span>]; <span class=\"comment\">//无向图则需要乘2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">    edge[++cnt].<span class=\"built_in\">add</span>(v, head[u]);</span><br><span class=\"line\">    head[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[N], ram, root[N], vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; num)</span> </span>&#123;</span><br><span class=\"line\">    p[u].x = ++tim;</span><br><span class=\"line\">    a[tim] = num[u]; <span class=\"comment\">// 重置数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].next) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(edge[i].to, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p[u].y = tim;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nodes</span> &#123;</span><span class=\"keyword\">int</span> l, r, minv; &#125; hjt[N * <span class=\"number\">25</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> pre, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = ++ram;</span><br><span class=\"line\">    hjt[now] = hjt[pre];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">        hjt[now].minv = pos;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (val &lt;= mid) hjt[now].l = <span class=\"built_in\">modify</span>(hjt[now].l, l, mid, val, pos);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> hjt[now].r = <span class=\"built_in\">modify</span>(hjt[now].r, mid + <span class=\"number\">1</span>, r, val, pos);</span><br><span class=\"line\">    hjt[now].minv = <span class=\"built_in\">min</span>(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> tr, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hjt[hjt[tr].l].minv &lt; ql) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(hjt[tr].l, l, mid, ql);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(hjt[tr].r, mid + <span class=\"number\">1</span>, r, ql);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">smallestMissingValueSubtree</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; pa, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = pa.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">init</span>(n);</span><br><span class=\"line\">        ram = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pa[i] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">add</span>(pa[i], i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, nums); <span class=\"comment\">// 预处理dfs序</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = *<span class=\"built_in\">max_element</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()) + <span class=\"number\">1</span>; <span class=\"comment\">// 找到最大值，记得+1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            root[i] = <span class=\"built_in\">modify</span>(root[i - <span class=\"number\">1</span>], <span class=\"number\">1</span>, len, a[i], i); <span class=\"comment\">// 主席树插入，注意此时用到的数组是a，不是nums了</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; p[i].x &lt;&lt; &#x27; &#x27; &lt;&lt; p[i].y &lt;&lt; endl;</span></span><br><span class=\"line\">            ans[i] = <span class=\"built_in\">query</span>(root[p[i].y], <span class=\"number\">1</span>, len, p[i].x);<span class=\"comment\">// 查询结点i的子树，意味在查询dfs序中区间[p[i].x, p[i].y]的答案</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：haoboy</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree/solution/zhu-xi-shu-dfsxu-tu-po-zhi-hu-bu-xiang-t-7nh8/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LeetCode 虚拟周赛 185","date":"2021-11-17T15:18:03.000Z","_content":"\n-----\n\n# LeetCode 虚拟周赛 185\n\n## T1 1417. 重新格式化字符串\n\n-   **通过的用户数**3297\n-   **尝试过的用户数**3450\n-   **用户总通过次数**3441\n-   **用户总提交次数**6732\n-   **题目难度** **Easy**\n\n给你一个混合了数字和字母的字符串 `s`，其中的字母均为小写英文字母。\n\n请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。\n\n请你返回 **重新格式化后** 的字符串；如果无法按要求重新格式化，则返回一个 **空字符串** 。\n\n**示例 1：**\n\n```\n输入：s = \"a0b1c2\"\n输出：\"0a1b2c\"\n解释：\"0a1b2c\" 中任意两个相邻字符的类型都不同。 \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" 也是满足题目要求的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"leetcode\"\n输出：\"\"\n解释：\"leetcode\" 中只有字母，所以无法满足重新格式化的条件。\n```\n\n**示例 3：**\n\n```\n输入：s = \"1229857369\"\n输出：\"\"\n解释：\"1229857369\" 中只有数字，所以无法满足重新格式化的条件。\n```\n\n**示例 4：**\n\n```\n输入：s = \"covid2019\"\n输出：\"c2o0v1i9d\"\n```\n\n**示例 5：**\n\n```\n输入：s = \"ab123\"\n输出：\"1a2b3\"\n```\n\n**提示：**\n\n-   `1 <= s.length <= 500`\n-   `s` 仅由小写英文字母和/或数字组成。\n\n**提交：**\n\n```Rust\nimpl Solution {\n    pub fn reformat(s: String) -> String {\n        let ch = s.bytes().filter(|ch| ch.is_ascii_alphabetic()).collect::<Vec<_>>();\n        let dig = s.bytes().filter(|ch| ch.is_ascii_digit()).collect::<Vec<_>>();\n        if (ch.len() as i32 - dig.len() as i32).abs() > 1 {\n            String::from(\"\")\n        } else {\n            let mut s = (0..ch.len().min(dig.len())).fold(Vec::new(), |mut s, i| {\n                s.push(ch[i]);\n                s.push(dig[i]);\n                s\n            });\n            if ch.len() > dig.len() {\n                s.push(ch[ch.len() - 1]);\n            } else if ch.len() < dig.len() {\n                s.insert(0, dig[dig.len() - 1]);\n            }\n            String::from_utf8(s).unwrap()\n        }\n    }\n}\n```\n\n## T2 1418. 点菜展示表\n\n-   **通过的用户数**1861\n-   **尝试过的用户数**2042\n-   **用户总通过次数**1885\n-   **用户总提交次数**3567\n-   **题目难度** **Medium**\n\n给你一个数组 `orders`，表示客户在餐厅中完成的订单，确切地说， `orders[i]=[customerNamei,tableNumberi,foodItemi]` ，其中 `customerNamei` 是客户的姓名，`tableNumberi` 是客户所在餐桌的桌号，而 `foodItemi` 是客户点的餐品名称。\n\n请你返回该餐厅的 **点菜展示表** *。*在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。\n\n注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。\n\n**示例 1：**\n\n```\n输入：orders = [[\"David\",\"3\",\"Ceviche\"],[\"Corina\",\"10\",\"Beef Burrito\"],[\"David\",\"3\",\"Fried Chicken\"],[\"Carla\",\"5\",\"Water\"],[\"Carla\",\"5\",\"Ceviche\"],[\"Rous\",\"3\",\"Ceviche\"]]\n输出：[[\"Table\",\"Beef Burrito\",\"Ceviche\",\"Fried Chicken\",\"Water\"],[\"3\",\"0\",\"2\",\"1\",\"0\"],[\"5\",\"0\",\"1\",\"0\",\"1\"],[\"10\",\"1\",\"0\",\"0\",\"0\"]] \n解释：\n点菜展示表如下所示：\nTable,Beef Burrito,Ceviche,Fried Chicken,Water\n3    ,0           ,2      ,1            ,0\n5    ,0           ,1      ,0            ,1\n10   ,1           ,0      ,0            ,0\n对于餐桌 3：David 点了 \"Ceviche\" 和 \"Fried Chicken\"，而 Rous 点了 \"Ceviche\"\n而餐桌 5：Carla 点了 \"Water\" 和 \"Ceviche\"\n餐桌 10：Corina 点了 \"Beef Burrito\" \n```\n\n**示例 2：**\n\n```\n输入：orders = [[\"James\",\"12\",\"Fried Chicken\"],[\"Ratesh\",\"12\",\"Fried Chicken\"],[\"Amadeus\",\"12\",\"Fried Chicken\"],[\"Adam\",\"1\",\"Canadian Waffles\"],[\"Brianna\",\"1\",\"Canadian Waffles\"]]\n输出：[[\"Table\",\"Canadian Waffles\",\"Fried Chicken\"],[\"1\",\"2\",\"0\"],[\"12\",\"0\",\"3\"]] \n解释：\n对于餐桌 1：Adam 和 Brianna 都点了 \"Canadian Waffles\"\n而餐桌 12：James, Ratesh 和 Amadeus 都点了 \"Fried Chicken\"\n```\n\n**示例 3：**\n\n```\n输入：orders = [[\"Laura\",\"2\",\"Bean Burrito\"],[\"Jhon\",\"2\",\"Beef Burrito\"],[\"Melissa\",\"2\",\"Soda\"]]\n输出：[[\"Table\",\"Bean Burrito\",\"Beef Burrito\",\"Soda\"],[\"2\",\"1\",\"1\",\"1\"]] \n```\n\n**提示：**\n\n-   `1 <= orders.length <= 5 * 10^4`\n-   `orders[i].length == 3`\n-   `1 <= customerNamei.length, foodItemi.length <= 20`\n-   `customerNamei` 和 `foodItemi` 由大小写英文字母及空格字符 `' '` 组成。\n-   `tableNumberi` 是 `1` 到 `500` 范围内的整数。\n\n**题解：**\n\n>   不难，就是恶心，写了半个小时困得扛不住就一键放弃了\n\n```C#\npublic List<List<String>> displayTable(List<List<String>> orders) {\n        //构造表头\n        List<String> header = orders.stream()\n                .map(order -> order.get(2))\n                .distinct()\n                .sorted()\n                .collect(Collectors.toCollection(() -> Stream.of(\"Table\").collect(Collectors.toList())));\n\n        //填写数据\n        return orders.stream()\n                .collect(Collectors.groupingBy(\n                        order -> Integer.valueOf(order.get(1)),\n                        (Supplier<Map<Integer, Map<String, Integer>>>) TreeMap::new,\n                        Collectors.groupingBy(order -> order.get(2), Collectors.summingInt(e -> 1)))\n                ).entrySet()\n                .stream()\n                .peek(entry -> entry.getValue().put(\"Table\", entry.getKey()))\n                .map(entry -> header.stream()\n                        .map(column -> entry.getValue().getOrDefault(column, 0).toString())\n                        .collect(Collectors.toList()))\n                .collect(Collectors.toCollection(() -> Stream.of(header).collect(Collectors.toList())));\n    }\n```\n\n>   干脆出道手写 SQL 数据库得了\n\n## L3 1419. 数青蛙\n\n-   **通过的用户数**1087\n-   **尝试过的用户数**1882\n-   **用户总通过次数**1105\n-   **用户总提交次数**4362\n-   **题目难度** **Medium**\n\n给你一个字符串 `croakOfFrogs`，它表示不同青蛙发出的蛙鸣声（字符串 \"croak\" ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 `croakOfFrogs` 中会混合多个 “croak” *。*请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。\n\n**注意：**要想发出蛙鸣 \"croak\"，青蛙必须 **依序** 输出 `‘c’, ’r’, ’o’, ’a’, ’k’` 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。\n\n如果字符串 `croakOfFrogs` 不是由若干有效的 \"croak\" 字符混合而成，请返回 `-1` 。\n\n**示例 1：**\n\n```\n输入：croakOfFrogs = \"croakcroak\"\n输出：1 \n解释：一只青蛙 “呱呱” 两次\n```\n\n**示例 2：**\n\n```\n输入：croakOfFrogs = \"crcoakroak\"\n输出：2 \n解释：最少需要两只青蛙，“呱呱” 声用黑体标注\n第一只青蛙 \"crcoakroak\"\n第二只青蛙 \"crcoakroak\"\n```\n\n**示例 3：**\n\n```\n输入：croakOfFrogs = \"croakcrook\"\n输出：-1\n解释：给出的字符串不是 \"croak\" 的有效组合。\n```\n\n**示例 4：**\n\n```\n输入：croakOfFrogs = \"croakcroa\"\n输出：-1\n```\n\n**提示：**\n\n-   `1 <= croakOfFrogs.length <= 10^5`\n-   字符串中的字符只有 `'c'`, `'r'`, `'o'`, `'a'` 或者 `'k'`\n\n**题解：**\n\n>   状态机。记录在转移序列中的青蛙个数的最大值即可。如果状态转移任何一步出现问题，都应该返回 -1\n\n```rust\nimpl Solution {\n    pub fn min_number_of_frogs(croak_of_frogs: String) -> i32 {\n        let mut stat = [0; 4];\n        let mut cnt = 0;\n        for ch in croak_of_frogs.bytes() {\n            match ch {\n                b'c' => {\n                    stat[0] += 1;\n                }\n                b'r' => {\n                    stat[0] -= 1;\n                    stat[1] += 1;\n                }\n                b'o' => {\n                    stat[1] -= 1;\n                    stat[2] += 1;\n                }\n                b'a' => {\n                    stat[2] -= 1;\n                    stat[3] += 1;\n                }\n                b'k' => {\n                    stat[3] -= 1;\n                }\n                _ => unreachable!()\n            }\n            if stat.iter().filter(|&&i| i < 0).count() != 0 {\n                return -1;\n            }\n            cnt = cnt.max(stat.iter().sum::<i32>());\n        }\n        if stat.iter().filter(|&&i| i != 0).count() != 0 {\n            return -1;\n        }\n        cnt\n    }\n}\n```\n\n## T4 1420. 生成数组\n\n-   **通过的用户数**181\n-   **尝试过的用户数**292\n-   **用户总通过次数**200\n-   **用户总提交次数**417\n-   **题目难度** **Hard**\n\n给你三个整数 `n`、`m` 和 `k` 。下图描述的算法用于找出正整数数组中最大的元素。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png)\n\n请你生成一个具有下述属性的数组 `arr` ：\n\n-   `arr` 中有 `n` 个整数。\n-   `1 <= arr[i] <= m` 其中 `(0 <= i < n)` 。\n-   将上面提到的算法应用于 `arr` ，`search_cost` 的值等于 `k` 。\n\n返回上述条件下生成数组 `arr` 的 **方法数** ，由于答案可能会很大，所以 **必须** 对 `10^9 + 7` 取余。\n\n**示例 1：**\n\n```\n输入：n = 2, m = 3, k = 1\n输出：6\n解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n```\n\n**示例 2：**\n\n```\n输入：n = 5, m = 2, k = 3\n输出：0\n解释：没有数组可以满足上述条件\n```\n\n**示例 3：**\n\n```\n输入：n = 9, m = 1, k = 1\n输出：1\n解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]\n```\n\n**示例 4：**\n\n```\n输入：n = 50, m = 100, k = 25\n输出：34549172\n解释：不要忘了对 1000000007 取余\n```\n\n**示例 5：**\n\n```\n输入：n = 37, m = 17, k = 7\n输出：418930126\n```\n\n**提示：**\n\n-   `1 <= n <= 50`\n-   `1 <= m <= 100`\n-   `0 <= k <= n`\n\n**题解：**\n\n>   [动态规划]([生成数组 - 生成数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution/sheng-cheng-shu-zu-by-leetcode-solution-yswf/))\n\n","source":"_posts/virtual-contest-185.md","raw":"---\ntitle: LeetCode 虚拟周赛 185\ndate: 2021-11-17 23:18:03\ntags: LeetCode 周赛总结\n---\n\n-----\n\n# LeetCode 虚拟周赛 185\n\n## T1 1417. 重新格式化字符串\n\n-   **通过的用户数**3297\n-   **尝试过的用户数**3450\n-   **用户总通过次数**3441\n-   **用户总提交次数**6732\n-   **题目难度** **Easy**\n\n给你一个混合了数字和字母的字符串 `s`，其中的字母均为小写英文字母。\n\n请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。\n\n请你返回 **重新格式化后** 的字符串；如果无法按要求重新格式化，则返回一个 **空字符串** 。\n\n**示例 1：**\n\n```\n输入：s = \"a0b1c2\"\n输出：\"0a1b2c\"\n解释：\"0a1b2c\" 中任意两个相邻字符的类型都不同。 \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" 也是满足题目要求的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"leetcode\"\n输出：\"\"\n解释：\"leetcode\" 中只有字母，所以无法满足重新格式化的条件。\n```\n\n**示例 3：**\n\n```\n输入：s = \"1229857369\"\n输出：\"\"\n解释：\"1229857369\" 中只有数字，所以无法满足重新格式化的条件。\n```\n\n**示例 4：**\n\n```\n输入：s = \"covid2019\"\n输出：\"c2o0v1i9d\"\n```\n\n**示例 5：**\n\n```\n输入：s = \"ab123\"\n输出：\"1a2b3\"\n```\n\n**提示：**\n\n-   `1 <= s.length <= 500`\n-   `s` 仅由小写英文字母和/或数字组成。\n\n**提交：**\n\n```Rust\nimpl Solution {\n    pub fn reformat(s: String) -> String {\n        let ch = s.bytes().filter(|ch| ch.is_ascii_alphabetic()).collect::<Vec<_>>();\n        let dig = s.bytes().filter(|ch| ch.is_ascii_digit()).collect::<Vec<_>>();\n        if (ch.len() as i32 - dig.len() as i32).abs() > 1 {\n            String::from(\"\")\n        } else {\n            let mut s = (0..ch.len().min(dig.len())).fold(Vec::new(), |mut s, i| {\n                s.push(ch[i]);\n                s.push(dig[i]);\n                s\n            });\n            if ch.len() > dig.len() {\n                s.push(ch[ch.len() - 1]);\n            } else if ch.len() < dig.len() {\n                s.insert(0, dig[dig.len() - 1]);\n            }\n            String::from_utf8(s).unwrap()\n        }\n    }\n}\n```\n\n## T2 1418. 点菜展示表\n\n-   **通过的用户数**1861\n-   **尝试过的用户数**2042\n-   **用户总通过次数**1885\n-   **用户总提交次数**3567\n-   **题目难度** **Medium**\n\n给你一个数组 `orders`，表示客户在餐厅中完成的订单，确切地说， `orders[i]=[customerNamei,tableNumberi,foodItemi]` ，其中 `customerNamei` 是客户的姓名，`tableNumberi` 是客户所在餐桌的桌号，而 `foodItemi` 是客户点的餐品名称。\n\n请你返回该餐厅的 **点菜展示表** *。*在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。\n\n注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。\n\n**示例 1：**\n\n```\n输入：orders = [[\"David\",\"3\",\"Ceviche\"],[\"Corina\",\"10\",\"Beef Burrito\"],[\"David\",\"3\",\"Fried Chicken\"],[\"Carla\",\"5\",\"Water\"],[\"Carla\",\"5\",\"Ceviche\"],[\"Rous\",\"3\",\"Ceviche\"]]\n输出：[[\"Table\",\"Beef Burrito\",\"Ceviche\",\"Fried Chicken\",\"Water\"],[\"3\",\"0\",\"2\",\"1\",\"0\"],[\"5\",\"0\",\"1\",\"0\",\"1\"],[\"10\",\"1\",\"0\",\"0\",\"0\"]] \n解释：\n点菜展示表如下所示：\nTable,Beef Burrito,Ceviche,Fried Chicken,Water\n3    ,0           ,2      ,1            ,0\n5    ,0           ,1      ,0            ,1\n10   ,1           ,0      ,0            ,0\n对于餐桌 3：David 点了 \"Ceviche\" 和 \"Fried Chicken\"，而 Rous 点了 \"Ceviche\"\n而餐桌 5：Carla 点了 \"Water\" 和 \"Ceviche\"\n餐桌 10：Corina 点了 \"Beef Burrito\" \n```\n\n**示例 2：**\n\n```\n输入：orders = [[\"James\",\"12\",\"Fried Chicken\"],[\"Ratesh\",\"12\",\"Fried Chicken\"],[\"Amadeus\",\"12\",\"Fried Chicken\"],[\"Adam\",\"1\",\"Canadian Waffles\"],[\"Brianna\",\"1\",\"Canadian Waffles\"]]\n输出：[[\"Table\",\"Canadian Waffles\",\"Fried Chicken\"],[\"1\",\"2\",\"0\"],[\"12\",\"0\",\"3\"]] \n解释：\n对于餐桌 1：Adam 和 Brianna 都点了 \"Canadian Waffles\"\n而餐桌 12：James, Ratesh 和 Amadeus 都点了 \"Fried Chicken\"\n```\n\n**示例 3：**\n\n```\n输入：orders = [[\"Laura\",\"2\",\"Bean Burrito\"],[\"Jhon\",\"2\",\"Beef Burrito\"],[\"Melissa\",\"2\",\"Soda\"]]\n输出：[[\"Table\",\"Bean Burrito\",\"Beef Burrito\",\"Soda\"],[\"2\",\"1\",\"1\",\"1\"]] \n```\n\n**提示：**\n\n-   `1 <= orders.length <= 5 * 10^4`\n-   `orders[i].length == 3`\n-   `1 <= customerNamei.length, foodItemi.length <= 20`\n-   `customerNamei` 和 `foodItemi` 由大小写英文字母及空格字符 `' '` 组成。\n-   `tableNumberi` 是 `1` 到 `500` 范围内的整数。\n\n**题解：**\n\n>   不难，就是恶心，写了半个小时困得扛不住就一键放弃了\n\n```C#\npublic List<List<String>> displayTable(List<List<String>> orders) {\n        //构造表头\n        List<String> header = orders.stream()\n                .map(order -> order.get(2))\n                .distinct()\n                .sorted()\n                .collect(Collectors.toCollection(() -> Stream.of(\"Table\").collect(Collectors.toList())));\n\n        //填写数据\n        return orders.stream()\n                .collect(Collectors.groupingBy(\n                        order -> Integer.valueOf(order.get(1)),\n                        (Supplier<Map<Integer, Map<String, Integer>>>) TreeMap::new,\n                        Collectors.groupingBy(order -> order.get(2), Collectors.summingInt(e -> 1)))\n                ).entrySet()\n                .stream()\n                .peek(entry -> entry.getValue().put(\"Table\", entry.getKey()))\n                .map(entry -> header.stream()\n                        .map(column -> entry.getValue().getOrDefault(column, 0).toString())\n                        .collect(Collectors.toList()))\n                .collect(Collectors.toCollection(() -> Stream.of(header).collect(Collectors.toList())));\n    }\n```\n\n>   干脆出道手写 SQL 数据库得了\n\n## L3 1419. 数青蛙\n\n-   **通过的用户数**1087\n-   **尝试过的用户数**1882\n-   **用户总通过次数**1105\n-   **用户总提交次数**4362\n-   **题目难度** **Medium**\n\n给你一个字符串 `croakOfFrogs`，它表示不同青蛙发出的蛙鸣声（字符串 \"croak\" ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 `croakOfFrogs` 中会混合多个 “croak” *。*请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。\n\n**注意：**要想发出蛙鸣 \"croak\"，青蛙必须 **依序** 输出 `‘c’, ’r’, ’o’, ’a’, ’k’` 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。\n\n如果字符串 `croakOfFrogs` 不是由若干有效的 \"croak\" 字符混合而成，请返回 `-1` 。\n\n**示例 1：**\n\n```\n输入：croakOfFrogs = \"croakcroak\"\n输出：1 \n解释：一只青蛙 “呱呱” 两次\n```\n\n**示例 2：**\n\n```\n输入：croakOfFrogs = \"crcoakroak\"\n输出：2 \n解释：最少需要两只青蛙，“呱呱” 声用黑体标注\n第一只青蛙 \"crcoakroak\"\n第二只青蛙 \"crcoakroak\"\n```\n\n**示例 3：**\n\n```\n输入：croakOfFrogs = \"croakcrook\"\n输出：-1\n解释：给出的字符串不是 \"croak\" 的有效组合。\n```\n\n**示例 4：**\n\n```\n输入：croakOfFrogs = \"croakcroa\"\n输出：-1\n```\n\n**提示：**\n\n-   `1 <= croakOfFrogs.length <= 10^5`\n-   字符串中的字符只有 `'c'`, `'r'`, `'o'`, `'a'` 或者 `'k'`\n\n**题解：**\n\n>   状态机。记录在转移序列中的青蛙个数的最大值即可。如果状态转移任何一步出现问题，都应该返回 -1\n\n```rust\nimpl Solution {\n    pub fn min_number_of_frogs(croak_of_frogs: String) -> i32 {\n        let mut stat = [0; 4];\n        let mut cnt = 0;\n        for ch in croak_of_frogs.bytes() {\n            match ch {\n                b'c' => {\n                    stat[0] += 1;\n                }\n                b'r' => {\n                    stat[0] -= 1;\n                    stat[1] += 1;\n                }\n                b'o' => {\n                    stat[1] -= 1;\n                    stat[2] += 1;\n                }\n                b'a' => {\n                    stat[2] -= 1;\n                    stat[3] += 1;\n                }\n                b'k' => {\n                    stat[3] -= 1;\n                }\n                _ => unreachable!()\n            }\n            if stat.iter().filter(|&&i| i < 0).count() != 0 {\n                return -1;\n            }\n            cnt = cnt.max(stat.iter().sum::<i32>());\n        }\n        if stat.iter().filter(|&&i| i != 0).count() != 0 {\n            return -1;\n        }\n        cnt\n    }\n}\n```\n\n## T4 1420. 生成数组\n\n-   **通过的用户数**181\n-   **尝试过的用户数**292\n-   **用户总通过次数**200\n-   **用户总提交次数**417\n-   **题目难度** **Hard**\n\n给你三个整数 `n`、`m` 和 `k` 。下图描述的算法用于找出正整数数组中最大的元素。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png)\n\n请你生成一个具有下述属性的数组 `arr` ：\n\n-   `arr` 中有 `n` 个整数。\n-   `1 <= arr[i] <= m` 其中 `(0 <= i < n)` 。\n-   将上面提到的算法应用于 `arr` ，`search_cost` 的值等于 `k` 。\n\n返回上述条件下生成数组 `arr` 的 **方法数** ，由于答案可能会很大，所以 **必须** 对 `10^9 + 7` 取余。\n\n**示例 1：**\n\n```\n输入：n = 2, m = 3, k = 1\n输出：6\n解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n```\n\n**示例 2：**\n\n```\n输入：n = 5, m = 2, k = 3\n输出：0\n解释：没有数组可以满足上述条件\n```\n\n**示例 3：**\n\n```\n输入：n = 9, m = 1, k = 1\n输出：1\n解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]\n```\n\n**示例 4：**\n\n```\n输入：n = 50, m = 100, k = 25\n输出：34549172\n解释：不要忘了对 1000000007 取余\n```\n\n**示例 5：**\n\n```\n输入：n = 37, m = 17, k = 7\n输出：418930126\n```\n\n**提示：**\n\n-   `1 <= n <= 50`\n-   `1 <= m <= 100`\n-   `0 <= k <= n`\n\n**题解：**\n\n>   [动态规划]([生成数组 - 生成数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution/sheng-cheng-shu-zu-by-leetcode-solution-yswf/))\n\n","slug":"virtual-contest-185","published":1,"updated":"2021-11-17T15:51:40.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw3pcypf0000n8y53bkq1w30","content":"<hr>\n<h1 id=\"LeetCode-虚拟周赛-185\"><a href=\"#LeetCode-虚拟周赛-185\" class=\"headerlink\" title=\"LeetCode 虚拟周赛 185\"></a>LeetCode 虚拟周赛 185</h1><h2 id=\"T1-1417-重新格式化字符串\"><a href=\"#T1-1417-重新格式化字符串\" class=\"headerlink\" title=\"T1 1417. 重新格式化字符串\"></a>T1 1417. 重新格式化字符串</h2><ul>\n<li>  <strong>通过的用户数</strong>3297</li>\n<li>  <strong>尝试过的用户数</strong>3450</li>\n<li>  <strong>用户总通过次数</strong>3441</li>\n<li>  <strong>用户总提交次数</strong>6732</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>\n<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>\n<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a0b1c2&quot;</span><br><span class=\"line\">输出：&quot;0a1b2c&quot;</span><br><span class=\"line\">解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;leetcode&quot;</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;1229857369&quot;</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;covid2019&quot;</span><br><span class=\"line\">输出：&quot;c2o0v1i9d&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ab123&quot;</span><br><span class=\"line\">输出：&quot;1a2b3&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= s.length &lt;= 500</code></li>\n<li>  <code>s</code> 仅由小写英文字母和/或数字组成。</li>\n</ul>\n<p><strong>提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">reformat</span></span>(s: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ch = s.bytes().filter(|ch| ch.is_ascii_alphabetic()).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> dig = s.bytes().filter(|ch| ch.is_ascii_digit()).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch.len() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> - dig.len() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>).abs() &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> s = (<span class=\"number\">0</span>..ch.len().min(dig.len())).fold(<span class=\"built_in\">Vec</span>::new(), |<span class=\"keyword\">mut</span> s, i| &#123;</span><br><span class=\"line\">                s.push(ch[i]);</span><br><span class=\"line\">                s.push(dig[i]);</span><br><span class=\"line\">                s</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch.len() &gt; dig.len() &#123;</span><br><span class=\"line\">                s.push(ch[ch.len() - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ch.len() &lt; dig.len() &#123;</span><br><span class=\"line\">                s.insert(<span class=\"number\">0</span>, dig[dig.len() - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">String</span>::from_utf8(s).unwrap()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-1418-点菜展示表\"><a href=\"#T2-1418-点菜展示表\" class=\"headerlink\" title=\"T2 1418. 点菜展示表\"></a>T2 1418. 点菜展示表</h2><ul>\n<li>  <strong>通过的用户数</strong>1861</li>\n<li>  <strong>尝试过的用户数</strong>2042</li>\n<li>  <strong>用户总通过次数</strong>1885</li>\n<li>  <strong>用户总提交次数</strong>3567</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerNamei,tableNumberi,foodItemi]</code> ，其中 <code>customerNamei</code> 是客户的姓名，<code>tableNumberi</code> 是客户所在餐桌的桌号，而 <code>foodItemi</code> 是客户点的餐品名称。</p>\n<p>请你返回该餐厅的 <strong>点菜展示表</strong> <em>。</em>在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p>\n<p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]</span><br><span class=\"line\">输出：[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] </span><br><span class=\"line\">解释：</span><br><span class=\"line\">点菜展示表如下所示：</span><br><span class=\"line\">Table,Beef Burrito,Ceviche,Fried Chicken,Water</span><br><span class=\"line\">3    ,0           ,2      ,1            ,0</span><br><span class=\"line\">5    ,0           ,1      ,0            ,1</span><br><span class=\"line\">10   ,1           ,0      ,0            ,0</span><br><span class=\"line\">对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;</span><br><span class=\"line\">而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;</span><br><span class=\"line\">餐桌 10：Corina 点了 &quot;Beef Burrito&quot; </span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]</span><br><span class=\"line\">输出：[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] </span><br><span class=\"line\">解释：</span><br><span class=\"line\">对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;</span><br><span class=\"line\">而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]</span><br><span class=\"line\">输出：[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]] </span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= orders.length &lt;= 5 * 10^4</code></li>\n<li>  <code>orders[i].length == 3</code></li>\n<li>  <code>1 &lt;= customerNamei.length, foodItemi.length &lt;= 20</code></li>\n<li>  <code>customerNamei</code> 和 <code>foodItemi</code> 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li>\n<li>  <code>tableNumberi</code> 是 <code>1</code> 到 <code>500</code> 范围内的整数。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  不难，就是恶心，写了半个小时困得扛不住就一键放弃了</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;String&gt;&gt; displayTable(List&lt;List&lt;String&gt;&gt; orders) &#123;</span><br><span class=\"line\">        //构造表头</span><br><span class=\"line\">        List&lt;String&gt; header = orders.stream()</span><br><span class=\"line\">                .map(order -&gt; order.get(2))</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .sorted()</span><br><span class=\"line\">                .collect(Collectors.toCollection(() -&gt; Stream.of(&quot;Table&quot;).collect(Collectors.toList())));</span><br><span class=\"line\"></span><br><span class=\"line\">        //填写数据</span><br><span class=\"line\">        return orders.stream()</span><br><span class=\"line\">                .collect(Collectors.groupingBy(</span><br><span class=\"line\">                        order -&gt; Integer.valueOf(order.get(1)),</span><br><span class=\"line\">                        (Supplier&lt;Map&lt;Integer, Map&lt;String, Integer&gt;&gt;&gt;) TreeMap::new,</span><br><span class=\"line\">                        Collectors.groupingBy(order -&gt; order.get(2), Collectors.summingInt(e -&gt; 1)))</span><br><span class=\"line\">                ).entrySet()</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .peek(entry -&gt; entry.getValue().put(&quot;Table&quot;, entry.getKey()))</span><br><span class=\"line\">                .map(entry -&gt; header.stream()</span><br><span class=\"line\">                        .map(column -&gt; entry.getValue().getOrDefault(column, 0).toString())</span><br><span class=\"line\">                        .collect(Collectors.toList()))</span><br><span class=\"line\">                .collect(Collectors.toCollection(() -&gt; Stream.of(header).collect(Collectors.toList())));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  干脆出道手写 SQL 数据库得了</p>\n</blockquote>\n<h2 id=\"L3-1419-数青蛙\"><a href=\"#L3-1419-数青蛙\" class=\"headerlink\" title=\"L3 1419. 数青蛙\"></a>L3 1419. 数青蛙</h2><ul>\n<li>  <strong>通过的用户数</strong>1087</li>\n<li>  <strong>尝试过的用户数</strong>1882</li>\n<li>  <strong>用户总通过次数</strong>1105</li>\n<li>  <strong>用户总提交次数</strong>4362</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个字符串 <code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 <code>croakOfFrogs</code> 中会混合多个 “croak” <em>。</em>请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p>\n<p><strong>注意：</strong>要想发出蛙鸣 “croak”，青蛙必须 <strong>依序</strong> 输出 <code>‘c’, ’r’, ’o’, ’a’, ’k’</code> 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p>\n<p>如果字符串 <code>croakOfFrogs</code> 不是由若干有效的 “croak” 字符混合而成，请返回 <code>-1</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：croakOfFrogs = &quot;croakcroak&quot;</span><br><span class=\"line\">输出：1 </span><br><span class=\"line\">解释：一只青蛙 “呱呱” 两次</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：croakOfFrogs = &quot;crcoakroak&quot;</span><br><span class=\"line\">输出：2 </span><br><span class=\"line\">解释：最少需要两只青蛙，“呱呱” 声用黑体标注</span><br><span class=\"line\">第一只青蛙 &quot;crcoakroak&quot;</span><br><span class=\"line\">第二只青蛙 &quot;crcoakroak&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：croakOfFrogs = &quot;croakcrook&quot;</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：给出的字符串不是 &quot;croak&quot; 的有效组合。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：croakOfFrogs = &quot;croakcroa&quot;</span><br><span class=\"line\">输出：-1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= croakOfFrogs.length &lt;= 10^5</code></li>\n<li>  字符串中的字符只有 <code>&#39;c&#39;</code>, <code>&#39;r&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;a&#39;</code> 或者 <code>&#39;k&#39;</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  状态机。记录在转移序列中的青蛙个数的最大值即可。如果状态转移任何一步出现问题，都应该返回 -1</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">min_number_of_frogs</span></span>(croak_of_frogs: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> stat = [<span class=\"number\">0</span>; <span class=\"number\">4</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> croak_of_frogs.bytes() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">match</span> ch &#123;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;c&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">0</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;r&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">0</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                    stat[<span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;o&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">1</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                    stat[<span class=\"number\">2</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;a&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">2</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                    stat[<span class=\"number\">3</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;k&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">3</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                _ =&gt; <span class=\"built_in\">unreachable!</span>()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stat.iter().filter(|&amp;&amp;i| i &lt; <span class=\"number\">0</span>).count() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cnt = cnt.max(stat.iter().sum::&lt;<span class=\"built_in\">i32</span>&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stat.iter().filter(|&amp;&amp;i| i != <span class=\"number\">0</span>).count() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-1420-生成数组\"><a href=\"#T4-1420-生成数组\" class=\"headerlink\" title=\"T4 1420. 生成数组\"></a>T4 1420. 生成数组</h2><ul>\n<li>  <strong>通过的用户数</strong>181</li>\n<li>  <strong>尝试过的用户数</strong>292</li>\n<li>  <strong>用户总通过次数</strong>200</li>\n<li>  <strong>用户总提交次数</strong>417</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png\" alt=\"img\"></p>\n<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>\n<ul>\n<li>  <code>arr</code> 中有 <code>n</code> 个整数。</li>\n<li>  <code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>\n<li>  将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>\n</ul>\n<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 2, m = 3, k = 1</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, m = 2, k = 3</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：没有数组可以满足上述条件</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 9, m = 1, k = 1</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 50, m = 100, k = 25</span><br><span class=\"line\">输出：34549172</span><br><span class=\"line\">解释：不要忘了对 1000000007 取余</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 37, m = 17, k = 7</span><br><span class=\"line\">输出：418930126</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= n &lt;= 50</code></li>\n<li>  <code>1 &lt;= m &lt;= 100</code></li>\n<li>  <code>0 &lt;= k &lt;= n</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  [动态规划](<a href=\"https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution/sheng-cheng-shu-zu-by-leetcode-solution-yswf/\">生成数组 - 生成数组 - 力扣（LeetCode） (leetcode-cn.com)</a>)</p>\n</blockquote>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-虚拟周赛-185\"><a href=\"#LeetCode-虚拟周赛-185\" class=\"headerlink\" title=\"LeetCode 虚拟周赛 185\"></a>LeetCode 虚拟周赛 185</h1><h2 id=\"T1-1417-重新格式化字符串\"><a href=\"#T1-1417-重新格式化字符串\" class=\"headerlink\" title=\"T1 1417. 重新格式化字符串\"></a>T1 1417. 重新格式化字符串</h2><ul>\n<li>  <strong>通过的用户数</strong>3297</li>\n<li>  <strong>尝试过的用户数</strong>3450</li>\n<li>  <strong>用户总通过次数</strong>3441</li>\n<li>  <strong>用户总提交次数</strong>6732</li>\n<li>  <strong>题目难度</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>\n<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>\n<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a0b1c2&quot;</span><br><span class=\"line\">输出：&quot;0a1b2c&quot;</span><br><span class=\"line\">解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;leetcode&quot;</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;1229857369&quot;</span><br><span class=\"line\">输出：&quot;&quot;</span><br><span class=\"line\">解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;covid2019&quot;</span><br><span class=\"line\">输出：&quot;c2o0v1i9d&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ab123&quot;</span><br><span class=\"line\">输出：&quot;1a2b3&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= s.length &lt;= 500</code></li>\n<li>  <code>s</code> 仅由小写英文字母和/或数字组成。</li>\n</ul>\n<p><strong>提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">reformat</span></span>(s: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> ch = s.bytes().filter(|ch| ch.is_ascii_alphabetic()).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> dig = s.bytes().filter(|ch| ch.is_ascii_digit()).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch.len() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> - dig.len() <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>).abs() &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> s = (<span class=\"number\">0</span>..ch.len().min(dig.len())).fold(<span class=\"built_in\">Vec</span>::new(), |<span class=\"keyword\">mut</span> s, i| &#123;</span><br><span class=\"line\">                s.push(ch[i]);</span><br><span class=\"line\">                s.push(dig[i]);</span><br><span class=\"line\">                s</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch.len() &gt; dig.len() &#123;</span><br><span class=\"line\">                s.push(ch[ch.len() - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ch.len() &lt; dig.len() &#123;</span><br><span class=\"line\">                s.insert(<span class=\"number\">0</span>, dig[dig.len() - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">String</span>::from_utf8(s).unwrap()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-1418-点菜展示表\"><a href=\"#T2-1418-点菜展示表\" class=\"headerlink\" title=\"T2 1418. 点菜展示表\"></a>T2 1418. 点菜展示表</h2><ul>\n<li>  <strong>通过的用户数</strong>1861</li>\n<li>  <strong>尝试过的用户数</strong>2042</li>\n<li>  <strong>用户总通过次数</strong>1885</li>\n<li>  <strong>用户总提交次数</strong>3567</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerNamei,tableNumberi,foodItemi]</code> ，其中 <code>customerNamei</code> 是客户的姓名，<code>tableNumberi</code> 是客户所在餐桌的桌号，而 <code>foodItemi</code> 是客户点的餐品名称。</p>\n<p>请你返回该餐厅的 <strong>点菜展示表</strong> <em>。</em>在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p>\n<p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]</span><br><span class=\"line\">输出：[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] </span><br><span class=\"line\">解释：</span><br><span class=\"line\">点菜展示表如下所示：</span><br><span class=\"line\">Table,Beef Burrito,Ceviche,Fried Chicken,Water</span><br><span class=\"line\">3    ,0           ,2      ,1            ,0</span><br><span class=\"line\">5    ,0           ,1      ,0            ,1</span><br><span class=\"line\">10   ,1           ,0      ,0            ,0</span><br><span class=\"line\">对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;</span><br><span class=\"line\">而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;</span><br><span class=\"line\">餐桌 10：Corina 点了 &quot;Beef Burrito&quot; </span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]</span><br><span class=\"line\">输出：[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] </span><br><span class=\"line\">解释：</span><br><span class=\"line\">对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;</span><br><span class=\"line\">而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]</span><br><span class=\"line\">输出：[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]] </span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= orders.length &lt;= 5 * 10^4</code></li>\n<li>  <code>orders[i].length == 3</code></li>\n<li>  <code>1 &lt;= customerNamei.length, foodItemi.length &lt;= 20</code></li>\n<li>  <code>customerNamei</code> 和 <code>foodItemi</code> 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li>\n<li>  <code>tableNumberi</code> 是 <code>1</code> 到 <code>500</code> 范围内的整数。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  不难，就是恶心，写了半个小时困得扛不住就一键放弃了</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;String&gt;&gt; displayTable(List&lt;List&lt;String&gt;&gt; orders) &#123;</span><br><span class=\"line\">        //构造表头</span><br><span class=\"line\">        List&lt;String&gt; header = orders.stream()</span><br><span class=\"line\">                .map(order -&gt; order.get(2))</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .sorted()</span><br><span class=\"line\">                .collect(Collectors.toCollection(() -&gt; Stream.of(&quot;Table&quot;).collect(Collectors.toList())));</span><br><span class=\"line\"></span><br><span class=\"line\">        //填写数据</span><br><span class=\"line\">        return orders.stream()</span><br><span class=\"line\">                .collect(Collectors.groupingBy(</span><br><span class=\"line\">                        order -&gt; Integer.valueOf(order.get(1)),</span><br><span class=\"line\">                        (Supplier&lt;Map&lt;Integer, Map&lt;String, Integer&gt;&gt;&gt;) TreeMap::new,</span><br><span class=\"line\">                        Collectors.groupingBy(order -&gt; order.get(2), Collectors.summingInt(e -&gt; 1)))</span><br><span class=\"line\">                ).entrySet()</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .peek(entry -&gt; entry.getValue().put(&quot;Table&quot;, entry.getKey()))</span><br><span class=\"line\">                .map(entry -&gt; header.stream()</span><br><span class=\"line\">                        .map(column -&gt; entry.getValue().getOrDefault(column, 0).toString())</span><br><span class=\"line\">                        .collect(Collectors.toList()))</span><br><span class=\"line\">                .collect(Collectors.toCollection(() -&gt; Stream.of(header).collect(Collectors.toList())));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  干脆出道手写 SQL 数据库得了</p>\n</blockquote>\n<h2 id=\"L3-1419-数青蛙\"><a href=\"#L3-1419-数青蛙\" class=\"headerlink\" title=\"L3 1419. 数青蛙\"></a>L3 1419. 数青蛙</h2><ul>\n<li>  <strong>通过的用户数</strong>1087</li>\n<li>  <strong>尝试过的用户数</strong>1882</li>\n<li>  <strong>用户总通过次数</strong>1105</li>\n<li>  <strong>用户总提交次数</strong>4362</li>\n<li>  <strong>题目难度</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个字符串 <code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 <code>croakOfFrogs</code> 中会混合多个 “croak” <em>。</em>请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p>\n<p><strong>注意：</strong>要想发出蛙鸣 “croak”，青蛙必须 <strong>依序</strong> 输出 <code>‘c’, ’r’, ’o’, ’a’, ’k’</code> 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p>\n<p>如果字符串 <code>croakOfFrogs</code> 不是由若干有效的 “croak” 字符混合而成，请返回 <code>-1</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：croakOfFrogs = &quot;croakcroak&quot;</span><br><span class=\"line\">输出：1 </span><br><span class=\"line\">解释：一只青蛙 “呱呱” 两次</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：croakOfFrogs = &quot;crcoakroak&quot;</span><br><span class=\"line\">输出：2 </span><br><span class=\"line\">解释：最少需要两只青蛙，“呱呱” 声用黑体标注</span><br><span class=\"line\">第一只青蛙 &quot;crcoakroak&quot;</span><br><span class=\"line\">第二只青蛙 &quot;crcoakroak&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：croakOfFrogs = &quot;croakcrook&quot;</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：给出的字符串不是 &quot;croak&quot; 的有效组合。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：croakOfFrogs = &quot;croakcroa&quot;</span><br><span class=\"line\">输出：-1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= croakOfFrogs.length &lt;= 10^5</code></li>\n<li>  字符串中的字符只有 <code>&#39;c&#39;</code>, <code>&#39;r&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;a&#39;</code> 或者 <code>&#39;k&#39;</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  状态机。记录在转移序列中的青蛙个数的最大值即可。如果状态转移任何一步出现问题，都应该返回 -1</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">min_number_of_frogs</span></span>(croak_of_frogs: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> stat = [<span class=\"number\">0</span>; <span class=\"number\">4</span>];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> croak_of_frogs.bytes() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">match</span> ch &#123;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;c&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">0</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;r&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">0</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                    stat[<span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;o&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">1</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                    stat[<span class=\"number\">2</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;a&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">2</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                    stat[<span class=\"number\">3</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"string\">b&#x27;k&#x27;</span> =&gt; &#123;</span><br><span class=\"line\">                    stat[<span class=\"number\">3</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                _ =&gt; <span class=\"built_in\">unreachable!</span>()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stat.iter().filter(|&amp;&amp;i| i &lt; <span class=\"number\">0</span>).count() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cnt = cnt.max(stat.iter().sum::&lt;<span class=\"built_in\">i32</span>&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stat.iter().filter(|&amp;&amp;i| i != <span class=\"number\">0</span>).count() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-1420-生成数组\"><a href=\"#T4-1420-生成数组\" class=\"headerlink\" title=\"T4 1420. 生成数组\"></a>T4 1420. 生成数组</h2><ul>\n<li>  <strong>通过的用户数</strong>181</li>\n<li>  <strong>尝试过的用户数</strong>292</li>\n<li>  <strong>用户总通过次数</strong>200</li>\n<li>  <strong>用户总提交次数</strong>417</li>\n<li>  <strong>题目难度</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png\" alt=\"img\"></p>\n<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>\n<ul>\n<li>  <code>arr</code> 中有 <code>n</code> 个整数。</li>\n<li>  <code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>\n<li>  将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>\n</ul>\n<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 2, m = 3, k = 1</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, m = 2, k = 3</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：没有数组可以满足上述条件</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 9, m = 1, k = 1</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 50, m = 100, k = 25</span><br><span class=\"line\">输出：34549172</span><br><span class=\"line\">解释：不要忘了对 1000000007 取余</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 37, m = 17, k = 7</span><br><span class=\"line\">输出：418930126</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= n &lt;= 50</code></li>\n<li>  <code>1 &lt;= m &lt;= 100</code></li>\n<li>  <code>0 &lt;= k &lt;= n</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  [动态规划](<a href=\"https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution/sheng-cheng-shu-zu-by-leetcode-solution-yswf/\">生成数组 - 生成数组 - 力扣（LeetCode） (leetcode-cn.com)</a>)</p>\n</blockquote>\n"},{"title":"LeetCode 周赛 268","date":"2021-11-21T04:33:15.000Z","_content":"\n----------\n\n# LeetCode 周赛 268\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-268/problems/watering-plants/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-268/problems/range-frequency-queries/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-268/problems/sum-of-k-mirror-numbers/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1087 / 4397 | MiracleSNeko | 12   | 1:23:11  | 0:12:25                                                      | 0:25:11                                                      | 1:08:11 3                                                    |                                                              |\n\n>   T1 的数据量直接暴力，直接暴力，直接暴力，不然就会出现我这种 T1 写十分钟的 sb 事情\n\n## T1 5930. 两栋颜色不同且距离最远的房子\n\n-   **User Accepted:**3449\n-   **User Tried:**3518\n-   **Total Accepted:**3504\n-   **Total Submissions:**4578\n-   **Difficulty:** **Easy**\n\n街上有 `n` 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 **0** 开始且长度为 `n` 的整数数组 `colors` ，其中 `colors[i]` 表示第 `i` 栋房子的颜色。\n\n返回 **两栋** 颜色 **不同** 房子之间的 **最大** 距离。\n\n第 `i` 栋房子和第 `j` 栋房子之间的距离是 `abs(i - j)` ，其中 `abs(x)` 是 `x` 的绝对值。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/31/eg1.png)\n\n```\n输入：colors = [1,1,1,6,1,1,1]\n输出：3\n解释：上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 3 。\n房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。\n注意，房子 3 和房子 6 也可以产生最佳答案。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/31/eg2.png)\n\n```\n输入：colors = [1,8,3,8,3]\n输出：4\n解释：上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 4 。\n房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。\n```\n\n**示例 3：**\n\n```\n输入：colors = [0,1]\n输出：1\n解释：两栋颜色不同且距离最远的房子是房子 0 和房子 1 。\n房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。\n```\n\n**提示：**\n\n-   `n == colors.length`\n-   `2 <= n <= 100`\n-   `0 <= colors[i] <= 100`\n-   生成的测试数据满足 **至少** 存在 2 栋颜色不同的房子\n\n**提交：**\n\n```rust\nimpl Solution {\n    pub fn max_distance(colors: Vec<i32>) -> i32 {\n        let len = colors.len();\n        let mut ans = 0;\n        for i in 0..len {\n            for j in i..len {\n                if colors[i] != colors[j] {\n                    ans = ans.max(j - i);\n                }\n            }\n        }\n        ans as i32\n    }\n}\n```\n\n## T2 5201. 给植物浇水\n\n-   **User Accepted:**3240\n-   **User Tried:**3308\n-   **Total Accepted:**3274\n-   **Total Submissions:**4243\n-   **Difficulty:** **Medium**\n\n你打算用一个水罐给花园里的 `n` 株植物浇水。植物排成一行，从左到右进行标记，编号从 `0` 到 `n - 1` 。其中，第 `i` 株植物的位置是 `x = i` 。`x = -1` 处有一条河，你可以在那里重新灌满你的水罐。\n\n每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：\n\n-   按从左到右的顺序给植物浇水。\n-   在给当前植物浇完水之后，如果你没有足够的水 **完全** 浇灌下一株植物，那么你就需要返回河边重新装满水罐。\n-   你 **不能** 提前重新灌满水罐。\n\n最初，你在河边（也就是，`x = -1`），在 x 轴上每移动 **一个单位** 都需要 **一步** 。\n\n给你一个下标从 **0** 开始的整数数组 `plants` ，数组由 `n` 个整数组成。其中，`plants[i]` 为第 `i` 株植物需要的水量。另有一个整数 `capacity` 表示水罐的容量，返回浇灌所有植物需要的 **步数** 。\n\n**示例 1：**\n\n```\n输入：plants = [2,2,3,3], capacity = 5\n输出：14\n解释：从河边开始，此时水罐是装满的：\n- 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。\n- 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。\n- 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。\n- 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。\n- 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。\n需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。\n```\n\n**示例 2：**\n\n```\n输入：plants = [1,1,1,4,2,3], capacity = 4\n输出：30\n解释：从河边开始，此时水罐是装满的：\n- 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。\n- 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。\n- 走到植物 5 (6 步) ，浇水。\n需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。\n```\n\n**示例 3：**\n\n```\n输入：plants = [7,7,7,7,7,7,7], capacity = 8\n输出：49\n解释：每次浇水都需要重新灌满水罐。\n需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。\n```\n\n**提示：**\n\n-   `n == plants.length`\n-   `1 <= n <= 1000`\n-   `1 <= plants[i] <= 106`\n-   `max(plants[i]) <= capacity <= 109`\n\n**提交：**\n\n>   模拟，注意是在前一个植物的位置就发现水不足需要折返\n\n```rust\nimpl Solution {\n    pub fn watering_plants(plants: Vec<i32>, capacity: i32) -> i32 {\n        let mut steps = 1;\n        let mut i = 0;\n        let mut rest = capacity;\n        while i != plants.len() - 1 {\n            rest -= plants[i];\n            // next\n            if rest >= plants[i + 1] {\n                steps += 1;\n            }\n            // back\n            else {\n                steps += 1 + 2 * (i + 1);\n                rest = capacity;\n            }\n            i += 1;\n        }\n        steps as i32\n    }\n}\n```\n\n## T3 5186. 区间内查询数字的频率\n\n-   **User Accepted:**1280\n-   **User Tried:**2923\n-   **Total Accepted:**1332\n-   **Total Submissions:**9561\n-   **Difficulty:** **Medium**\n\n请你设计一个数据结构，它能求出给定子数组内一个给定值的 **频率** 。\n\n子数组中一个值的 **频率** 指的是这个子数组中这个值的出现次数。\n\n请你实现 `RangeFreqQuery` 类：\n\n-   `RangeFreqQuery(int[] arr)` 用下标从 **0** 开始的整数数组 `arr` 构造一个类的实例。\n-   `int query(int left, int right, int value)` 返回子数组 `arr[left...right]` 中 `value` 的 **频率** 。\n\n一个 **子数组** 指的是数组中一段连续的元素。`arr[left...right]` 指的是 `nums` 中包含下标 `left` 和 `right` **在内** 的中间一段连续元素。\n\n**示例 1：**\n\n```\n输入：\n[\"RangeFreqQuery\", \"query\", \"query\"]\n[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]\n输出：\n[null, 1, 2]\n\n解释：\nRangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);\nrangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。\nrangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。\n```\n\n**提示：**\n\n-   `1 <= arr.length <= 105`\n-   `1 <= arr[i], value <= 104`\n-   `0 <= left <= right < arr.length`\n-   调用 `query` 不超过 `105` 次。\n\n**提交：**\n\n>   一开始的 upper_bound 写的有错，需要几个特判边界条件，修改后没了\n\n```rust\nuse std::collections::HashMap;\n\nstruct RangeFreqQuery {\n    pos: HashMap<i32, Vec<usize>>,\n}\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl RangeFreqQuery {\n    fn new(arr: Vec<i32>) -> Self {\n        let pos = arr\n            .iter()\n            .enumerate()\n            .fold(HashMap::new(), |mut mp, (u, &i)| {\n                (*mp.entry(i).or_insert(vec![])).push(u);\n                mp\n            });\n        Self { pos }\n    }\n\n    fn query(&self, left: i32, right: i32, value: i32) -> i32 {\n        if let Some(arr) = self.pos.get(&value) {\n            let l = Self::lower_bound(arr, left as usize);\n            let r = Self::upper_bound(arr, right as usize);\n            r as i32 - l as i32\n        } else {\n            0\n        }\n    }\n\n    fn lower_bound(arr: &Vec<usize>, target: usize) -> usize {\n        let mut l = 0;\n        let mut r = arr.len();\n        while l < r {\n            let m = (l + r) >> 1;\n            if arr[m] >= target {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n\n    fn upper_bound(arr: &Vec<usize>, target: usize) -> usize {\n        let mut l = 0;\n        let mut r = arr.len();\n        while l < r {\n            let m = (l + r) >> 1;\n            if arr[m] > target {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n}\n```\n\n## T4 5933. k 镜像数字的和\n\n-   **User Accepted:**238\n-   **User Tried:**498\n-   **Total Accepted:**284\n-   **Total Submissions:**967\n-   **Difficulty:** **Hard**\n\n一个 **k 镜像数字** 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 **没有前导 0** 的 **正** 整数。\n\n-   比方说，`9` 是一个 2 镜像数字。`9` 在十进制下为 `9` ，二进制下为 `1001` ，两者从前往后读和从后往前读都一样。\n-   相反地，`4` 不是一个 2 镜像数字。`4` 在二进制下为 `100` ，从前往后和从后往前读不相同。\n\n给你进制 `k` 和一个数字 `n` ，请你返回 k 镜像数字中 **最小** 的 `n` 个数 **之和** 。\n\n**示例 1：**\n\n```\n输入：k = 2, n = 5\n输出：25\n解释：\n最小的 5 个 2 镜像数字和它们的二进制表示如下：\n  十进制       二进制\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\n它们的和为 1 + 3 + 5 + 7 + 9 = 25 。\n```\n\n**示例 2：**\n\n```\n输入：k = 3, n = 7\n输出：499\n解释：\n7 个最小的 3 镜像数字和它们的三进制表示如下：\n  十进制       三进制\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\n它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。\n```\n\n**示例 3：**\n\n```\n输入：k = 7, n = 17\n输出：20379000\n解释：17 个最小的 7 镜像数字分别为：\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596\n```\n\n**提示：**\n\n-   `2 <= k <= 9`\n-   `1 <= n <= 30`\n\n**题解：**\n\n>   OEIS 可以直接查表。打表的思路和正经做差不多。遍历 k 进制对称数，并判断十进制是否对称。生成对称数时按位数 &1 分为两种情况 dfs 即可\n\n","source":"_posts/weekly-contest-268.md","raw":"---\ntitle: LeetCode 周赛 268\ndate: 2021-11-21 12:33:15\ntags: LeetCode 周赛总结\n---\n\n----------\n\n# LeetCode 周赛 268\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-268/problems/watering-plants/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-268/problems/range-frequency-queries/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-268/problems/sum-of-k-mirror-numbers/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1087 / 4397 | MiracleSNeko | 12   | 1:23:11  | 0:12:25                                                      | 0:25:11                                                      | 1:08:11 3                                                    |                                                              |\n\n>   T1 的数据量直接暴力，直接暴力，直接暴力，不然就会出现我这种 T1 写十分钟的 sb 事情\n\n## T1 5930. 两栋颜色不同且距离最远的房子\n\n-   **User Accepted:**3449\n-   **User Tried:**3518\n-   **Total Accepted:**3504\n-   **Total Submissions:**4578\n-   **Difficulty:** **Easy**\n\n街上有 `n` 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 **0** 开始且长度为 `n` 的整数数组 `colors` ，其中 `colors[i]` 表示第 `i` 栋房子的颜色。\n\n返回 **两栋** 颜色 **不同** 房子之间的 **最大** 距离。\n\n第 `i` 栋房子和第 `j` 栋房子之间的距离是 `abs(i - j)` ，其中 `abs(x)` 是 `x` 的绝对值。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/31/eg1.png)\n\n```\n输入：colors = [1,1,1,6,1,1,1]\n输出：3\n解释：上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 3 。\n房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。\n注意，房子 3 和房子 6 也可以产生最佳答案。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/10/31/eg2.png)\n\n```\n输入：colors = [1,8,3,8,3]\n输出：4\n解释：上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 4 。\n房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。\n```\n\n**示例 3：**\n\n```\n输入：colors = [0,1]\n输出：1\n解释：两栋颜色不同且距离最远的房子是房子 0 和房子 1 。\n房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。\n```\n\n**提示：**\n\n-   `n == colors.length`\n-   `2 <= n <= 100`\n-   `0 <= colors[i] <= 100`\n-   生成的测试数据满足 **至少** 存在 2 栋颜色不同的房子\n\n**提交：**\n\n```rust\nimpl Solution {\n    pub fn max_distance(colors: Vec<i32>) -> i32 {\n        let len = colors.len();\n        let mut ans = 0;\n        for i in 0..len {\n            for j in i..len {\n                if colors[i] != colors[j] {\n                    ans = ans.max(j - i);\n                }\n            }\n        }\n        ans as i32\n    }\n}\n```\n\n## T2 5201. 给植物浇水\n\n-   **User Accepted:**3240\n-   **User Tried:**3308\n-   **Total Accepted:**3274\n-   **Total Submissions:**4243\n-   **Difficulty:** **Medium**\n\n你打算用一个水罐给花园里的 `n` 株植物浇水。植物排成一行，从左到右进行标记，编号从 `0` 到 `n - 1` 。其中，第 `i` 株植物的位置是 `x = i` 。`x = -1` 处有一条河，你可以在那里重新灌满你的水罐。\n\n每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：\n\n-   按从左到右的顺序给植物浇水。\n-   在给当前植物浇完水之后，如果你没有足够的水 **完全** 浇灌下一株植物，那么你就需要返回河边重新装满水罐。\n-   你 **不能** 提前重新灌满水罐。\n\n最初，你在河边（也就是，`x = -1`），在 x 轴上每移动 **一个单位** 都需要 **一步** 。\n\n给你一个下标从 **0** 开始的整数数组 `plants` ，数组由 `n` 个整数组成。其中，`plants[i]` 为第 `i` 株植物需要的水量。另有一个整数 `capacity` 表示水罐的容量，返回浇灌所有植物需要的 **步数** 。\n\n**示例 1：**\n\n```\n输入：plants = [2,2,3,3], capacity = 5\n输出：14\n解释：从河边开始，此时水罐是装满的：\n- 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。\n- 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。\n- 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。\n- 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。\n- 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。\n需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。\n```\n\n**示例 2：**\n\n```\n输入：plants = [1,1,1,4,2,3], capacity = 4\n输出：30\n解释：从河边开始，此时水罐是装满的：\n- 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。\n- 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。\n- 走到植物 5 (6 步) ，浇水。\n需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。\n```\n\n**示例 3：**\n\n```\n输入：plants = [7,7,7,7,7,7,7], capacity = 8\n输出：49\n解释：每次浇水都需要重新灌满水罐。\n需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。\n```\n\n**提示：**\n\n-   `n == plants.length`\n-   `1 <= n <= 1000`\n-   `1 <= plants[i] <= 106`\n-   `max(plants[i]) <= capacity <= 109`\n\n**提交：**\n\n>   模拟，注意是在前一个植物的位置就发现水不足需要折返\n\n```rust\nimpl Solution {\n    pub fn watering_plants(plants: Vec<i32>, capacity: i32) -> i32 {\n        let mut steps = 1;\n        let mut i = 0;\n        let mut rest = capacity;\n        while i != plants.len() - 1 {\n            rest -= plants[i];\n            // next\n            if rest >= plants[i + 1] {\n                steps += 1;\n            }\n            // back\n            else {\n                steps += 1 + 2 * (i + 1);\n                rest = capacity;\n            }\n            i += 1;\n        }\n        steps as i32\n    }\n}\n```\n\n## T3 5186. 区间内查询数字的频率\n\n-   **User Accepted:**1280\n-   **User Tried:**2923\n-   **Total Accepted:**1332\n-   **Total Submissions:**9561\n-   **Difficulty:** **Medium**\n\n请你设计一个数据结构，它能求出给定子数组内一个给定值的 **频率** 。\n\n子数组中一个值的 **频率** 指的是这个子数组中这个值的出现次数。\n\n请你实现 `RangeFreqQuery` 类：\n\n-   `RangeFreqQuery(int[] arr)` 用下标从 **0** 开始的整数数组 `arr` 构造一个类的实例。\n-   `int query(int left, int right, int value)` 返回子数组 `arr[left...right]` 中 `value` 的 **频率** 。\n\n一个 **子数组** 指的是数组中一段连续的元素。`arr[left...right]` 指的是 `nums` 中包含下标 `left` 和 `right` **在内** 的中间一段连续元素。\n\n**示例 1：**\n\n```\n输入：\n[\"RangeFreqQuery\", \"query\", \"query\"]\n[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]\n输出：\n[null, 1, 2]\n\n解释：\nRangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);\nrangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。\nrangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。\n```\n\n**提示：**\n\n-   `1 <= arr.length <= 105`\n-   `1 <= arr[i], value <= 104`\n-   `0 <= left <= right < arr.length`\n-   调用 `query` 不超过 `105` 次。\n\n**提交：**\n\n>   一开始的 upper_bound 写的有错，需要几个特判边界条件，修改后没了\n\n```rust\nuse std::collections::HashMap;\n\nstruct RangeFreqQuery {\n    pos: HashMap<i32, Vec<usize>>,\n}\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl RangeFreqQuery {\n    fn new(arr: Vec<i32>) -> Self {\n        let pos = arr\n            .iter()\n            .enumerate()\n            .fold(HashMap::new(), |mut mp, (u, &i)| {\n                (*mp.entry(i).or_insert(vec![])).push(u);\n                mp\n            });\n        Self { pos }\n    }\n\n    fn query(&self, left: i32, right: i32, value: i32) -> i32 {\n        if let Some(arr) = self.pos.get(&value) {\n            let l = Self::lower_bound(arr, left as usize);\n            let r = Self::upper_bound(arr, right as usize);\n            r as i32 - l as i32\n        } else {\n            0\n        }\n    }\n\n    fn lower_bound(arr: &Vec<usize>, target: usize) -> usize {\n        let mut l = 0;\n        let mut r = arr.len();\n        while l < r {\n            let m = (l + r) >> 1;\n            if arr[m] >= target {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n\n    fn upper_bound(arr: &Vec<usize>, target: usize) -> usize {\n        let mut l = 0;\n        let mut r = arr.len();\n        while l < r {\n            let m = (l + r) >> 1;\n            if arr[m] > target {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n}\n```\n\n## T4 5933. k 镜像数字的和\n\n-   **User Accepted:**238\n-   **User Tried:**498\n-   **Total Accepted:**284\n-   **Total Submissions:**967\n-   **Difficulty:** **Hard**\n\n一个 **k 镜像数字** 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 **没有前导 0** 的 **正** 整数。\n\n-   比方说，`9` 是一个 2 镜像数字。`9` 在十进制下为 `9` ，二进制下为 `1001` ，两者从前往后读和从后往前读都一样。\n-   相反地，`4` 不是一个 2 镜像数字。`4` 在二进制下为 `100` ，从前往后和从后往前读不相同。\n\n给你进制 `k` 和一个数字 `n` ，请你返回 k 镜像数字中 **最小** 的 `n` 个数 **之和** 。\n\n**示例 1：**\n\n```\n输入：k = 2, n = 5\n输出：25\n解释：\n最小的 5 个 2 镜像数字和它们的二进制表示如下：\n  十进制       二进制\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\n它们的和为 1 + 3 + 5 + 7 + 9 = 25 。\n```\n\n**示例 2：**\n\n```\n输入：k = 3, n = 7\n输出：499\n解释：\n7 个最小的 3 镜像数字和它们的三进制表示如下：\n  十进制       三进制\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\n它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。\n```\n\n**示例 3：**\n\n```\n输入：k = 7, n = 17\n输出：20379000\n解释：17 个最小的 7 镜像数字分别为：\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596\n```\n\n**提示：**\n\n-   `2 <= k <= 9`\n-   `1 <= n <= 30`\n\n**题解：**\n\n>   OEIS 可以直接查表。打表的思路和正经做差不多。遍历 k 进制对称数，并判断十进制是否对称。生成对称数时按位数 &1 分为两种情况 dfs 即可\n\n","slug":"weekly-contest-268","published":1,"updated":"2021-11-21T04:49:56.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckw8rk4y40000osy5cdbf76lc","content":"<hr>\n<h1 id=\"LeetCode-周赛-268\"><a href=\"#LeetCode-周赛-268\" class=\"headerlink\" title=\"LeetCode 周赛 268\"></a>LeetCode 周赛 268</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-268/problems/watering-plants/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-268/problems/range-frequency-queries/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-268/problems/sum-of-k-mirror-numbers/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1087 / 4397</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:23:11</td>\n<td>0:12:25</td>\n<td>0:25:11</td>\n<td>1:08:11 3</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>  T1 的数据量直接暴力，直接暴力，直接暴力，不然就会出现我这种 T1 写十分钟的 sb 事情</p>\n</blockquote>\n<h2 id=\"T1-5930-两栋颜色不同且距离最远的房子\"><a href=\"#T1-5930-两栋颜色不同且距离最远的房子\" class=\"headerlink\" title=\"T1 5930. 两栋颜色不同且距离最远的房子\"></a>T1 5930. 两栋颜色不同且距离最远的房子</h2><ul>\n<li>  **User Accepted:**3449</li>\n<li>  **User Tried:**3518</li>\n<li>  **Total Accepted:**3504</li>\n<li>  **Total Submissions:**4578</li>\n<li>  <strong>Difficulty:</strong> <strong>Easy</strong></li>\n</ul>\n<p>街上有 <code>n</code> 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>colors</code> ，其中 <code>colors[i]</code> 表示第 <code>i</code> 栋房子的颜色。</p>\n<p>返回 <strong>两栋</strong> 颜色 <strong>不同</strong> 房子之间的 <strong>最大</strong> 距离。</p>\n<p>第 <code>i</code> 栋房子和第 <code>j</code> 栋房子之间的距离是 <code>abs(i - j)</code> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/31/eg1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：colors = [1,1,1,6,1,1,1]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。</span><br><span class=\"line\">两栋颜色不同且距离最远的房子是房子 0 和房子 3 。</span><br><span class=\"line\">房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。</span><br><span class=\"line\">注意，房子 3 和房子 6 也可以产生最佳答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/31/eg2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：colors = [1,8,3,8,3]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。</span><br><span class=\"line\">两栋颜色不同且距离最远的房子是房子 0 和房子 4 。</span><br><span class=\"line\">房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：colors = [0,1]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：两栋颜色不同且距离最远的房子是房子 0 和房子 1 。</span><br><span class=\"line\">房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == colors.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 100</code></li>\n<li>  <code>0 &lt;= colors[i] &lt;= 100</code></li>\n<li>  生成的测试数据满足 <strong>至少</strong> 存在 2 栋颜色不同的房子</li>\n</ul>\n<p><strong>提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">max_distance</span></span>(colors: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = colors.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..len &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> i..len &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> colors[i] != colors[j] &#123;</span><br><span class=\"line\">                    ans = ans.max(j - i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-5201-给植物浇水\"><a href=\"#T2-5201-给植物浇水\" class=\"headerlink\" title=\"T2 5201. 给植物浇水\"></a>T2 5201. 给植物浇水</h2><ul>\n<li>  **User Accepted:**3240</li>\n<li>  **User Tried:**3308</li>\n<li>  **Total Accepted:**3274</li>\n<li>  **Total Submissions:**4243</li>\n<li>  <strong>Difficulty:</strong> <strong>Medium</strong></li>\n</ul>\n<p>你打算用一个水罐给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。<code>x = -1</code> 处有一条河，你可以在那里重新灌满你的水罐。</p>\n<p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p>\n<ul>\n<li>  按从左到右的顺序给植物浇水。</li>\n<li>  在给当前植物浇完水之后，如果你没有足够的水 <strong>完全</strong> 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li>\n<li>  你 <strong>不能</strong> 提前重新灌满水罐。</li>\n</ul>\n<p>最初，你在河边（也就是，<code>x = -1</code>），在 x 轴上每移动 <strong>一个单位</strong> 都需要 <strong>一步</strong> 。</p>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有一个整数 <code>capacity</code> 表示水罐的容量，返回浇灌所有植物需要的 <strong>步数</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：plants = [2,2,3,3], capacity = 5</span><br><span class=\"line\">输出：14</span><br><span class=\"line\">解释：从河边开始，此时水罐是装满的：</span><br><span class=\"line\">- 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。</span><br><span class=\"line\">- 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。</span><br><span class=\"line\">- 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。</span><br><span class=\"line\">- 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。</span><br><span class=\"line\">- 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。</span><br><span class=\"line\">- 走到植物 3 (4 步) ，浇水。</span><br><span class=\"line\">需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：plants = [1,1,1,4,2,3], capacity = 4</span><br><span class=\"line\">输出：30</span><br><span class=\"line\">解释：从河边开始，此时水罐是装满的：</span><br><span class=\"line\">- 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。</span><br><span class=\"line\">- 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。</span><br><span class=\"line\">- 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。</span><br><span class=\"line\">- 走到植物 5 (6 步) ，浇水。</span><br><span class=\"line\">需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：plants = [7,7,7,7,7,7,7], capacity = 8</span><br><span class=\"line\">输出：49</span><br><span class=\"line\">解释：每次浇水都需要重新灌满水罐。</span><br><span class=\"line\">需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == plants.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 1000</code></li>\n<li>  <code>1 &lt;= plants[i] &lt;= 106</code></li>\n<li>  <code>max(plants[i]) &lt;= capacity &lt;= 109</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  模拟，注意是在前一个植物的位置就发现水不足需要折返</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">watering_plants</span></span>(plants: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, capacity: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> steps = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> rest = capacity;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != plants.len() - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            rest -= plants[i];</span><br><span class=\"line\">            <span class=\"comment\">// next</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> rest &gt;= plants[i + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">                steps += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// back</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                steps += <span class=\"number\">1</span> + <span class=\"number\">2</span> * (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                rest = capacity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        steps <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T3-5186-区间内查询数字的频率\"><a href=\"#T3-5186-区间内查询数字的频率\" class=\"headerlink\" title=\"T3 5186. 区间内查询数字的频率\"></a>T3 5186. 区间内查询数字的频率</h2><ul>\n<li>  **User Accepted:**1280</li>\n<li>  **User Tried:**2923</li>\n<li>  **Total Accepted:**1332</li>\n<li>  **Total Submissions:**9561</li>\n<li>  <strong>Difficulty:</strong> <strong>Medium</strong></li>\n</ul>\n<p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 <strong>频率</strong> 。</p>\n<p>子数组中一个值的 <strong>频率</strong> 指的是这个子数组中这个值的出现次数。</p>\n<p>请你实现 <code>RangeFreqQuery</code> 类：</p>\n<ul>\n<li>  <code>RangeFreqQuery(int[] arr)</code> 用下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 构造一个类的实例。</li>\n<li>  <code>int query(int left, int right, int value)</code> 返回子数组 <code>arr[left...right]</code> 中 <code>value</code> 的 <strong>频率</strong> 。</li>\n</ul>\n<p>一个 <strong>子数组</strong> 指的是数组中一段连续的元素。<code>arr[left...right]</code> 指的是 <code>nums</code> 中包含下标 <code>left</code> 和 <code>right</code> <strong>在内</strong> 的中间一段连续元素。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]</span><br><span class=\"line\">[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, 1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);</span><br><span class=\"line\">rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。</span><br><span class=\"line\">rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= arr.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= arr[i], value &lt;= 104</code></li>\n<li>  <code>0 &lt;= left &lt;= right &lt; arr.length</code></li>\n<li>  调用 <code>query</code> 不超过 <code>105</code> 次。</li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  一开始的 upper_bound 写的有错，需要几个特判边界条件，修改后没了</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RangeFreqQuery</span></span> &#123;</span><br><span class=\"line\">    pos: HashMap&lt;<span class=\"built_in\">i32</span>, <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> RangeFreqQuery &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>(arr: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> pos = arr</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .enumerate()</span><br><span class=\"line\">            .fold(HashMap::new(), |<span class=\"keyword\">mut</span> mp, (u, &amp;i)| &#123;</span><br><span class=\"line\">                (*mp.entry(i).or_insert(<span class=\"built_in\">vec!</span>[])).push(u);</span><br><span class=\"line\">                mp</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123; pos &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">query</span></span>(&amp;<span class=\"keyword\">self</span>, left: <span class=\"built_in\">i32</span>, right: <span class=\"built_in\">i32</span>, value: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(arr) = <span class=\"keyword\">self</span>.pos.get(&amp;value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = Self::lower_bound(arr, left <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> r = Self::upper_bound(arr, right <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            r <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> - l <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">lower_bound</span></span>(arr: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;, target: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> r = arr.len();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[m] &gt;= target &#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">upper_bound</span></span>(arr: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;, target: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> r = arr.len();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[m] &gt; target &#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-5933-k-镜像数字的和\"><a href=\"#T4-5933-k-镜像数字的和\" class=\"headerlink\" title=\"T4 5933. k 镜像数字的和\"></a>T4 5933. k 镜像数字的和</h2><ul>\n<li>  **User Accepted:**238</li>\n<li>  **User Tried:**498</li>\n<li>  **Total Accepted:**284</li>\n<li>  **Total Submissions:**967</li>\n<li>  <strong>Difficulty:</strong> <strong>Hard</strong></li>\n</ul>\n<p>一个 <strong>k 镜像数字</strong> 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 <strong>没有前导 0</strong> 的 <strong>正</strong> 整数。</p>\n<ul>\n<li>  比方说，<code>9</code> 是一个 2 镜像数字。<code>9</code> 在十进制下为 <code>9</code> ，二进制下为 <code>1001</code> ，两者从前往后读和从后往前读都一样。</li>\n<li>  相反地，<code>4</code> 不是一个 2 镜像数字。<code>4</code> 在二进制下为 <code>100</code> ，从前往后和从后往前读不相同。</li>\n</ul>\n<p>给你进制 <code>k</code> 和一个数字 <code>n</code> ，请你返回 k 镜像数字中 <strong>最小</strong> 的 <code>n</code> 个数 <strong>之和</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：k = 2, n = 5</span><br><span class=\"line\">输出：25</span><br><span class=\"line\">解释：</span><br><span class=\"line\">最小的 5 个 2 镜像数字和它们的二进制表示如下：</span><br><span class=\"line\">  十进制       二进制</span><br><span class=\"line\">    1          1</span><br><span class=\"line\">    3          11</span><br><span class=\"line\">    5          101</span><br><span class=\"line\">    7          111</span><br><span class=\"line\">    9          1001</span><br><span class=\"line\">它们的和为 1 + 3 + 5 + 7 + 9 = 25 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：k = 3, n = 7</span><br><span class=\"line\">输出：499</span><br><span class=\"line\">解释：</span><br><span class=\"line\">7 个最小的 3 镜像数字和它们的三进制表示如下：</span><br><span class=\"line\">  十进制       三进制</span><br><span class=\"line\">    1          1</span><br><span class=\"line\">    2          2</span><br><span class=\"line\">    4          11</span><br><span class=\"line\">    8          22</span><br><span class=\"line\">    121        11111</span><br><span class=\"line\">    151        12121</span><br><span class=\"line\">    212        21212</span><br><span class=\"line\">它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：k = 7, n = 17</span><br><span class=\"line\">输出：20379000</span><br><span class=\"line\">解释：17 个最小的 7 镜像数字分别为：</span><br><span class=\"line\">1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= k &lt;= 9</code></li>\n<li>  <code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  OEIS 可以直接查表。打表的思路和正经做差不多。遍历 k 进制对称数，并判断十进制是否对称。生成对称数时按位数 &amp;1 分为两种情况 dfs 即可</p>\n</blockquote>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-268\"><a href=\"#LeetCode-周赛-268\" class=\"headerlink\" title=\"LeetCode 周赛 268\"></a>LeetCode 周赛 268</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-268/problems/watering-plants/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-268/problems/range-frequency-queries/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-268/problems/sum-of-k-mirror-numbers/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1087 / 4397</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>1:23:11</td>\n<td>0:12:25</td>\n<td>0:25:11</td>\n<td>1:08:11 3</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>  T1 的数据量直接暴力，直接暴力，直接暴力，不然就会出现我这种 T1 写十分钟的 sb 事情</p>\n</blockquote>\n<h2 id=\"T1-5930-两栋颜色不同且距离最远的房子\"><a href=\"#T1-5930-两栋颜色不同且距离最远的房子\" class=\"headerlink\" title=\"T1 5930. 两栋颜色不同且距离最远的房子\"></a>T1 5930. 两栋颜色不同且距离最远的房子</h2><ul>\n<li>  **User Accepted:**3449</li>\n<li>  **User Tried:**3518</li>\n<li>  **Total Accepted:**3504</li>\n<li>  **Total Submissions:**4578</li>\n<li>  <strong>Difficulty:</strong> <strong>Easy</strong></li>\n</ul>\n<p>街上有 <code>n</code> 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>colors</code> ，其中 <code>colors[i]</code> 表示第 <code>i</code> 栋房子的颜色。</p>\n<p>返回 <strong>两栋</strong> 颜色 <strong>不同</strong> 房子之间的 <strong>最大</strong> 距离。</p>\n<p>第 <code>i</code> 栋房子和第 <code>j</code> 栋房子之间的距离是 <code>abs(i - j)</code> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/31/eg1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：colors = [1,1,1,6,1,1,1]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。</span><br><span class=\"line\">两栋颜色不同且距离最远的房子是房子 0 和房子 3 。</span><br><span class=\"line\">房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。</span><br><span class=\"line\">注意，房子 3 和房子 6 也可以产生最佳答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/31/eg2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：colors = [1,8,3,8,3]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。</span><br><span class=\"line\">两栋颜色不同且距离最远的房子是房子 0 和房子 4 。</span><br><span class=\"line\">房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：colors = [0,1]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：两栋颜色不同且距离最远的房子是房子 0 和房子 1 。</span><br><span class=\"line\">房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == colors.length</code></li>\n<li>  <code>2 &lt;= n &lt;= 100</code></li>\n<li>  <code>0 &lt;= colors[i] &lt;= 100</code></li>\n<li>  生成的测试数据满足 <strong>至少</strong> 存在 2 栋颜色不同的房子</li>\n</ul>\n<p><strong>提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">max_distance</span></span>(colors: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = colors.len();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..len &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> i..len &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> colors[i] != colors[j] &#123;</span><br><span class=\"line\">                    ans = ans.max(j - i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-5201-给植物浇水\"><a href=\"#T2-5201-给植物浇水\" class=\"headerlink\" title=\"T2 5201. 给植物浇水\"></a>T2 5201. 给植物浇水</h2><ul>\n<li>  **User Accepted:**3240</li>\n<li>  **User Tried:**3308</li>\n<li>  **Total Accepted:**3274</li>\n<li>  **Total Submissions:**4243</li>\n<li>  <strong>Difficulty:</strong> <strong>Medium</strong></li>\n</ul>\n<p>你打算用一个水罐给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。<code>x = -1</code> 处有一条河，你可以在那里重新灌满你的水罐。</p>\n<p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p>\n<ul>\n<li>  按从左到右的顺序给植物浇水。</li>\n<li>  在给当前植物浇完水之后，如果你没有足够的水 <strong>完全</strong> 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li>\n<li>  你 <strong>不能</strong> 提前重新灌满水罐。</li>\n</ul>\n<p>最初，你在河边（也就是，<code>x = -1</code>），在 x 轴上每移动 <strong>一个单位</strong> 都需要 <strong>一步</strong> 。</p>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有一个整数 <code>capacity</code> 表示水罐的容量，返回浇灌所有植物需要的 <strong>步数</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：plants = [2,2,3,3], capacity = 5</span><br><span class=\"line\">输出：14</span><br><span class=\"line\">解释：从河边开始，此时水罐是装满的：</span><br><span class=\"line\">- 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。</span><br><span class=\"line\">- 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。</span><br><span class=\"line\">- 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。</span><br><span class=\"line\">- 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。</span><br><span class=\"line\">- 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。</span><br><span class=\"line\">- 走到植物 3 (4 步) ，浇水。</span><br><span class=\"line\">需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：plants = [1,1,1,4,2,3], capacity = 4</span><br><span class=\"line\">输出：30</span><br><span class=\"line\">解释：从河边开始，此时水罐是装满的：</span><br><span class=\"line\">- 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。</span><br><span class=\"line\">- 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。</span><br><span class=\"line\">- 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。</span><br><span class=\"line\">- 走到植物 5 (6 步) ，浇水。</span><br><span class=\"line\">需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：plants = [7,7,7,7,7,7,7], capacity = 8</span><br><span class=\"line\">输出：49</span><br><span class=\"line\">解释：每次浇水都需要重新灌满水罐。</span><br><span class=\"line\">需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == plants.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 1000</code></li>\n<li>  <code>1 &lt;= plants[i] &lt;= 106</code></li>\n<li>  <code>max(plants[i]) &lt;= capacity &lt;= 109</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  模拟，注意是在前一个植物的位置就发现水不足需要折返</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">watering_plants</span></span>(plants: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, capacity: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> steps = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> rest = capacity;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != plants.len() - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            rest -= plants[i];</span><br><span class=\"line\">            <span class=\"comment\">// next</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> rest &gt;= plants[i + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">                steps += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// back</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                steps += <span class=\"number\">1</span> + <span class=\"number\">2</span> * (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                rest = capacity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        steps <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T3-5186-区间内查询数字的频率\"><a href=\"#T3-5186-区间内查询数字的频率\" class=\"headerlink\" title=\"T3 5186. 区间内查询数字的频率\"></a>T3 5186. 区间内查询数字的频率</h2><ul>\n<li>  **User Accepted:**1280</li>\n<li>  **User Tried:**2923</li>\n<li>  **Total Accepted:**1332</li>\n<li>  **Total Submissions:**9561</li>\n<li>  <strong>Difficulty:</strong> <strong>Medium</strong></li>\n</ul>\n<p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 <strong>频率</strong> 。</p>\n<p>子数组中一个值的 <strong>频率</strong> 指的是这个子数组中这个值的出现次数。</p>\n<p>请你实现 <code>RangeFreqQuery</code> 类：</p>\n<ul>\n<li>  <code>RangeFreqQuery(int[] arr)</code> 用下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 构造一个类的实例。</li>\n<li>  <code>int query(int left, int right, int value)</code> 返回子数组 <code>arr[left...right]</code> 中 <code>value</code> 的 <strong>频率</strong> 。</li>\n</ul>\n<p>一个 <strong>子数组</strong> 指的是数组中一段连续的元素。<code>arr[left...right]</code> 指的是 <code>nums</code> 中包含下标 <code>left</code> 和 <code>right</code> <strong>在内</strong> 的中间一段连续元素。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]</span><br><span class=\"line\">[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, 1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);</span><br><span class=\"line\">rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。</span><br><span class=\"line\">rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= arr.length &lt;= 105</code></li>\n<li>  <code>1 &lt;= arr[i], value &lt;= 104</code></li>\n<li>  <code>0 &lt;= left &lt;= right &lt; arr.length</code></li>\n<li>  调用 <code>query</code> 不超过 <code>105</code> 次。</li>\n</ul>\n<p><strong>提交：</strong></p>\n<blockquote>\n<p>  一开始的 upper_bound 写的有错，需要几个特判边界条件，修改后没了</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RangeFreqQuery</span></span> &#123;</span><br><span class=\"line\">    pos: HashMap&lt;<span class=\"built_in\">i32</span>, <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> RangeFreqQuery &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>(arr: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> pos = arr</span><br><span class=\"line\">            .iter()</span><br><span class=\"line\">            .enumerate()</span><br><span class=\"line\">            .fold(HashMap::new(), |<span class=\"keyword\">mut</span> mp, (u, &amp;i)| &#123;</span><br><span class=\"line\">                (*mp.entry(i).or_insert(<span class=\"built_in\">vec!</span>[])).push(u);</span><br><span class=\"line\">                mp</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123; pos &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">query</span></span>(&amp;<span class=\"keyword\">self</span>, left: <span class=\"built_in\">i32</span>, right: <span class=\"built_in\">i32</span>, value: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(arr) = <span class=\"keyword\">self</span>.pos.get(&amp;value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> l = Self::lower_bound(arr, left <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> r = Self::upper_bound(arr, right <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">            r <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> - l <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">lower_bound</span></span>(arr: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;, target: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> r = arr.len();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[m] &gt;= target &#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">upper_bound</span></span>(arr: &amp;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;, target: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> r = arr.len();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[m] &gt; target &#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-5933-k-镜像数字的和\"><a href=\"#T4-5933-k-镜像数字的和\" class=\"headerlink\" title=\"T4 5933. k 镜像数字的和\"></a>T4 5933. k 镜像数字的和</h2><ul>\n<li>  **User Accepted:**238</li>\n<li>  **User Tried:**498</li>\n<li>  **Total Accepted:**284</li>\n<li>  **Total Submissions:**967</li>\n<li>  <strong>Difficulty:</strong> <strong>Hard</strong></li>\n</ul>\n<p>一个 <strong>k 镜像数字</strong> 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 <strong>没有前导 0</strong> 的 <strong>正</strong> 整数。</p>\n<ul>\n<li>  比方说，<code>9</code> 是一个 2 镜像数字。<code>9</code> 在十进制下为 <code>9</code> ，二进制下为 <code>1001</code> ，两者从前往后读和从后往前读都一样。</li>\n<li>  相反地，<code>4</code> 不是一个 2 镜像数字。<code>4</code> 在二进制下为 <code>100</code> ，从前往后和从后往前读不相同。</li>\n</ul>\n<p>给你进制 <code>k</code> 和一个数字 <code>n</code> ，请你返回 k 镜像数字中 <strong>最小</strong> 的 <code>n</code> 个数 <strong>之和</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：k = 2, n = 5</span><br><span class=\"line\">输出：25</span><br><span class=\"line\">解释：</span><br><span class=\"line\">最小的 5 个 2 镜像数字和它们的二进制表示如下：</span><br><span class=\"line\">  十进制       二进制</span><br><span class=\"line\">    1          1</span><br><span class=\"line\">    3          11</span><br><span class=\"line\">    5          101</span><br><span class=\"line\">    7          111</span><br><span class=\"line\">    9          1001</span><br><span class=\"line\">它们的和为 1 + 3 + 5 + 7 + 9 = 25 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：k = 3, n = 7</span><br><span class=\"line\">输出：499</span><br><span class=\"line\">解释：</span><br><span class=\"line\">7 个最小的 3 镜像数字和它们的三进制表示如下：</span><br><span class=\"line\">  十进制       三进制</span><br><span class=\"line\">    1          1</span><br><span class=\"line\">    2          2</span><br><span class=\"line\">    4          11</span><br><span class=\"line\">    8          22</span><br><span class=\"line\">    121        11111</span><br><span class=\"line\">    151        12121</span><br><span class=\"line\">    212        21212</span><br><span class=\"line\">它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：k = 7, n = 17</span><br><span class=\"line\">输出：20379000</span><br><span class=\"line\">解释：17 个最小的 7 镜像数字分别为：</span><br><span class=\"line\">1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= k &lt;= 9</code></li>\n<li>  <code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  OEIS 可以直接查表。打表的思路和正经做差不多。遍历 k 进制对称数，并判断十进制是否对称。生成对称数时按位数 &amp;1 分为两种情况 dfs 即可</p>\n</blockquote>\n"},{"title":"某科学的算法错题集","date":"2021-11-23T14:42:43.000Z","_content":"\n------------\n\n# 某科学的算法错题集\n\n>   平时写完大呼 CNM 的题目集合\n\n## Lc 1093. 大样本统计\n\n我们对 `0` 到 `255` 之间的整数进行采样，并将结果存储在数组 `count` 中：`count[k]` 就是整数 `k` 的采样个数。\n\n我们以 **浮点数** 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。\n\n我们先来回顾一下中位数的知识：\n\n-   如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；\n-   如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。\n\n**示例 1：**\n\n```\n输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n输出：[1.00000,3.00000,2.37500,2.50000,3.00000]\n```\n\n**示例 2：**\n\n```\n输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n输出：[1.00000,4.00000,2.18182,2.00000,1.00000]\n```\n\n**提示：**\n\n1.  `count.length == 256`\n2.  `1 <= sum(count) <= 10^9`\n3.  计数表示的众数是唯一的\n4.  答案与真实值误差在 `10^-5` 以内就会被视为正确答案\n\n**笔记：**\n\n其他几个数都好求，麻烦在中位数上。如果通过判断当前的 `sum` 值和 `len/2` 之间的关系，需要判断奇偶数等多种情况，因此用 `sum << 1` 和 `len` 之间直接比较即可，这样只需要处理一种特殊情况。\n\n```rust\nimpl Solution {\n    pub fn sample_stats(count: Vec<i32>) -> Vec<f64> {\n        let count = count.into_iter().enumerate().filter(|pair| pair.1 != 0).collect::<Vec<_>>();\n        let max = count.iter().max_by_key(|i| i.0).unwrap().0;\n        let min = count.iter().min_by_key(|i| i.0).unwrap().0;\n        let mode = count.iter().max_by_key(|i| i.1).unwrap().0;\n        let (sum, len) = count.iter().fold((0., 0), |(sum, len), p| (sum + p.0 as f64 * p.1 as f64, len + p.1));\n        let mut curr = 0;\n        let mut mid = 0.;\n        for i in 0..count.len() {\n            curr += count[i].1;\n            if curr << 1 > len {\n                mid = count[i].0 as f64;\n            } else if curr << 1 == len {\n                mid = (count[i].0 + count[i + 1].0) as f64 / 2.0;\n            } else {\n                continue;\n            }\n            break;\n        }\n        vec![min as f64, max as f64, sum / len as f64, mid, mode as f64]\n    }\n}\n```\n\n","source":"_posts/problem-set.md","raw":"---\ntitle: 某科学的算法错题集\ndate: 2021-11-23 22:42:43\ntags: 错题集\n---\n\n------------\n\n# 某科学的算法错题集\n\n>   平时写完大呼 CNM 的题目集合\n\n## Lc 1093. 大样本统计\n\n我们对 `0` 到 `255` 之间的整数进行采样，并将结果存储在数组 `count` 中：`count[k]` 就是整数 `k` 的采样个数。\n\n我们以 **浮点数** 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。\n\n我们先来回顾一下中位数的知识：\n\n-   如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；\n-   如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。\n\n**示例 1：**\n\n```\n输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n输出：[1.00000,3.00000,2.37500,2.50000,3.00000]\n```\n\n**示例 2：**\n\n```\n输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n输出：[1.00000,4.00000,2.18182,2.00000,1.00000]\n```\n\n**提示：**\n\n1.  `count.length == 256`\n2.  `1 <= sum(count) <= 10^9`\n3.  计数表示的众数是唯一的\n4.  答案与真实值误差在 `10^-5` 以内就会被视为正确答案\n\n**笔记：**\n\n其他几个数都好求，麻烦在中位数上。如果通过判断当前的 `sum` 值和 `len/2` 之间的关系，需要判断奇偶数等多种情况，因此用 `sum << 1` 和 `len` 之间直接比较即可，这样只需要处理一种特殊情况。\n\n```rust\nimpl Solution {\n    pub fn sample_stats(count: Vec<i32>) -> Vec<f64> {\n        let count = count.into_iter().enumerate().filter(|pair| pair.1 != 0).collect::<Vec<_>>();\n        let max = count.iter().max_by_key(|i| i.0).unwrap().0;\n        let min = count.iter().min_by_key(|i| i.0).unwrap().0;\n        let mode = count.iter().max_by_key(|i| i.1).unwrap().0;\n        let (sum, len) = count.iter().fold((0., 0), |(sum, len), p| (sum + p.0 as f64 * p.1 as f64, len + p.1));\n        let mut curr = 0;\n        let mut mid = 0.;\n        for i in 0..count.len() {\n            curr += count[i].1;\n            if curr << 1 > len {\n                mid = count[i].0 as f64;\n            } else if curr << 1 == len {\n                mid = (count[i].0 + count[i + 1].0) as f64 / 2.0;\n            } else {\n                continue;\n            }\n            break;\n        }\n        vec![min as f64, max as f64, sum / len as f64, mid, mode as f64]\n    }\n}\n```\n\n","slug":"problem-set","published":1,"updated":"2021-11-23T14:53:46.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwca1lc70000dcy57k677qxb","content":"<hr>\n<h1 id=\"某科学的算法错题集\"><a href=\"#某科学的算法错题集\" class=\"headerlink\" title=\"某科学的算法错题集\"></a>某科学的算法错题集</h1><blockquote>\n<p>  平时写完大呼 CNM 的题目集合</p>\n</blockquote>\n<h2 id=\"Lc-1093-大样本统计\"><a href=\"#Lc-1093-大样本统计\" class=\"headerlink\" title=\"Lc 1093. 大样本统计\"></a>Lc 1093. 大样本统计</h2><p>我们对 <code>0</code> 到 <code>255</code> 之间的整数进行采样，并将结果存储在数组 <code>count</code> 中：<code>count[k]</code> 就是整数 <code>k</code> 的采样个数。</p>\n<p>我们以 <strong>浮点数</strong> 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。</p>\n<p>我们先来回顾一下中位数的知识：</p>\n<ul>\n<li>  如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；</li>\n<li>  如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">输出：[1.00000,3.00000,2.37500,2.50000,3.00000]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">输出：[1.00000,4.00000,2.18182,2.00000,1.00000]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li> <code>count.length == 256</code></li>\n<li> <code>1 &lt;= sum(count) &lt;= 10^9</code></li>\n<li> 计数表示的众数是唯一的</li>\n<li> 答案与真实值误差在 <code>10^-5</code> 以内就会被视为正确答案</li>\n</ol>\n<p><strong>笔记：</strong></p>\n<p>其他几个数都好求，麻烦在中位数上。如果通过判断当前的 <code>sum</code> 值和 <code>len/2</code> 之间的关系，需要判断奇偶数等多种情况，因此用 <code>sum &lt;&lt; 1</code> 和 <code>len</code> 之间直接比较即可，这样只需要处理一种特殊情况。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">sample_stats</span></span>(count: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">f64</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> count = count.into_iter().enumerate().filter(|pair| pair.<span class=\"number\">1</span> != <span class=\"number\">0</span>).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> max = count.iter().max_by_key(|i| i.<span class=\"number\">0</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> min = count.iter().min_by_key(|i| i.<span class=\"number\">0</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mode = count.iter().max_by_key(|i| i.<span class=\"number\">1</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (sum, len) = count.iter().fold((<span class=\"number\">0</span>., <span class=\"number\">0</span>), |(sum, len), p| (sum + p.<span class=\"number\">0</span> <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span> * p.<span class=\"number\">1</span> <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>, len + p.<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> curr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mid = <span class=\"number\">0</span>.;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..count.len() &#123;</span><br><span class=\"line\">            curr += count[i].<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> curr &lt;&lt; <span class=\"number\">1</span> &gt; len &#123;</span><br><span class=\"line\">                mid = count[i].<span class=\"number\">0</span> <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> curr &lt;&lt; <span class=\"number\">1</span> == len &#123;</span><br><span class=\"line\">                mid = (count[i].<span class=\"number\">0</span> + count[i + <span class=\"number\">1</span>].<span class=\"number\">0</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span> / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">vec!</span>[min <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>, max <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>, sum / len <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>, mid, mode <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"某科学的算法错题集\"><a href=\"#某科学的算法错题集\" class=\"headerlink\" title=\"某科学的算法错题集\"></a>某科学的算法错题集</h1><blockquote>\n<p>  平时写完大呼 CNM 的题目集合</p>\n</blockquote>\n<h2 id=\"Lc-1093-大样本统计\"><a href=\"#Lc-1093-大样本统计\" class=\"headerlink\" title=\"Lc 1093. 大样本统计\"></a>Lc 1093. 大样本统计</h2><p>我们对 <code>0</code> 到 <code>255</code> 之间的整数进行采样，并将结果存储在数组 <code>count</code> 中：<code>count[k]</code> 就是整数 <code>k</code> 的采样个数。</p>\n<p>我们以 <strong>浮点数</strong> 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。</p>\n<p>我们先来回顾一下中位数的知识：</p>\n<ul>\n<li>  如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；</li>\n<li>  如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">输出：[1.00000,3.00000,2.37500,2.50000,3.00000]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">输出：[1.00000,4.00000,2.18182,2.00000,1.00000]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li> <code>count.length == 256</code></li>\n<li> <code>1 &lt;= sum(count) &lt;= 10^9</code></li>\n<li> 计数表示的众数是唯一的</li>\n<li> 答案与真实值误差在 <code>10^-5</code> 以内就会被视为正确答案</li>\n</ol>\n<p><strong>笔记：</strong></p>\n<p>其他几个数都好求，麻烦在中位数上。如果通过判断当前的 <code>sum</code> 值和 <code>len/2</code> 之间的关系，需要判断奇偶数等多种情况，因此用 <code>sum &lt;&lt; 1</code> 和 <code>len</code> 之间直接比较即可，这样只需要处理一种特殊情况。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">sample_stats</span></span>(count: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">f64</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> count = count.into_iter().enumerate().filter(|pair| pair.<span class=\"number\">1</span> != <span class=\"number\">0</span>).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> max = count.iter().max_by_key(|i| i.<span class=\"number\">0</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> min = count.iter().min_by_key(|i| i.<span class=\"number\">0</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mode = count.iter().max_by_key(|i| i.<span class=\"number\">1</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (sum, len) = count.iter().fold((<span class=\"number\">0</span>., <span class=\"number\">0</span>), |(sum, len), p| (sum + p.<span class=\"number\">0</span> <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span> * p.<span class=\"number\">1</span> <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>, len + p.<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> curr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mid = <span class=\"number\">0</span>.;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..count.len() &#123;</span><br><span class=\"line\">            curr += count[i].<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> curr &lt;&lt; <span class=\"number\">1</span> &gt; len &#123;</span><br><span class=\"line\">                mid = count[i].<span class=\"number\">0</span> <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> curr &lt;&lt; <span class=\"number\">1</span> == len &#123;</span><br><span class=\"line\">                mid = (count[i].<span class=\"number\">0</span> + count[i + <span class=\"number\">1</span>].<span class=\"number\">0</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span> / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">vec!</span>[min <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>, max <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>, sum / len <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>, mid, mode <span class=\"keyword\">as</span> <span class=\"built_in\">f64</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LeetCode 周赛 269","date":"2021-11-28T13:05:37.000Z","_content":"\n----------\n\n# LeetCode 周赛 268\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-269/problems/k-radius-subarray-averages/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-269/problems/removing-minimum-and-maximum-from-array/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-269/problems/find-all-people-with-secret/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1340 / 4292 | MiracleSNeko | 12   | 0:40:39  | 0:01:58                                                      | 0:16:32 1                                                    | 0:35:39                                                      |                                                              |\n\n>   手速慢了是真没办法\n\n## T1 5938. 找出数组排序后的目标下标\n\n-   **User Accepted:**3482\n-   **User Tried:**3512\n-   **Total Accepted:**3520\n-   **Total Submissions:**4023\n-   **Difficulty:** **Easy**\n\n给你一个下标从 **0** 开始的整数数组 `nums` 以及一个目标元素 `target` 。\n\n**目标下标** 是一个满足 `nums[i] == target` 的下标 `i` 。\n\n将 `nums` 按 **非递减** 顺序排序后，返回由 `nums` 中目标下标组成的列表。如果不存在目标下标，返回一个 **空** 列表。返回的列表必须按 **递增** 顺序排列。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,5,2,3], target = 2\n输出：[1,2]\n解释：排序后，nums 变为 [1,2,2,3,5] 。\n满足 nums[i] == 2 的下标是 1 和 2 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,5,2,3], target = 3\n输出：[3]\n解释：排序后，nums 变为 [1,2,2,3,5] 。\n满足 nums[i] == 3 的下标是 3 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,2,5,2,3], target = 5\n输出：[4]\n解释：排序后，nums 变为 [1,2,2,3,5] 。\n满足 nums[i] == 5 的下标是 4 。\n```\n\n**示例 4：**\n\n```\n输入：nums = [1,2,5,2,3], target = 4\n输出：[]\n解释：nums 中不含值为 4 的元素。\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 100`\n-   `1 <= nums[i], target <= 100`\n\n**提交：**\n\n```rust\nimpl Solution {\n    pub fn target_indices(mut nums: Vec<i32>, target: i32) -> Vec<i32> {\n        nums.sort();\n        nums.iter().enumerate()\n            .filter(|(_, &v)| v == target)\n            .map(|(idx, _)| idx as i32)\n            .collect()\n    }\n}\n```\n\n## T2 5939. 半径为 k 的子数组平均值\n\n-   **User Accepted:**2893\n-   **User Tried:**3329\n-   **Total Accepted:**2923\n-   **Total Submissions:**9155\n-   **Difficulty:** **Medium**\n\n给你一个下标从 **0** 开始的数组 `nums` ，数组中有 `n` 个整数，另给你一个整数 `k` 。\n\n**半径为 k 的子数组平均值** 是指：`nums` 中一个以下标 `i` 为 **中心** 且 **半径** 为 `k` 的子数组中所有元素的平均值，即下标在 `i - k` 和 `i + k` 范围（**含** `i - k` 和 `i + k`）内所有元素的平均值。如果在下标 `i` 前或后不足 `k` 个元素，那么 **半径为 k 的子数组平均值** 是 `-1` 。\n\n构建并返回一个长度为 `n` 的数组 `avgs` ，其中 `avgs[i]` 是以下标 `i` 为中心的子数组的 **半径为 k 的子数组平均值** 。\n\n`x` 个元素的 **平均值** 是 `x` 个元素相加之和除以 `x` ，此时使用截断式 **整数除法** ，即需要去掉结果的小数部分。\n\n-   例如，四个元素 `2`、`3`、`1` 和 `5` 的平均值是 `(2 + 3 + 1 + 5) / 4 = 11 / 4 = 3.75`，截断后得到 `3` 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/11/07/eg1.png)\n\n```\n输入：nums = [7,4,3,9,1,8,5,2,6], k = 3\n输出：[-1,-1,-1,5,4,4,-1,-1,-1]\n解释：\n- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。\n- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。\n  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。\n- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。\n- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。\n- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n```\n\n**示例 2：**\n\n```\n输入：nums = [100000], k = 0\n输出：[100000]\n解释：\n- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。\n  avg[0] = 100000 / 1 = 100000 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [8], k = 100000\n输出：[-1]\n解释：\n- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n```\n\n**提示：**\n\n-   `n == nums.length`\n-   `1 <= n <= 105`\n-   `0 <= nums[i], k <= 105`\n\n>   注意前缀和 $10^5 \\times 10^5$ 是会爆 `i32` 的！！！\n\n```rust\nimpl Solution {\n    pub fn watering_plants(plants: Vec<i32>, capacity: i32) -> i32 {\n        let mut steps = 1;\n        let mut i = 0;\n        let mut rest = capacity;\n        while i != plants.len() - 1 {\n            rest -= plants[i];\n            // next\n            if rest >= plants[i + 1] {\n                steps += 1;\n            }\n            // back\n            else {\n                steps += 1 + 2 * (i + 1);\n                rest = capacity;\n            }\n            i += 1;\n        }\n        steps as i32\n    }\n}\n```\n\n## T3 5940. 从数组中移除最大值和最小值\n\n-   **User Accepted:**2832\n-   **User Tried:**3041\n-   **Total Accepted:**2870\n-   **Total Submissions:**5009\n-   **Difficulty:** **Medium**\n\n给你一个下标从 **0** 开始的数组 `nums` ，数组由若干 **互不相同** 的整数组成。\n\n`nums` 中有一个值最小的元素和一个值最大的元素。分别称为 **最小值** 和 **最大值** 。你的目标是从数组中移除这两个元素。\n\n一次 **删除** 操作定义为从数组的 **前面** 移除一个元素或从数组的 **后面** 移除一个元素。\n\n返回将数组中最小值和最大值 **都** 移除需要的最小删除次数。 \n\n**示例 1：**\n\n```\n输入：nums = [2,10,7,5,4,1,8,6]\n输出：5\n解释：\n数组中的最小元素是 nums[5] ，值为 1 。\n数组中的最大元素是 nums[1] ，值为 10 。\n将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。\n结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,-4,19,1,8,-2,-3,5]\n输出：3\n解释：\n数组中的最小元素是 nums[1] ，值为 -4 。\n数组中的最大元素是 nums[2] ，值为 19 。\n将最大值和最小值都移除需要从数组前面移除 3 个元素。\n结果是 3 ，这是所有可能情况中的最小删除次数。 \n```\n\n**示例 3：**\n\n```\n输入：nums = [101]\n输出：1\n解释：\n数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。\n移除它只需要 1 次删除操作。\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 105`\n-   `-105 <= nums[i] <= 105`\n-   `nums` 中的整数 **互不相同**\n\n>   只有都从左边、都从右边、一左一右三种情况\n\n```rust\nimpl Solution {\n    pub fn minimum_deletions(nums: Vec<i32>) -> i32 {\n        let mut maxpos = nums.iter().enumerate().max_by_key(|item| item.1).unwrap().0;\n        let mut minpos = nums.iter().enumerate().min_by_key(|item| item.1).unwrap().0;\n        let len = nums.len();\n        if maxpos < minpos {\n            std::mem::swap(&mut maxpos, &mut minpos);\n        }\n        let (l, r, m) = (minpos + 1, len - maxpos, maxpos - minpos);\n        (l + r).min((l + m).min(r + m)) as i32\n    }\n}\n```\n\n## T4 5941. 找出知晓秘密的所有专家\n\n-   **User Accepted:**648\n-   **User Tried:**1842\n-   **Total Accepted:**756\n-   **Total Submissions:**5755\n-   **Difficulty:** **Hard**\n\n给你一个整数 `n` ，表示有 `n` 个专家从 `0` 到 `n - 1` 编号。另外给你一个下标从 0 开始的二维整数数组 `meetings` ，其中 `meetings[i] = [xi, yi, timei]` 表示专家 `xi` 和专家 `yi` 在时间 `timei` 要开一场会。一个专家可以同时参加 **多场会议** 。最后，给你一个整数 `firstPerson` 。\n\n专家 `0` 有一个 **秘密** ，最初，他在时间 `0` 将这个秘密分享给了专家 `firstPerson` 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 `xi` 在时间 `timei` 时知晓这个秘密，那么他将会与专家 `yi` 分享这个秘密，反之亦然。\n\n秘密共享是 **瞬时发生** 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。\n\n在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 **任何顺序** 返回答案。\n\n**示例 1：**\n\n```\n输入：n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\n输出：[0,1,2,3,5]\n解释：\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 5 ，专家 1 将秘密与专家 2 共享。\n时间 8 ，专家 2 将秘密与专家 3 共享。\n时间 10 ，专家 1 将秘密与专家 5 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。\n```\n\n**示例 2：**\n\n```\n输入：n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\n输出：[0,1,3]\n解释：\n时间 0 ，专家 0 将秘密与专家 3 共享。\n时间 2 ，专家 1 与专家 2 都不知晓这个秘密。\n时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。\n因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。\n```\n\n**示例 3：**\n\n```\n输入：n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\n输出：[0,1,2,3,4]\n解释：\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。\n注意，专家 2 可以在收到秘密的同一时间分享此秘密。\n时间 2 ，专家 3 将秘密与专家 4 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。\n```\n\n**示例 4：**\n\n```\n输入：n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1\n输出：[0,1,2,3]\n解释：\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 1 ，专家 0 将秘密与专家 2 共享，专家 1 将秘密与专家 3 共享。\n因此，在所有会议结束后，专家 0、1、2 和 3 都将知晓这个秘密。\n```\n\n**提示：**\n\n-   `2 <= n <= 105`\n-   `1 <= meetings.length <= 105`\n-   `meetings[i].length == 3`\n-   `0 <= xi, yi <= n - 1`\n-   `xi != yi`\n-   `1 <= timei <= 105`\n-   `1 <= firstPerson <= n - 1`\n\n**题解：**\n\n>   并查集，注意需要处理同一时刻的多组会议：\n>\n>   排序完成后，遍历所有时刻。同一时刻可能存在多场会议，由于秘密共享是瞬时发生的，且同一时刻的会议是乱序的，不存在先后，所以对每一时刻的处理分为两步：\n>\n>   第一轮遍历：首先判断两位专家中是否有人知道秘密，若有人知道秘密，则将两位专家的祖先节点都置为0。完成该操作后，无论两位专家是否有人知道秘密，都将两个专家合并，因为同一时刻的其他会议中，可能有其他知道秘密的专家将秘密分享给这两位中的任何一个，若存在此情况，则当前时刻过后，这两位专家也知道了秘密。\n>   第二轮遍历：处理两种情况，\n>   场景一：第一轮遍历中，先遍历到某场会议，此时两位专家都不知道秘密，但在后面的遍历中，其中一位专家知道了秘密，由于上一步做了合并集合处理，此时将两位专家的祖先节点均置为0即可。\n>   场景二：第一轮遍历中，先遍历到某场会议，此时两位专家都不知道秘密，在后面的遍历中，这两位专家均没有被分享秘密，这时需要将两位专家从合并的集合中分离出来，如果不分离出来，在后面某时刻，如果这两位专家其中一个知道了秘密，那么会认为这两位专家都知道了秘密，但事实上，由于该时刻已过去，秘密无法分享给另一位专家。示例2即为此情况。\n>\n>   作者：fudan\n>   链接：https://leetcode-cn.com/problems/find-all-people-with-secret/solution/bing-cha-ji-pai-xu-javashuang-bai-xiang-5gbrx/\n>   来源：力扣（LeetCode）\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n>   比赛最后提交的代码有一个巨他妈傻逼的 bug：要按照时间排序的场景，我他妈居然用了 HashMap 而不是 BTreeMap。差点就 AK 了草啊\n\n```rust\nuse std::collections::BTreeMap;\n\nstruct DisjointSet {\n    parent: Vec<usize>,\n    rank: Vec<i32>,\n    known: Vec<i32>,\n}\n\nimpl DisjointSet {\n    #[inline]\n    fn with_capacity(cap: usize) -> Self {\n        Self {\n            parent: (0..=cap).collect(),\n            rank: vec![0; cap + 1],\n            known: vec![i32::MAX; cap + 1]\n        }\n    }\n\n    pub fn find(&mut self, u: usize) -> usize {\n        if u != self.parent[u] {\n            self.parent[u] = self.find(self.parent[u]);\n        }\n        self.parent[u]\n    }\n\n    pub fn union(&mut self, u: usize, v: usize, t: i32) -> bool {\n        let (mut fu, mut fv) = (self.find(u), self.find(v));\n        if fu == fv && (self.known[u] > t && self.known[v] > t) {\n            false\n        } else {\n            if self.rank[fu] > self.rank[fv] {\n                std::mem::swap(&mut fu, &mut fv);\n            }\n            self.parent[fu] = fv;\n            if self.rank[fu] == self.rank[fv] {\n                self.rank[fv] += 1;\n            }\n            let time = self.known[u].min(self.known[v]);\n            self.known[u] = time;\n            self.known[v] = time;\n            true\n        }\n    }\n}\n\nimpl Solution {\n    pub fn find_all_people(n: i32,  mut meetings: Vec<Vec<i32>>, first_person: i32) -> Vec<i32> {\n        let mut dsj = DisjointSet::with_capacity(n as usize);\n        meetings.sort_by(|lhs, rhs| lhs[2].cmp(&rhs[2]));\n        let mut mp = BTreeMap::new();\n        for meet in meetings {\n            (*mp.entry(meet[2]).or_insert(vec![])).push(vec![meet[0], meet[1]]);\n        }\n        dsj.known[first_person as usize] = 0;\n        dsj.known[0] = 0;\n        for (time, meet) in mp {\n            for m in meet.iter() {\n                dsj.union(m[0] as usize, m[1] as usize, time);\n            }\n            for m in meet.iter().rev() {\n                dsj.union(m[0] as usize, m[1] as usize, time);\n            }\n        }\n        dsj.known.into_iter().enumerate()\n            .filter(|&(_, t)| t != i32::MAX)\n            .map(|(idx, _)| idx as i32)\n            .collect()\n    }\n}\n```\n\n>   参考题解，较为精炼的处理重复时间的方法\n\n```rust\nuse std::collections::BTreeMap;\n\nimpl Solution {\n    pub fn find_all_people(n: i32,  meetings: Vec<Vec<i32>>, first_person: i32) -> Vec<i32> {\n        fn find(tar: usize, parent: &mut Vec<usize>) -> usize {\n            if tar != parent[tar] {\n                parent[tar] = find(parent[tar], parent);\n            }\n            parent[tar]\n        }\n        let mut parent = (0..=n as usize).collect::<Vec<_>>();\n        parent[first_person as usize] = 0;\n        let mut mp = BTreeMap::new();\n        for meet in meetings {\n            (*mp.entry(meet[2]).or_insert(vec![])).push((meet[0] as usize, meet[1] as usize))\n        }\n        for (_, pairs) in mp {\n            for &(u, v) in pairs.iter() {\n                let (fu, fv) = (find(u, &mut parent), find(v, &mut parent));\n                if parent[fu] == 0 || parent[fv] == 0 {\n                    parent[fu] = 0;\n                    parent[fv] = 0;\n                }\n                parent[fu] = parent[fv];\n            }\n            for &(u, v) in pairs.iter() {\n                let (fu, fv) = (find(u, &mut parent), find(v, &mut parent));\n                if parent[fu] == 0 || parent[fv] == 0 {\n                    parent[fu] = 0;\n                    parent[fv] = 0;\n                } else {\n                    parent[u] = u;\n                    parent[v] = v;\n                }\n            }\n        }\n        parent.into_iter().enumerate()\n            .filter(|&(_, p)| p == 0 )\n            .map(|(idx, _)| idx as i32 )\n            .collect()\n    }\n}\n```\n\n>   另外这一题也有 Dijkstra 解法\n\n>   把所有会议连接关系当成一张网络图，离源点的距离表示知道秘密的时间，对每个节点求最早知道时间。\n>   前驱节点的最早知道时间，要小于等于和它开会的后序节点的时间，才能通知到后序节点的那个人。\n>   答案为距离更新过的节点。\n>\n>   作者：Mountain-Ocean\n>   链接：https://leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/\n>   来源：力扣（LeetCode）\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```c++\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\n        vector<int> ans;\n        vector<int> dis(n, INT_MAX);\n        vector<vector<PII>> graph(n);\n        for (auto& list : meetings) {\n            int a = list[0], b = list[1], t = list[2];\n            graph[a].push_back({b, t});\n            graph[b].push_back({a, t});\n        }\n        dijkstra(graph, dis, firstPerson);\n        for (int i = 0; i < n; ++i) {\n            if (dis[i] != INT_MAX) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n\n    void dijkstra(vector<vector<PII>>& graph, vector<int>& dis, int start) {\n        priority_queue<PII, vector<PII>, greater<PII>> pq;\n        pq.push({0, 0});\n        pq.push({0, start});\n        dis[0] = 0;\n        dis[start] = 0;\n        while (!pq.empty()) {\n            auto [t, u] = pq.top();\n            pq.pop();\n            if (t > dis[u]) continue;\n            for (auto [v, time] : graph[u]) {\n                // t <= time: 前驱节点的最早知道时间，要小于等于和它开会的后序节点的时间\n                if (t <= time && time < dis[v]) {\n                    dis[v] = time;\n                    pq.push({time, v});\n                }\n            }\n        }\n    }\n};\n\n作者：Mountain-Ocean\n链接：https://leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","source":"_posts/weekly-contest-269.md","raw":"---\ntitle: LeetCode 周赛 269\ndate: 2021-11-28 21:05:37\ntags: LeetCode 周赛\n---\n\n----------\n\n# LeetCode 周赛 268\n\n| 排名        | 用户名       | 得分 | 完成时间 | [题目1 (3)](https://leetcode-cn.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/) | [题目2 (4)](https://leetcode-cn.com/contest/weekly-contest-269/problems/k-radius-subarray-averages/) | [题目3 (5)](https://leetcode-cn.com/contest/weekly-contest-269/problems/removing-minimum-and-maximum-from-array/) | [题目4 (6)](https://leetcode-cn.com/contest/weekly-contest-269/problems/find-all-people-with-secret/) |\n| ----------- | ------------ | ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1340 / 4292 | MiracleSNeko | 12   | 0:40:39  | 0:01:58                                                      | 0:16:32 1                                                    | 0:35:39                                                      |                                                              |\n\n>   手速慢了是真没办法\n\n## T1 5938. 找出数组排序后的目标下标\n\n-   **User Accepted:**3482\n-   **User Tried:**3512\n-   **Total Accepted:**3520\n-   **Total Submissions:**4023\n-   **Difficulty:** **Easy**\n\n给你一个下标从 **0** 开始的整数数组 `nums` 以及一个目标元素 `target` 。\n\n**目标下标** 是一个满足 `nums[i] == target` 的下标 `i` 。\n\n将 `nums` 按 **非递减** 顺序排序后，返回由 `nums` 中目标下标组成的列表。如果不存在目标下标，返回一个 **空** 列表。返回的列表必须按 **递增** 顺序排列。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,5,2,3], target = 2\n输出：[1,2]\n解释：排序后，nums 变为 [1,2,2,3,5] 。\n满足 nums[i] == 2 的下标是 1 和 2 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,5,2,3], target = 3\n输出：[3]\n解释：排序后，nums 变为 [1,2,2,3,5] 。\n满足 nums[i] == 3 的下标是 3 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,2,5,2,3], target = 5\n输出：[4]\n解释：排序后，nums 变为 [1,2,2,3,5] 。\n满足 nums[i] == 5 的下标是 4 。\n```\n\n**示例 4：**\n\n```\n输入：nums = [1,2,5,2,3], target = 4\n输出：[]\n解释：nums 中不含值为 4 的元素。\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 100`\n-   `1 <= nums[i], target <= 100`\n\n**提交：**\n\n```rust\nimpl Solution {\n    pub fn target_indices(mut nums: Vec<i32>, target: i32) -> Vec<i32> {\n        nums.sort();\n        nums.iter().enumerate()\n            .filter(|(_, &v)| v == target)\n            .map(|(idx, _)| idx as i32)\n            .collect()\n    }\n}\n```\n\n## T2 5939. 半径为 k 的子数组平均值\n\n-   **User Accepted:**2893\n-   **User Tried:**3329\n-   **Total Accepted:**2923\n-   **Total Submissions:**9155\n-   **Difficulty:** **Medium**\n\n给你一个下标从 **0** 开始的数组 `nums` ，数组中有 `n` 个整数，另给你一个整数 `k` 。\n\n**半径为 k 的子数组平均值** 是指：`nums` 中一个以下标 `i` 为 **中心** 且 **半径** 为 `k` 的子数组中所有元素的平均值，即下标在 `i - k` 和 `i + k` 范围（**含** `i - k` 和 `i + k`）内所有元素的平均值。如果在下标 `i` 前或后不足 `k` 个元素，那么 **半径为 k 的子数组平均值** 是 `-1` 。\n\n构建并返回一个长度为 `n` 的数组 `avgs` ，其中 `avgs[i]` 是以下标 `i` 为中心的子数组的 **半径为 k 的子数组平均值** 。\n\n`x` 个元素的 **平均值** 是 `x` 个元素相加之和除以 `x` ，此时使用截断式 **整数除法** ，即需要去掉结果的小数部分。\n\n-   例如，四个元素 `2`、`3`、`1` 和 `5` 的平均值是 `(2 + 3 + 1 + 5) / 4 = 11 / 4 = 3.75`，截断后得到 `3` 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/11/07/eg1.png)\n\n```\n输入：nums = [7,4,3,9,1,8,5,2,6], k = 3\n输出：[-1,-1,-1,5,4,4,-1,-1,-1]\n解释：\n- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。\n- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。\n  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。\n- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。\n- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。\n- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n```\n\n**示例 2：**\n\n```\n输入：nums = [100000], k = 0\n输出：[100000]\n解释：\n- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。\n  avg[0] = 100000 / 1 = 100000 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [8], k = 100000\n输出：[-1]\n解释：\n- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n```\n\n**提示：**\n\n-   `n == nums.length`\n-   `1 <= n <= 105`\n-   `0 <= nums[i], k <= 105`\n\n>   注意前缀和 $10^5 \\times 10^5$ 是会爆 `i32` 的！！！\n\n```rust\nimpl Solution {\n    pub fn watering_plants(plants: Vec<i32>, capacity: i32) -> i32 {\n        let mut steps = 1;\n        let mut i = 0;\n        let mut rest = capacity;\n        while i != plants.len() - 1 {\n            rest -= plants[i];\n            // next\n            if rest >= plants[i + 1] {\n                steps += 1;\n            }\n            // back\n            else {\n                steps += 1 + 2 * (i + 1);\n                rest = capacity;\n            }\n            i += 1;\n        }\n        steps as i32\n    }\n}\n```\n\n## T3 5940. 从数组中移除最大值和最小值\n\n-   **User Accepted:**2832\n-   **User Tried:**3041\n-   **Total Accepted:**2870\n-   **Total Submissions:**5009\n-   **Difficulty:** **Medium**\n\n给你一个下标从 **0** 开始的数组 `nums` ，数组由若干 **互不相同** 的整数组成。\n\n`nums` 中有一个值最小的元素和一个值最大的元素。分别称为 **最小值** 和 **最大值** 。你的目标是从数组中移除这两个元素。\n\n一次 **删除** 操作定义为从数组的 **前面** 移除一个元素或从数组的 **后面** 移除一个元素。\n\n返回将数组中最小值和最大值 **都** 移除需要的最小删除次数。 \n\n**示例 1：**\n\n```\n输入：nums = [2,10,7,5,4,1,8,6]\n输出：5\n解释：\n数组中的最小元素是 nums[5] ，值为 1 。\n数组中的最大元素是 nums[1] ，值为 10 。\n将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。\n结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,-4,19,1,8,-2,-3,5]\n输出：3\n解释：\n数组中的最小元素是 nums[1] ，值为 -4 。\n数组中的最大元素是 nums[2] ，值为 19 。\n将最大值和最小值都移除需要从数组前面移除 3 个元素。\n结果是 3 ，这是所有可能情况中的最小删除次数。 \n```\n\n**示例 3：**\n\n```\n输入：nums = [101]\n输出：1\n解释：\n数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。\n移除它只需要 1 次删除操作。\n```\n\n**提示：**\n\n-   `1 <= nums.length <= 105`\n-   `-105 <= nums[i] <= 105`\n-   `nums` 中的整数 **互不相同**\n\n>   只有都从左边、都从右边、一左一右三种情况\n\n```rust\nimpl Solution {\n    pub fn minimum_deletions(nums: Vec<i32>) -> i32 {\n        let mut maxpos = nums.iter().enumerate().max_by_key(|item| item.1).unwrap().0;\n        let mut minpos = nums.iter().enumerate().min_by_key(|item| item.1).unwrap().0;\n        let len = nums.len();\n        if maxpos < minpos {\n            std::mem::swap(&mut maxpos, &mut minpos);\n        }\n        let (l, r, m) = (minpos + 1, len - maxpos, maxpos - minpos);\n        (l + r).min((l + m).min(r + m)) as i32\n    }\n}\n```\n\n## T4 5941. 找出知晓秘密的所有专家\n\n-   **User Accepted:**648\n-   **User Tried:**1842\n-   **Total Accepted:**756\n-   **Total Submissions:**5755\n-   **Difficulty:** **Hard**\n\n给你一个整数 `n` ，表示有 `n` 个专家从 `0` 到 `n - 1` 编号。另外给你一个下标从 0 开始的二维整数数组 `meetings` ，其中 `meetings[i] = [xi, yi, timei]` 表示专家 `xi` 和专家 `yi` 在时间 `timei` 要开一场会。一个专家可以同时参加 **多场会议** 。最后，给你一个整数 `firstPerson` 。\n\n专家 `0` 有一个 **秘密** ，最初，他在时间 `0` 将这个秘密分享给了专家 `firstPerson` 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 `xi` 在时间 `timei` 时知晓这个秘密，那么他将会与专家 `yi` 分享这个秘密，反之亦然。\n\n秘密共享是 **瞬时发生** 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。\n\n在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 **任何顺序** 返回答案。\n\n**示例 1：**\n\n```\n输入：n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\n输出：[0,1,2,3,5]\n解释：\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 5 ，专家 1 将秘密与专家 2 共享。\n时间 8 ，专家 2 将秘密与专家 3 共享。\n时间 10 ，专家 1 将秘密与专家 5 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。\n```\n\n**示例 2：**\n\n```\n输入：n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\n输出：[0,1,3]\n解释：\n时间 0 ，专家 0 将秘密与专家 3 共享。\n时间 2 ，专家 1 与专家 2 都不知晓这个秘密。\n时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。\n因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。\n```\n\n**示例 3：**\n\n```\n输入：n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\n输出：[0,1,2,3,4]\n解释：\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。\n注意，专家 2 可以在收到秘密的同一时间分享此秘密。\n时间 2 ，专家 3 将秘密与专家 4 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。\n```\n\n**示例 4：**\n\n```\n输入：n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1\n输出：[0,1,2,3]\n解释：\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 1 ，专家 0 将秘密与专家 2 共享，专家 1 将秘密与专家 3 共享。\n因此，在所有会议结束后，专家 0、1、2 和 3 都将知晓这个秘密。\n```\n\n**提示：**\n\n-   `2 <= n <= 105`\n-   `1 <= meetings.length <= 105`\n-   `meetings[i].length == 3`\n-   `0 <= xi, yi <= n - 1`\n-   `xi != yi`\n-   `1 <= timei <= 105`\n-   `1 <= firstPerson <= n - 1`\n\n**题解：**\n\n>   并查集，注意需要处理同一时刻的多组会议：\n>\n>   排序完成后，遍历所有时刻。同一时刻可能存在多场会议，由于秘密共享是瞬时发生的，且同一时刻的会议是乱序的，不存在先后，所以对每一时刻的处理分为两步：\n>\n>   第一轮遍历：首先判断两位专家中是否有人知道秘密，若有人知道秘密，则将两位专家的祖先节点都置为0。完成该操作后，无论两位专家是否有人知道秘密，都将两个专家合并，因为同一时刻的其他会议中，可能有其他知道秘密的专家将秘密分享给这两位中的任何一个，若存在此情况，则当前时刻过后，这两位专家也知道了秘密。\n>   第二轮遍历：处理两种情况，\n>   场景一：第一轮遍历中，先遍历到某场会议，此时两位专家都不知道秘密，但在后面的遍历中，其中一位专家知道了秘密，由于上一步做了合并集合处理，此时将两位专家的祖先节点均置为0即可。\n>   场景二：第一轮遍历中，先遍历到某场会议，此时两位专家都不知道秘密，在后面的遍历中，这两位专家均没有被分享秘密，这时需要将两位专家从合并的集合中分离出来，如果不分离出来，在后面某时刻，如果这两位专家其中一个知道了秘密，那么会认为这两位专家都知道了秘密，但事实上，由于该时刻已过去，秘密无法分享给另一位专家。示例2即为此情况。\n>\n>   作者：fudan\n>   链接：https://leetcode-cn.com/problems/find-all-people-with-secret/solution/bing-cha-ji-pai-xu-javashuang-bai-xiang-5gbrx/\n>   来源：力扣（LeetCode）\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n>   比赛最后提交的代码有一个巨他妈傻逼的 bug：要按照时间排序的场景，我他妈居然用了 HashMap 而不是 BTreeMap。差点就 AK 了草啊\n\n```rust\nuse std::collections::BTreeMap;\n\nstruct DisjointSet {\n    parent: Vec<usize>,\n    rank: Vec<i32>,\n    known: Vec<i32>,\n}\n\nimpl DisjointSet {\n    #[inline]\n    fn with_capacity(cap: usize) -> Self {\n        Self {\n            parent: (0..=cap).collect(),\n            rank: vec![0; cap + 1],\n            known: vec![i32::MAX; cap + 1]\n        }\n    }\n\n    pub fn find(&mut self, u: usize) -> usize {\n        if u != self.parent[u] {\n            self.parent[u] = self.find(self.parent[u]);\n        }\n        self.parent[u]\n    }\n\n    pub fn union(&mut self, u: usize, v: usize, t: i32) -> bool {\n        let (mut fu, mut fv) = (self.find(u), self.find(v));\n        if fu == fv && (self.known[u] > t && self.known[v] > t) {\n            false\n        } else {\n            if self.rank[fu] > self.rank[fv] {\n                std::mem::swap(&mut fu, &mut fv);\n            }\n            self.parent[fu] = fv;\n            if self.rank[fu] == self.rank[fv] {\n                self.rank[fv] += 1;\n            }\n            let time = self.known[u].min(self.known[v]);\n            self.known[u] = time;\n            self.known[v] = time;\n            true\n        }\n    }\n}\n\nimpl Solution {\n    pub fn find_all_people(n: i32,  mut meetings: Vec<Vec<i32>>, first_person: i32) -> Vec<i32> {\n        let mut dsj = DisjointSet::with_capacity(n as usize);\n        meetings.sort_by(|lhs, rhs| lhs[2].cmp(&rhs[2]));\n        let mut mp = BTreeMap::new();\n        for meet in meetings {\n            (*mp.entry(meet[2]).or_insert(vec![])).push(vec![meet[0], meet[1]]);\n        }\n        dsj.known[first_person as usize] = 0;\n        dsj.known[0] = 0;\n        for (time, meet) in mp {\n            for m in meet.iter() {\n                dsj.union(m[0] as usize, m[1] as usize, time);\n            }\n            for m in meet.iter().rev() {\n                dsj.union(m[0] as usize, m[1] as usize, time);\n            }\n        }\n        dsj.known.into_iter().enumerate()\n            .filter(|&(_, t)| t != i32::MAX)\n            .map(|(idx, _)| idx as i32)\n            .collect()\n    }\n}\n```\n\n>   参考题解，较为精炼的处理重复时间的方法\n\n```rust\nuse std::collections::BTreeMap;\n\nimpl Solution {\n    pub fn find_all_people(n: i32,  meetings: Vec<Vec<i32>>, first_person: i32) -> Vec<i32> {\n        fn find(tar: usize, parent: &mut Vec<usize>) -> usize {\n            if tar != parent[tar] {\n                parent[tar] = find(parent[tar], parent);\n            }\n            parent[tar]\n        }\n        let mut parent = (0..=n as usize).collect::<Vec<_>>();\n        parent[first_person as usize] = 0;\n        let mut mp = BTreeMap::new();\n        for meet in meetings {\n            (*mp.entry(meet[2]).or_insert(vec![])).push((meet[0] as usize, meet[1] as usize))\n        }\n        for (_, pairs) in mp {\n            for &(u, v) in pairs.iter() {\n                let (fu, fv) = (find(u, &mut parent), find(v, &mut parent));\n                if parent[fu] == 0 || parent[fv] == 0 {\n                    parent[fu] = 0;\n                    parent[fv] = 0;\n                }\n                parent[fu] = parent[fv];\n            }\n            for &(u, v) in pairs.iter() {\n                let (fu, fv) = (find(u, &mut parent), find(v, &mut parent));\n                if parent[fu] == 0 || parent[fv] == 0 {\n                    parent[fu] = 0;\n                    parent[fv] = 0;\n                } else {\n                    parent[u] = u;\n                    parent[v] = v;\n                }\n            }\n        }\n        parent.into_iter().enumerate()\n            .filter(|&(_, p)| p == 0 )\n            .map(|(idx, _)| idx as i32 )\n            .collect()\n    }\n}\n```\n\n>   另外这一题也有 Dijkstra 解法\n\n>   把所有会议连接关系当成一张网络图，离源点的距离表示知道秘密的时间，对每个节点求最早知道时间。\n>   前驱节点的最早知道时间，要小于等于和它开会的后序节点的时间，才能通知到后序节点的那个人。\n>   答案为距离更新过的节点。\n>\n>   作者：Mountain-Ocean\n>   链接：https://leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/\n>   来源：力扣（LeetCode）\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```c++\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\n        vector<int> ans;\n        vector<int> dis(n, INT_MAX);\n        vector<vector<PII>> graph(n);\n        for (auto& list : meetings) {\n            int a = list[0], b = list[1], t = list[2];\n            graph[a].push_back({b, t});\n            graph[b].push_back({a, t});\n        }\n        dijkstra(graph, dis, firstPerson);\n        for (int i = 0; i < n; ++i) {\n            if (dis[i] != INT_MAX) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n\n    void dijkstra(vector<vector<PII>>& graph, vector<int>& dis, int start) {\n        priority_queue<PII, vector<PII>, greater<PII>> pq;\n        pq.push({0, 0});\n        pq.push({0, start});\n        dis[0] = 0;\n        dis[start] = 0;\n        while (!pq.empty()) {\n            auto [t, u] = pq.top();\n            pq.pop();\n            if (t > dis[u]) continue;\n            for (auto [v, time] : graph[u]) {\n                // t <= time: 前驱节点的最早知道时间，要小于等于和它开会的后序节点的时间\n                if (t <= time && time < dis[v]) {\n                    dis[v] = time;\n                    pq.push({time, v});\n                }\n            }\n        }\n    }\n};\n\n作者：Mountain-Ocean\n链接：https://leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","slug":"weekly-contest-269","published":1,"updated":"2021-11-28T14:34:14.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwjchw4i0000vwy56q7fcdxx","content":"<hr>\n<h1 id=\"LeetCode-周赛-268\"><a href=\"#LeetCode-周赛-268\" class=\"headerlink\" title=\"LeetCode 周赛 268\"></a>LeetCode 周赛 268</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-269/problems/k-radius-subarray-averages/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-269/problems/removing-minimum-and-maximum-from-array/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-269/problems/find-all-people-with-secret/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1340 / 4292</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>0:40:39</td>\n<td>0:01:58</td>\n<td>0:16:32 1</td>\n<td>0:35:39</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>  手速慢了是真没办法</p>\n</blockquote>\n<h2 id=\"T1-5938-找出数组排序后的目标下标\"><a href=\"#T1-5938-找出数组排序后的目标下标\" class=\"headerlink\" title=\"T1 5938. 找出数组排序后的目标下标\"></a>T1 5938. 找出数组排序后的目标下标</h2><ul>\n<li>  **User Accepted:**3482</li>\n<li>  **User Tried:**3512</li>\n<li>  **Total Accepted:**3520</li>\n<li>  **Total Submissions:**4023</li>\n<li>  <strong>Difficulty:</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 以及一个目标元素 <code>target</code> 。</p>\n<p><strong>目标下标</strong> 是一个满足 <code>nums[i] == target</code> 的下标 <code>i</code> 。</p>\n<p>将 <code>nums</code> 按 <strong>非递减</strong> 顺序排序后，返回由 <code>nums</code> 中目标下标组成的列表。如果不存在目标下标，返回一个 <strong>空</strong> 列表。返回的列表必须按 <strong>递增</strong> 顺序排列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,5,2,3], target = 2</span><br><span class=\"line\">输出：[1,2]</span><br><span class=\"line\">解释：排序后，nums 变为 [1,2,2,3,5] 。</span><br><span class=\"line\">满足 nums[i] == 2 的下标是 1 和 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,5,2,3], target = 3</span><br><span class=\"line\">输出：[3]</span><br><span class=\"line\">解释：排序后，nums 变为 [1,2,2,3,5] 。</span><br><span class=\"line\">满足 nums[i] == 3 的下标是 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,5,2,3], target = 5</span><br><span class=\"line\">输出：[4]</span><br><span class=\"line\">解释：排序后，nums 变为 [1,2,2,3,5] 。</span><br><span class=\"line\">满足 nums[i] == 5 的下标是 4 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,5,2,3], target = 4</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：nums 中不含值为 4 的元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 100</code></li>\n<li>  <code>1 &lt;= nums[i], target &lt;= 100</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">target_indices</span></span>(<span class=\"keyword\">mut</span> nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, target: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        nums.sort();</span><br><span class=\"line\">        nums.iter().enumerate()</span><br><span class=\"line\">            .filter(|(_, &amp;v)| v == target)</span><br><span class=\"line\">            .map(|(idx, _)| idx <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            .collect()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-5939-半径为-k-的子数组平均值\"><a href=\"#T2-5939-半径为-k-的子数组平均值\" class=\"headerlink\" title=\"T2 5939. 半径为 k 的子数组平均值\"></a>T2 5939. 半径为 k 的子数组平均值</h2><ul>\n<li>  **User Accepted:**2893</li>\n<li>  **User Tried:**3329</li>\n<li>  **Total Accepted:**2923</li>\n<li>  **Total Submissions:**9155</li>\n<li>  <strong>Difficulty:</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p>\n<p><strong>半径为 k 的子数组平均值</strong> 是指：<code>nums</code> 中一个以下标 <code>i</code> 为 <strong>中心</strong> 且 <strong>半径</strong> 为 <code>k</code> 的子数组中所有元素的平均值，即下标在 <code>i - k</code> 和 <code>i + k</code> 范围（<strong>含</strong> <code>i - k</code> 和 <code>i + k</code>）内所有元素的平均值。如果在下标 <code>i</code> 前或后不足 <code>k</code> 个元素，那么 <strong>半径为 k 的子数组平均值</strong> 是 <code>-1</code> 。</p>\n<p>构建并返回一个长度为 <code>n</code> 的数组 <code>avgs</code> ，其中 <code>avgs[i]</code> 是以下标 <code>i</code> 为中心的子数组的 <strong>半径为 k 的子数组平均值</strong> 。</p>\n<p><code>x</code> 个元素的 <strong>平均值</strong> 是 <code>x</code> 个元素相加之和除以 <code>x</code> ，此时使用截断式 <strong>整数除法</strong> ，即需要去掉结果的小数部分。</p>\n<ul>\n<li>例如，四个元素 <code>2</code>、<code>3</code>、<code>1</code> 和 <code>5</code> 的平均值是 <code>(2 + 3 + 1 + 5) / 4 = 11 / 4 = 3.75</code>，截断后得到 <code>3</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/07/eg1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [7,4,3,9,1,8,5,2,6], k = 3</span><br><span class=\"line\">输出：[-1,-1,-1,5,4,4,-1,-1,-1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。</span><br><span class=\"line\">- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。</span><br><span class=\"line\">  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。</span><br><span class=\"line\">- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。</span><br><span class=\"line\">- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。</span><br><span class=\"line\">- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [100000], k = 0</span><br><span class=\"line\">输出：[100000]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。</span><br><span class=\"line\">  avg[0] = 100000 / 1 = 100000 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [8], k = 100000</span><br><span class=\"line\">输出：[-1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == nums.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>0 &lt;= nums[i], k &lt;= 105</code></li>\n</ul>\n<blockquote>\n<p>  注意前缀和 $10^5 \\times 10^5$ 是会爆 <code>i32</code> 的！！！</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">watering_plants</span></span>(plants: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, capacity: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> steps = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> rest = capacity;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != plants.len() - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            rest -= plants[i];</span><br><span class=\"line\">            <span class=\"comment\">// next</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> rest &gt;= plants[i + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">                steps += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// back</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                steps += <span class=\"number\">1</span> + <span class=\"number\">2</span> * (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                rest = capacity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        steps <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T3-5940-从数组中移除最大值和最小值\"><a href=\"#T3-5940-从数组中移除最大值和最小值\" class=\"headerlink\" title=\"T3 5940. 从数组中移除最大值和最小值\"></a>T3 5940. 从数组中移除最大值和最小值</h2><ul>\n<li>  **User Accepted:**2832</li>\n<li>  **User Tried:**3041</li>\n<li>  **Total Accepted:**2870</li>\n<li>  **Total Submissions:**5009</li>\n<li>  <strong>Difficulty:</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组由若干 <strong>互不相同</strong> 的整数组成。</p>\n<p><code>nums</code> 中有一个值最小的元素和一个值最大的元素。分别称为 <strong>最小值</strong> 和 <strong>最大值</strong> 。你的目标是从数组中移除这两个元素。</p>\n<p>一次 <strong>删除</strong> 操作定义为从数组的 <strong>前面</strong> 移除一个元素或从数组的 <strong>后面</strong> 移除一个元素。</p>\n<p>返回将数组中最小值和最大值 <strong>都</strong> 移除需要的最小删除次数。 </p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,10,7,5,4,1,8,6]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：</span><br><span class=\"line\">数组中的最小元素是 nums[5] ，值为 1 。</span><br><span class=\"line\">数组中的最大元素是 nums[1] ，值为 10 。</span><br><span class=\"line\">将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。</span><br><span class=\"line\">结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,-4,19,1,8,-2,-3,5]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">数组中的最小元素是 nums[1] ，值为 -4 。</span><br><span class=\"line\">数组中的最大元素是 nums[2] ，值为 19 。</span><br><span class=\"line\">将最大值和最小值都移除需要从数组前面移除 3 个元素。</span><br><span class=\"line\">结果是 3 ，这是所有可能情况中的最小删除次数。 </span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [101]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。</span><br><span class=\"line\">移除它只需要 1 次删除操作。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>-105 &lt;= nums[i] &lt;= 105</code></li>\n<li>  <code>nums</code> 中的整数 <strong>互不相同</strong></li>\n</ul>\n<blockquote>\n<p>  只有都从左边、都从右边、一左一右三种情况</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">minimum_deletions</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> maxpos = nums.iter().enumerate().max_by_key(|item| item.<span class=\"number\">1</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> minpos = nums.iter().enumerate().min_by_key(|item| item.<span class=\"number\">1</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = nums.len();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> maxpos &lt; minpos &#123;</span><br><span class=\"line\">            std::mem::swap(&amp;<span class=\"keyword\">mut</span> maxpos, &amp;<span class=\"keyword\">mut</span> minpos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (l, r, m) = (minpos + <span class=\"number\">1</span>, len - maxpos, maxpos - minpos);</span><br><span class=\"line\">        (l + r).min((l + m).min(r + m)) <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-5941-找出知晓秘密的所有专家\"><a href=\"#T4-5941-找出知晓秘密的所有专家\" class=\"headerlink\" title=\"T4 5941. 找出知晓秘密的所有专家\"></a>T4 5941. 找出知晓秘密的所有专家</h2><ul>\n<li>  **User Accepted:**648</li>\n<li>  **User Tried:**1842</li>\n<li>  **Total Accepted:**756</li>\n<li>  **Total Submissions:**5755</li>\n<li>  <strong>Difficulty:</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code> 编号。另外给你一个下标从 0 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [xi, yi, timei]</code> 表示专家 <code>xi</code> 和专家 <code>yi</code> 在时间 <code>timei</code> 要开一场会。一个专家可以同时参加 <strong>多场会议</strong> 。最后，给你一个整数 <code>firstPerson</code> 。</p>\n<p>专家 <code>0</code> 有一个 <strong>秘密</strong> ，最初，他在时间 <code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>xi</code> 在时间 <code>timei</code> 时知晓这个秘密，那么他将会与专家 <code>yi</code> 分享这个秘密，反之亦然。</p>\n<p>秘密共享是 <strong>瞬时发生</strong> 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p>\n<p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1</span><br><span class=\"line\">输出：[0,1,2,3,5]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间 0 ，专家 0 将秘密与专家 1 共享。</span><br><span class=\"line\">时间 5 ，专家 1 将秘密与专家 2 共享。</span><br><span class=\"line\">时间 8 ，专家 2 将秘密与专家 3 共享。</span><br><span class=\"line\">时间 10 ，专家 1 将秘密与专家 5 共享。</span><br><span class=\"line\">因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3</span><br><span class=\"line\">输出：[0,1,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间 0 ，专家 0 将秘密与专家 3 共享。</span><br><span class=\"line\">时间 2 ，专家 1 与专家 2 都不知晓这个秘密。</span><br><span class=\"line\">时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。</span><br><span class=\"line\">因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1</span><br><span class=\"line\">输出：[0,1,2,3,4]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间 0 ，专家 0 将秘密与专家 1 共享。</span><br><span class=\"line\">时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。</span><br><span class=\"line\">注意，专家 2 可以在收到秘密的同一时间分享此秘密。</span><br><span class=\"line\">时间 2 ，专家 3 将秘密与专家 4 共享。</span><br><span class=\"line\">因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1</span><br><span class=\"line\">输出：[0,1,2,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间 0 ，专家 0 将秘密与专家 1 共享。</span><br><span class=\"line\">时间 1 ，专家 0 将秘密与专家 2 共享，专家 1 将秘密与专家 3 共享。</span><br><span class=\"line\">因此，在所有会议结束后，专家 0、1、2 和 3 都将知晓这个秘密。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  <code>1 &lt;= meetings.length &lt;= 105</code></li>\n<li>  <code>meetings[i].length == 3</code></li>\n<li>  <code>0 &lt;= xi, yi &lt;= n - 1</code></li>\n<li>  <code>xi != yi</code></li>\n<li>  <code>1 &lt;= timei &lt;= 105</code></li>\n<li>  <code>1 &lt;= firstPerson &lt;= n - 1</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  并查集，注意需要处理同一时刻的多组会议：</p>\n<p>  排序完成后，遍历所有时刻。同一时刻可能存在多场会议，由于秘密共享是瞬时发生的，且同一时刻的会议是乱序的，不存在先后，所以对每一时刻的处理分为两步：</p>\n<p>  第一轮遍历：首先判断两位专家中是否有人知道秘密，若有人知道秘密，则将两位专家的祖先节点都置为0。完成该操作后，无论两位专家是否有人知道秘密，都将两个专家合并，因为同一时刻的其他会议中，可能有其他知道秘密的专家将秘密分享给这两位中的任何一个，若存在此情况，则当前时刻过后，这两位专家也知道了秘密。<br>  第二轮遍历：处理两种情况，<br>  场景一：第一轮遍历中，先遍历到某场会议，此时两位专家都不知道秘密，但在后面的遍历中，其中一位专家知道了秘密，由于上一步做了合并集合处理，此时将两位专家的祖先节点均置为0即可。<br>  场景二：第一轮遍历中，先遍历到某场会议，此时两位专家都不知道秘密，在后面的遍历中，这两位专家均没有被分享秘密，这时需要将两位专家从合并的集合中分离出来，如果不分离出来，在后面某时刻，如果这两位专家其中一个知道了秘密，那么会认为这两位专家都知道了秘密，但事实上，由于该时刻已过去，秘密无法分享给另一位专家。示例2即为此情况。</p>\n<p>  作者：fudan<br>  链接：<a href=\"https://leetcode-cn.com/problems/find-all-people-with-secret/solution/bing-cha-ji-pai-xu-javashuang-bai-xiang-5gbrx/\">https://leetcode-cn.com/problems/find-all-people-with-secret/solution/bing-cha-ji-pai-xu-javashuang-bai-xiang-5gbrx/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<blockquote>\n<p>  比赛最后提交的代码有一个巨他妈傻逼的 bug：要按照时间排序的场景，我他妈居然用了 HashMap 而不是 BTreeMap。差点就 AK 了草啊</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::BTreeMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DisjointSet</span></span> &#123;</span><br><span class=\"line\">    parent: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    rank: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;,</span><br><span class=\"line\">    known: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> DisjointSet &#123;</span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            parent: (<span class=\"number\">0</span>..=cap).collect(),</span><br><span class=\"line\">            rank: <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; cap + <span class=\"number\">1</span>],</span><br><span class=\"line\">            known: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; cap + <span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, u: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> u != <span class=\"keyword\">self</span>.parent[u] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[u] = <span class=\"keyword\">self</span>.find(<span class=\"keyword\">self</span>.parent[u]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent[u]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">union</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, u: <span class=\"built_in\">usize</span>, v: <span class=\"built_in\">usize</span>, t: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> fu, <span class=\"keyword\">mut</span> fv) = (<span class=\"keyword\">self</span>.find(u), <span class=\"keyword\">self</span>.find(v));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fu == fv &amp;&amp; (<span class=\"keyword\">self</span>.known[u] &gt; t &amp;&amp; <span class=\"keyword\">self</span>.known[v] &gt; t) &#123;</span><br><span class=\"line\">            <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fu] &gt; <span class=\"keyword\">self</span>.rank[fv] &#123;</span><br><span class=\"line\">                std::mem::swap(&amp;<span class=\"keyword\">mut</span> fu, &amp;<span class=\"keyword\">mut</span> fv);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[fu] = fv;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fu] == <span class=\"keyword\">self</span>.rank[fv] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.rank[fv] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> time = <span class=\"keyword\">self</span>.known[u].min(<span class=\"keyword\">self</span>.known[v]);</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.known[u] = time;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.known[v] = time;</span><br><span class=\"line\">            <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find_all_people</span></span>(n: <span class=\"built_in\">i32</span>,  <span class=\"keyword\">mut</span> meetings: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;, first_person: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dsj = DisjointSet::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">        meetings.sort_by(|lhs, rhs| lhs[<span class=\"number\">2</span>].cmp(&amp;rhs[<span class=\"number\">2</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mp = BTreeMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> meet <span class=\"keyword\">in</span> meetings &#123;</span><br><span class=\"line\">            (*mp.entry(meet[<span class=\"number\">2</span>]).or_insert(<span class=\"built_in\">vec!</span>[])).push(<span class=\"built_in\">vec!</span>[meet[<span class=\"number\">0</span>], meet[<span class=\"number\">1</span>]]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dsj.known[first_person <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dsj.known[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (time, meet) <span class=\"keyword\">in</span> mp &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> meet.iter() &#123;</span><br><span class=\"line\">                dsj.union(m[<span class=\"number\">0</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, m[<span class=\"number\">1</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> meet.iter().rev() &#123;</span><br><span class=\"line\">                dsj.union(m[<span class=\"number\">0</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, m[<span class=\"number\">1</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dsj.known.into_iter().enumerate()</span><br><span class=\"line\">            .filter(|&amp;(_, t)| t != <span class=\"built_in\">i32</span>::MAX)</span><br><span class=\"line\">            .map(|(idx, _)| idx <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            .collect()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  参考题解，较为精炼的处理重复时间的方法</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::BTreeMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find_all_people</span></span>(n: <span class=\"built_in\">i32</span>,  meetings: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;, first_person: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(tar: <span class=\"built_in\">usize</span>, parent: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tar != parent[tar] &#123;</span><br><span class=\"line\">                parent[tar] = find(parent[tar], parent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            parent[tar]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> parent = (<span class=\"number\">0</span>..=n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        parent[first_person <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mp = BTreeMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> meet <span class=\"keyword\">in</span> meetings &#123;</span><br><span class=\"line\">            (*mp.entry(meet[<span class=\"number\">2</span>]).or_insert(<span class=\"built_in\">vec!</span>[])).push((meet[<span class=\"number\">0</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, meet[<span class=\"number\">1</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (_, pairs) <span class=\"keyword\">in</span> mp &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> &amp;(u, v) <span class=\"keyword\">in</span> pairs.iter() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> (fu, fv) = (find(u, &amp;<span class=\"keyword\">mut</span> parent), find(v, &amp;<span class=\"keyword\">mut</span> parent));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> parent[fu] == <span class=\"number\">0</span> || parent[fv] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    parent[fu] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    parent[fv] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                parent[fu] = parent[fv];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> &amp;(u, v) <span class=\"keyword\">in</span> pairs.iter() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> (fu, fv) = (find(u, &amp;<span class=\"keyword\">mut</span> parent), find(v, &amp;<span class=\"keyword\">mut</span> parent));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> parent[fu] == <span class=\"number\">0</span> || parent[fv] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    parent[fu] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    parent[fv] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    parent[u] = u;</span><br><span class=\"line\">                    parent[v] = v;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent.into_iter().enumerate()</span><br><span class=\"line\">            .filter(|&amp;(_, p)| p == <span class=\"number\">0</span> )</span><br><span class=\"line\">            .map(|(idx, _)| idx <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> )</span><br><span class=\"line\">            .collect()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  另外这一题也有 Dijkstra 解法</p>\n</blockquote>\n<blockquote>\n<p>  把所有会议连接关系当成一张网络图，离源点的距离表示知道秘密的时间，对每个节点求最早知道时间。<br>  前驱节点的最早知道时间，要小于等于和它开会的后序节点的时间，才能通知到后序节点的那个人。<br>  答案为距离更新过的节点。</p>\n<p>  作者：Mountain-Ocean<br>  链接：<a href=\"https://leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/\">https://leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findAllPeople</span><span class=\"params\">(<span class=\"keyword\">int</span> n, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; meetings, <span class=\"keyword\">int</span> firstPerson)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dis</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">        vector&lt;vector&lt;PII&gt;&gt; <span class=\"built_in\">graph</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; list : meetings) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = list[<span class=\"number\">0</span>], b = list[<span class=\"number\">1</span>], t = list[<span class=\"number\">2</span>];</span><br><span class=\"line\">            graph[a].<span class=\"built_in\">push_back</span>(&#123;b, t&#125;);</span><br><span class=\"line\">            graph[b].<span class=\"built_in\">push_back</span>(&#123;a, t&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">dijkstra</span>(graph, dis, firstPerson);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dis[i] != INT_MAX) &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(vector&lt;vector&lt;PII&gt;&gt;&amp; graph, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; dis, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class=\"line\">        pq.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        pq.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, start&#125;);</span><br><span class=\"line\">        dis[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dis[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [t, u] = pq.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &gt; dis[u]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> [v, time] : graph[u]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// t &lt;= time: 前驱节点的最早知道时间，要小于等于和它开会的后序节点的时间</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t &lt;= time &amp;&amp; time &lt; dis[v]) &#123;</span><br><span class=\"line\">                    dis[v] = time;</span><br><span class=\"line\">                    pq.<span class=\"built_in\">push</span>(&#123;time, v&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：Mountain-Ocean</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<hr>\n<h1 id=\"LeetCode-周赛-268\"><a href=\"#LeetCode-周赛-268\" class=\"headerlink\" title=\"LeetCode 周赛 268\"></a>LeetCode 周赛 268</h1><table>\n<thead>\n<tr>\n<th>排名</th>\n<th>用户名</th>\n<th>得分</th>\n<th>完成时间</th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/\">题目1 (3)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-269/problems/k-radius-subarray-averages/\">题目2 (4)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-269/problems/removing-minimum-and-maximum-from-array/\">题目3 (5)</a></th>\n<th><a href=\"https://leetcode-cn.com/contest/weekly-contest-269/problems/find-all-people-with-secret/\">题目4 (6)</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1340 / 4292</td>\n<td>MiracleSNeko</td>\n<td>12</td>\n<td>0:40:39</td>\n<td>0:01:58</td>\n<td>0:16:32 1</td>\n<td>0:35:39</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>  手速慢了是真没办法</p>\n</blockquote>\n<h2 id=\"T1-5938-找出数组排序后的目标下标\"><a href=\"#T1-5938-找出数组排序后的目标下标\" class=\"headerlink\" title=\"T1 5938. 找出数组排序后的目标下标\"></a>T1 5938. 找出数组排序后的目标下标</h2><ul>\n<li>  **User Accepted:**3482</li>\n<li>  **User Tried:**3512</li>\n<li>  **Total Accepted:**3520</li>\n<li>  **Total Submissions:**4023</li>\n<li>  <strong>Difficulty:</strong> <strong>Easy</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 以及一个目标元素 <code>target</code> 。</p>\n<p><strong>目标下标</strong> 是一个满足 <code>nums[i] == target</code> 的下标 <code>i</code> 。</p>\n<p>将 <code>nums</code> 按 <strong>非递减</strong> 顺序排序后，返回由 <code>nums</code> 中目标下标组成的列表。如果不存在目标下标，返回一个 <strong>空</strong> 列表。返回的列表必须按 <strong>递增</strong> 顺序排列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,5,2,3], target = 2</span><br><span class=\"line\">输出：[1,2]</span><br><span class=\"line\">解释：排序后，nums 变为 [1,2,2,3,5] 。</span><br><span class=\"line\">满足 nums[i] == 2 的下标是 1 和 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,5,2,3], target = 3</span><br><span class=\"line\">输出：[3]</span><br><span class=\"line\">解释：排序后，nums 变为 [1,2,2,3,5] 。</span><br><span class=\"line\">满足 nums[i] == 3 的下标是 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,5,2,3], target = 5</span><br><span class=\"line\">输出：[4]</span><br><span class=\"line\">解释：排序后，nums 变为 [1,2,2,3,5] 。</span><br><span class=\"line\">满足 nums[i] == 5 的下标是 4 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,5,2,3], target = 4</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：nums 中不含值为 4 的元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 100</code></li>\n<li>  <code>1 &lt;= nums[i], target &lt;= 100</code></li>\n</ul>\n<p><strong>提交：</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">target_indices</span></span>(<span class=\"keyword\">mut</span> nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, target: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        nums.sort();</span><br><span class=\"line\">        nums.iter().enumerate()</span><br><span class=\"line\">            .filter(|(_, &amp;v)| v == target)</span><br><span class=\"line\">            .map(|(idx, _)| idx <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            .collect()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T2-5939-半径为-k-的子数组平均值\"><a href=\"#T2-5939-半径为-k-的子数组平均值\" class=\"headerlink\" title=\"T2 5939. 半径为 k 的子数组平均值\"></a>T2 5939. 半径为 k 的子数组平均值</h2><ul>\n<li>  **User Accepted:**2893</li>\n<li>  **User Tried:**3329</li>\n<li>  **Total Accepted:**2923</li>\n<li>  **Total Submissions:**9155</li>\n<li>  <strong>Difficulty:</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p>\n<p><strong>半径为 k 的子数组平均值</strong> 是指：<code>nums</code> 中一个以下标 <code>i</code> 为 <strong>中心</strong> 且 <strong>半径</strong> 为 <code>k</code> 的子数组中所有元素的平均值，即下标在 <code>i - k</code> 和 <code>i + k</code> 范围（<strong>含</strong> <code>i - k</code> 和 <code>i + k</code>）内所有元素的平均值。如果在下标 <code>i</code> 前或后不足 <code>k</code> 个元素，那么 <strong>半径为 k 的子数组平均值</strong> 是 <code>-1</code> 。</p>\n<p>构建并返回一个长度为 <code>n</code> 的数组 <code>avgs</code> ，其中 <code>avgs[i]</code> 是以下标 <code>i</code> 为中心的子数组的 <strong>半径为 k 的子数组平均值</strong> 。</p>\n<p><code>x</code> 个元素的 <strong>平均值</strong> 是 <code>x</code> 个元素相加之和除以 <code>x</code> ，此时使用截断式 <strong>整数除法</strong> ，即需要去掉结果的小数部分。</p>\n<ul>\n<li>例如，四个元素 <code>2</code>、<code>3</code>、<code>1</code> 和 <code>5</code> 的平均值是 <code>(2 + 3 + 1 + 5) / 4 = 11 / 4 = 3.75</code>，截断后得到 <code>3</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/07/eg1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [7,4,3,9,1,8,5,2,6], k = 3</span><br><span class=\"line\">输出：[-1,-1,-1,5,4,4,-1,-1,-1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。</span><br><span class=\"line\">- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。</span><br><span class=\"line\">  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。</span><br><span class=\"line\">- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。</span><br><span class=\"line\">- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。</span><br><span class=\"line\">- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [100000], k = 0</span><br><span class=\"line\">输出：[100000]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。</span><br><span class=\"line\">  avg[0] = 100000 / 1 = 100000 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [8], k = 100000</span><br><span class=\"line\">输出：[-1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>n == nums.length</code></li>\n<li>  <code>1 &lt;= n &lt;= 105</code></li>\n<li>  <code>0 &lt;= nums[i], k &lt;= 105</code></li>\n</ul>\n<blockquote>\n<p>  注意前缀和 $10^5 \\times 10^5$ 是会爆 <code>i32</code> 的！！！</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">watering_plants</span></span>(plants: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;, capacity: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> steps = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> rest = capacity;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != plants.len() - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            rest -= plants[i];</span><br><span class=\"line\">            <span class=\"comment\">// next</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> rest &gt;= plants[i + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">                steps += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// back</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                steps += <span class=\"number\">1</span> + <span class=\"number\">2</span> * (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                rest = capacity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        steps <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T3-5940-从数组中移除最大值和最小值\"><a href=\"#T3-5940-从数组中移除最大值和最小值\" class=\"headerlink\" title=\"T3 5940. 从数组中移除最大值和最小值\"></a>T3 5940. 从数组中移除最大值和最小值</h2><ul>\n<li>  **User Accepted:**2832</li>\n<li>  **User Tried:**3041</li>\n<li>  **Total Accepted:**2870</li>\n<li>  **Total Submissions:**5009</li>\n<li>  <strong>Difficulty:</strong> <strong>Medium</strong></li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组由若干 <strong>互不相同</strong> 的整数组成。</p>\n<p><code>nums</code> 中有一个值最小的元素和一个值最大的元素。分别称为 <strong>最小值</strong> 和 <strong>最大值</strong> 。你的目标是从数组中移除这两个元素。</p>\n<p>一次 <strong>删除</strong> 操作定义为从数组的 <strong>前面</strong> 移除一个元素或从数组的 <strong>后面</strong> 移除一个元素。</p>\n<p>返回将数组中最小值和最大值 <strong>都</strong> 移除需要的最小删除次数。 </p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,10,7,5,4,1,8,6]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：</span><br><span class=\"line\">数组中的最小元素是 nums[5] ，值为 1 。</span><br><span class=\"line\">数组中的最大元素是 nums[1] ，值为 10 。</span><br><span class=\"line\">将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。</span><br><span class=\"line\">结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,-4,19,1,8,-2,-3,5]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">数组中的最小元素是 nums[1] ，值为 -4 。</span><br><span class=\"line\">数组中的最大元素是 nums[2] ，值为 19 。</span><br><span class=\"line\">将最大值和最小值都移除需要从数组前面移除 3 个元素。</span><br><span class=\"line\">结果是 3 ，这是所有可能情况中的最小删除次数。 </span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [101]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。</span><br><span class=\"line\">移除它只需要 1 次删除操作。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>1 &lt;= nums.length &lt;= 105</code></li>\n<li>  <code>-105 &lt;= nums[i] &lt;= 105</code></li>\n<li>  <code>nums</code> 中的整数 <strong>互不相同</strong></li>\n</ul>\n<blockquote>\n<p>  只有都从左边、都从右边、一左一右三种情况</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">minimum_deletions</span></span>(nums: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;) -&gt; <span class=\"built_in\">i32</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> maxpos = nums.iter().enumerate().max_by_key(|item| item.<span class=\"number\">1</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> minpos = nums.iter().enumerate().min_by_key(|item| item.<span class=\"number\">1</span>).unwrap().<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = nums.len();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> maxpos &lt; minpos &#123;</span><br><span class=\"line\">            std::mem::swap(&amp;<span class=\"keyword\">mut</span> maxpos, &amp;<span class=\"keyword\">mut</span> minpos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (l, r, m) = (minpos + <span class=\"number\">1</span>, len - maxpos, maxpos - minpos);</span><br><span class=\"line\">        (l + r).min((l + m).min(r + m)) <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"T4-5941-找出知晓秘密的所有专家\"><a href=\"#T4-5941-找出知晓秘密的所有专家\" class=\"headerlink\" title=\"T4 5941. 找出知晓秘密的所有专家\"></a>T4 5941. 找出知晓秘密的所有专家</h2><ul>\n<li>  **User Accepted:**648</li>\n<li>  **User Tried:**1842</li>\n<li>  **Total Accepted:**756</li>\n<li>  **Total Submissions:**5755</li>\n<li>  <strong>Difficulty:</strong> <strong>Hard</strong></li>\n</ul>\n<p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code> 编号。另外给你一个下标从 0 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [xi, yi, timei]</code> 表示专家 <code>xi</code> 和专家 <code>yi</code> 在时间 <code>timei</code> 要开一场会。一个专家可以同时参加 <strong>多场会议</strong> 。最后，给你一个整数 <code>firstPerson</code> 。</p>\n<p>专家 <code>0</code> 有一个 <strong>秘密</strong> ，最初，他在时间 <code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>xi</code> 在时间 <code>timei</code> 时知晓这个秘密，那么他将会与专家 <code>yi</code> 分享这个秘密，反之亦然。</p>\n<p>秘密共享是 <strong>瞬时发生</strong> 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p>\n<p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1</span><br><span class=\"line\">输出：[0,1,2,3,5]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间 0 ，专家 0 将秘密与专家 1 共享。</span><br><span class=\"line\">时间 5 ，专家 1 将秘密与专家 2 共享。</span><br><span class=\"line\">时间 8 ，专家 2 将秘密与专家 3 共享。</span><br><span class=\"line\">时间 10 ，专家 1 将秘密与专家 5 共享。</span><br><span class=\"line\">因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3</span><br><span class=\"line\">输出：[0,1,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间 0 ，专家 0 将秘密与专家 3 共享。</span><br><span class=\"line\">时间 2 ，专家 1 与专家 2 都不知晓这个秘密。</span><br><span class=\"line\">时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。</span><br><span class=\"line\">因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1</span><br><span class=\"line\">输出：[0,1,2,3,4]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间 0 ，专家 0 将秘密与专家 1 共享。</span><br><span class=\"line\">时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。</span><br><span class=\"line\">注意，专家 2 可以在收到秘密的同一时间分享此秘密。</span><br><span class=\"line\">时间 2 ，专家 3 将秘密与专家 4 共享。</span><br><span class=\"line\">因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1</span><br><span class=\"line\">输出：[0,1,2,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">时间 0 ，专家 0 将秘密与专家 1 共享。</span><br><span class=\"line\">时间 1 ，专家 0 将秘密与专家 2 共享，专家 1 将秘密与专家 3 共享。</span><br><span class=\"line\">因此，在所有会议结束后，专家 0、1、2 和 3 都将知晓这个秘密。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>  <code>2 &lt;= n &lt;= 105</code></li>\n<li>  <code>1 &lt;= meetings.length &lt;= 105</code></li>\n<li>  <code>meetings[i].length == 3</code></li>\n<li>  <code>0 &lt;= xi, yi &lt;= n - 1</code></li>\n<li>  <code>xi != yi</code></li>\n<li>  <code>1 &lt;= timei &lt;= 105</code></li>\n<li>  <code>1 &lt;= firstPerson &lt;= n - 1</code></li>\n</ul>\n<p><strong>题解：</strong></p>\n<blockquote>\n<p>  并查集，注意需要处理同一时刻的多组会议：</p>\n<p>  排序完成后，遍历所有时刻。同一时刻可能存在多场会议，由于秘密共享是瞬时发生的，且同一时刻的会议是乱序的，不存在先后，所以对每一时刻的处理分为两步：</p>\n<p>  第一轮遍历：首先判断两位专家中是否有人知道秘密，若有人知道秘密，则将两位专家的祖先节点都置为0。完成该操作后，无论两位专家是否有人知道秘密，都将两个专家合并，因为同一时刻的其他会议中，可能有其他知道秘密的专家将秘密分享给这两位中的任何一个，若存在此情况，则当前时刻过后，这两位专家也知道了秘密。<br>  第二轮遍历：处理两种情况，<br>  场景一：第一轮遍历中，先遍历到某场会议，此时两位专家都不知道秘密，但在后面的遍历中，其中一位专家知道了秘密，由于上一步做了合并集合处理，此时将两位专家的祖先节点均置为0即可。<br>  场景二：第一轮遍历中，先遍历到某场会议，此时两位专家都不知道秘密，在后面的遍历中，这两位专家均没有被分享秘密，这时需要将两位专家从合并的集合中分离出来，如果不分离出来，在后面某时刻，如果这两位专家其中一个知道了秘密，那么会认为这两位专家都知道了秘密，但事实上，由于该时刻已过去，秘密无法分享给另一位专家。示例2即为此情况。</p>\n<p>  作者：fudan<br>  链接：<a href=\"https://leetcode-cn.com/problems/find-all-people-with-secret/solution/bing-cha-ji-pai-xu-javashuang-bai-xiang-5gbrx/\">https://leetcode-cn.com/problems/find-all-people-with-secret/solution/bing-cha-ji-pai-xu-javashuang-bai-xiang-5gbrx/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<blockquote>\n<p>  比赛最后提交的代码有一个巨他妈傻逼的 bug：要按照时间排序的场景，我他妈居然用了 HashMap 而不是 BTreeMap。差点就 AK 了草啊</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::BTreeMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DisjointSet</span></span> &#123;</span><br><span class=\"line\">    parent: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;,</span><br><span class=\"line\">    rank: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;,</span><br><span class=\"line\">    known: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> DisjointSet &#123;</span><br><span class=\"line\">    <span class=\"meta\">#[inline]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_capacity</span></span>(cap: <span class=\"built_in\">usize</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            parent: (<span class=\"number\">0</span>..=cap).collect(),</span><br><span class=\"line\">            rank: <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; cap + <span class=\"number\">1</span>],</span><br><span class=\"line\">            known: <span class=\"built_in\">vec!</span>[<span class=\"built_in\">i32</span>::MAX; cap + <span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, u: <span class=\"built_in\">usize</span>) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> u != <span class=\"keyword\">self</span>.parent[u] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[u] = <span class=\"keyword\">self</span>.find(<span class=\"keyword\">self</span>.parent[u]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent[u]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">union</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, u: <span class=\"built_in\">usize</span>, v: <span class=\"built_in\">usize</span>, t: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (<span class=\"keyword\">mut</span> fu, <span class=\"keyword\">mut</span> fv) = (<span class=\"keyword\">self</span>.find(u), <span class=\"keyword\">self</span>.find(v));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fu == fv &amp;&amp; (<span class=\"keyword\">self</span>.known[u] &gt; t &amp;&amp; <span class=\"keyword\">self</span>.known[v] &gt; t) &#123;</span><br><span class=\"line\">            <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fu] &gt; <span class=\"keyword\">self</span>.rank[fv] &#123;</span><br><span class=\"line\">                std::mem::swap(&amp;<span class=\"keyword\">mut</span> fu, &amp;<span class=\"keyword\">mut</span> fv);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.parent[fu] = fv;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.rank[fu] == <span class=\"keyword\">self</span>.rank[fv] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.rank[fv] += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> time = <span class=\"keyword\">self</span>.known[u].min(<span class=\"keyword\">self</span>.known[v]);</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.known[u] = time;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.known[v] = time;</span><br><span class=\"line\">            <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find_all_people</span></span>(n: <span class=\"built_in\">i32</span>,  <span class=\"keyword\">mut</span> meetings: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;, first_person: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> dsj = DisjointSet::with_capacity(n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>);</span><br><span class=\"line\">        meetings.sort_by(|lhs, rhs| lhs[<span class=\"number\">2</span>].cmp(&amp;rhs[<span class=\"number\">2</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mp = BTreeMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> meet <span class=\"keyword\">in</span> meetings &#123;</span><br><span class=\"line\">            (*mp.entry(meet[<span class=\"number\">2</span>]).or_insert(<span class=\"built_in\">vec!</span>[])).push(<span class=\"built_in\">vec!</span>[meet[<span class=\"number\">0</span>], meet[<span class=\"number\">1</span>]]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dsj.known[first_person <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dsj.known[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (time, meet) <span class=\"keyword\">in</span> mp &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> meet.iter() &#123;</span><br><span class=\"line\">                dsj.union(m[<span class=\"number\">0</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, m[<span class=\"number\">1</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> meet.iter().rev() &#123;</span><br><span class=\"line\">                dsj.union(m[<span class=\"number\">0</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, m[<span class=\"number\">1</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dsj.known.into_iter().enumerate()</span><br><span class=\"line\">            .filter(|&amp;(_, t)| t != <span class=\"built_in\">i32</span>::MAX)</span><br><span class=\"line\">            .map(|(idx, _)| idx <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span>)</span><br><span class=\"line\">            .collect()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  参考题解，较为精炼的处理重复时间的方法</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::BTreeMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find_all_people</span></span>(n: <span class=\"built_in\">i32</span>,  meetings: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;, first_person: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">find</span></span>(tar: <span class=\"built_in\">usize</span>, parent: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;) -&gt; <span class=\"built_in\">usize</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tar != parent[tar] &#123;</span><br><span class=\"line\">                parent[tar] = find(parent[tar], parent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            parent[tar]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> parent = (<span class=\"number\">0</span>..=n <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>).collect::&lt;<span class=\"built_in\">Vec</span>&lt;_&gt;&gt;();</span><br><span class=\"line\">        parent[first_person <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> mp = BTreeMap::new();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> meet <span class=\"keyword\">in</span> meetings &#123;</span><br><span class=\"line\">            (*mp.entry(meet[<span class=\"number\">2</span>]).or_insert(<span class=\"built_in\">vec!</span>[])).push((meet[<span class=\"number\">0</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>, meet[<span class=\"number\">1</span>] <span class=\"keyword\">as</span> <span class=\"built_in\">usize</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (_, pairs) <span class=\"keyword\">in</span> mp &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> &amp;(u, v) <span class=\"keyword\">in</span> pairs.iter() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> (fu, fv) = (find(u, &amp;<span class=\"keyword\">mut</span> parent), find(v, &amp;<span class=\"keyword\">mut</span> parent));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> parent[fu] == <span class=\"number\">0</span> || parent[fv] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    parent[fu] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    parent[fv] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                parent[fu] = parent[fv];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> &amp;(u, v) <span class=\"keyword\">in</span> pairs.iter() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> (fu, fv) = (find(u, &amp;<span class=\"keyword\">mut</span> parent), find(v, &amp;<span class=\"keyword\">mut</span> parent));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> parent[fu] == <span class=\"number\">0</span> || parent[fv] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    parent[fu] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    parent[fv] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    parent[u] = u;</span><br><span class=\"line\">                    parent[v] = v;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent.into_iter().enumerate()</span><br><span class=\"line\">            .filter(|&amp;(_, p)| p == <span class=\"number\">0</span> )</span><br><span class=\"line\">            .map(|(idx, _)| idx <span class=\"keyword\">as</span> <span class=\"built_in\">i32</span> )</span><br><span class=\"line\">            .collect()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  另外这一题也有 Dijkstra 解法</p>\n</blockquote>\n<blockquote>\n<p>  把所有会议连接关系当成一张网络图，离源点的距离表示知道秘密的时间，对每个节点求最早知道时间。<br>  前驱节点的最早知道时间，要小于等于和它开会的后序节点的时间，才能通知到后序节点的那个人。<br>  答案为距离更新过的节点。</p>\n<p>  作者：Mountain-Ocean<br>  链接：<a href=\"https://leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/\">https://leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findAllPeople</span><span class=\"params\">(<span class=\"keyword\">int</span> n, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; meetings, <span class=\"keyword\">int</span> firstPerson)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dis</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">        vector&lt;vector&lt;PII&gt;&gt; <span class=\"built_in\">graph</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; list : meetings) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = list[<span class=\"number\">0</span>], b = list[<span class=\"number\">1</span>], t = list[<span class=\"number\">2</span>];</span><br><span class=\"line\">            graph[a].<span class=\"built_in\">push_back</span>(&#123;b, t&#125;);</span><br><span class=\"line\">            graph[b].<span class=\"built_in\">push_back</span>(&#123;a, t&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">dijkstra</span>(graph, dis, firstPerson);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dis[i] != INT_MAX) &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(vector&lt;vector&lt;PII&gt;&gt;&amp; graph, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; dis, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class=\"line\">        pq.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        pq.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, start&#125;);</span><br><span class=\"line\">        dis[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dis[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [t, u] = pq.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &gt; dis[u]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> [v, time] : graph[u]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// t &lt;= time: 前驱节点的最早知道时间，要小于等于和它开会的后序节点的时间</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t &lt;= time &amp;&amp; time &lt; dis[v]) &#123;</span><br><span class=\"line\">                    dis[v] = time;</span><br><span class=\"line\">                    pq.<span class=\"built_in\">push</span>(&#123;time, v&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：Mountain-Ocean</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/find-all-people-with-secret/solution/dijkstra-by-mountain-ocean-i98l/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckw3kx8ps00011cy5ak93fu82","tag_id":"ckw3kx8pu00031cy586i73a5e","_id":"ckw3kx8px00081cy59fxa68c1"},{"post_id":"ckw3kx8px00091cy53hul3uy4","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q0000c1cy577gi5s3v"},{"post_id":"ckw3kx8pu00021cy5cq0d2frc","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q1000e1cy58lm7f1d7"},{"post_id":"ckw3kx8py000a1cy565xg8vl1","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q2000h1cy5h0eh2y33"},{"post_id":"ckw3kx8q0000d1cy58ye0b15m","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q2000i1cy53t27h0fz"},{"post_id":"ckw3kx8pv00041cy5div423in","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q2000k1cy51rhlhmtc"},{"post_id":"ckw3kx8q1000f1cy5ct66408j","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q3000l1cy5cdol4538"},{"post_id":"ckw3kx8pw00051cy53c51h0uz","tag_id":"ckw3kx8q2000g1cy50pw7c13c","_id":"ckw3kx8q3000m1cy5du5daf4m"},{"post_id":"ckw3kx8px00061cy5g3zydb1s","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q3000n1cy593dcd7u4"},{"post_id":"ckw3kx8q4000p1cy5c24cgv4b","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q5000s1cy57cw5301i"},{"post_id":"ckw3kx8q5000r1cy573zuf48j","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3kx8q6000t1cy5e1aq5t67"},{"post_id":"ckw3kx8q4000o1cy53mm732vw","tag_id":"ckw3kx8q5000q1cy5a6tw7x6x","_id":"ckw3kx8q6000u1cy5hhct57u3"},{"post_id":"ckw3pcypf0000n8y53bkq1w30","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw3pcypl0001n8y59a8g654f"},{"post_id":"ckw8rk4y40000osy5cdbf76lc","tag_id":"ckw3kx8px00071cy50p1c1p4h","_id":"ckw8rk4y90001osy5fgfk5xgc"},{"post_id":"ckwca1lc70000dcy57k677qxb","tag_id":"ckwca1lcb0001dcy53i1m0lag","_id":"ckwca1lce0002dcy5d4fsfmv5"},{"post_id":"ckwjchw4i0000vwy56q7fcdxx","tag_id":"ckwjchw4m0001vwy550qk07e1","_id":"ckwjchw4t0002vwy5gd9q8mv2"}],"Tag":[{"name":"算法笔记","_id":"ckw3kx8pu00031cy586i73a5e"},{"name":"LeetCode 周赛总结","_id":"ckw3kx8px00071cy50p1c1p4h"},{"name":"saikr","_id":"ckw3kx8q2000g1cy50pw7c13c"},{"name":"模板","_id":"ckw3kx8q5000q1cy5a6tw7x6x"},{"name":"错题集","_id":"ckwca1lcb0001dcy53i1m0lag"},{"name":"LeetCode 周赛","_id":"ckwjchw4m0001vwy550qk07e1"}]}}