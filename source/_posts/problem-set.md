---
title: 某科学的算法错题集
date: 2021-11-23 22:42:43
tags: 错题集
---

------------

# 某科学的算法错题集

>   平时写完大呼 CNM 的题目集合

## Lc 1093. 大样本统计

我们对 `0` 到 `255` 之间的整数进行采样，并将结果存储在数组 `count` 中：`count[k]` 就是整数 `k` 的采样个数。

我们以 **浮点数** 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。

我们先来回顾一下中位数的知识：

-   如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；
-   如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。

**示例 1：**

```
输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
```

**示例 2：**

```
输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
```

**提示：**

1.  `count.length == 256`
2.  `1 <= sum(count) <= 10^9`
3.  计数表示的众数是唯一的
4.  答案与真实值误差在 `10^-5` 以内就会被视为正确答案

**笔记：**

其他几个数都好求，麻烦在中位数上。如果通过判断当前的 `sum` 值和 `len/2` 之间的关系，需要判断奇偶数等多种情况，因此用 `sum << 1` 和 `len` 之间直接比较即可，这样只需要处理一种特殊情况。

```rust
impl Solution {
    pub fn sample_stats(count: Vec<i32>) -> Vec<f64> {
        let count = count.into_iter().enumerate().filter(|pair| pair.1 != 0).collect::<Vec<_>>();
        let max = count.iter().max_by_key(|i| i.0).unwrap().0;
        let min = count.iter().min_by_key(|i| i.0).unwrap().0;
        let mode = count.iter().max_by_key(|i| i.1).unwrap().0;
        let (sum, len) = count.iter().fold((0., 0), |(sum, len), p| (sum + p.0 as f64 * p.1 as f64, len + p.1));
        let mut curr = 0;
        let mut mid = 0.;
        for i in 0..count.len() {
            curr += count[i].1;
            if curr << 1 > len {
                mid = count[i].0 as f64;
            } else if curr << 1 == len {
                mid = (count[i].0 + count[i + 1].0) as f64 / 2.0;
            } else {
                continue;
            }
            break;
        }
        vec![min as f64, max as f64, sum / len as f64, mid, mode as f64]
    }
}
```

