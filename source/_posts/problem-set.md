---
title: 某科学的算法错题集
date: 2021-11-23 22:42:43
tags: 错题集
---

------------

# 某科学的算法错题集

>   平时写完大呼 CNM 的题目集合

## Lc 1093. 大样本统计

我们对 `0` 到 `255` 之间的整数进行采样，并将结果存储在数组 `count` 中：`count[k]` 就是整数 `k` 的采样个数。

我们以 **浮点数** 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。

我们先来回顾一下中位数的知识：

-   如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；
-   如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。

**示例 1：**

```
输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
```

**示例 2：**

```
输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
```

**提示：**

1.  `count.length == 256`
2.  `1 <= sum(count) <= 10^9`
3.  计数表示的众数是唯一的
4.  答案与真实值误差在 `10^-5` 以内就会被视为正确答案

**笔记：**

其他几个数都好求，麻烦在中位数上。如果通过判断当前的 `sum` 值和 `len/2` 之间的关系，需要判断奇偶数等多种情况，因此用 `sum << 1` 和 `len` 之间直接比较即可，这样只需要处理一种特殊情况。

```rust
impl Solution {
    pub fn sample_stats(count: Vec<i32>) -> Vec<f64> {
        let count = count.into_iter().enumerate().filter(|pair| pair.1 != 0).collect::<Vec<_>>();
        let max = count.iter().max_by_key(|i| i.0).unwrap().0;
        let min = count.iter().min_by_key(|i| i.0).unwrap().0;
        let mode = count.iter().max_by_key(|i| i.1).unwrap().0;
        let (sum, len) = count.iter().fold((0., 0), |(sum, len), p| (sum + p.0 as f64 * p.1 as f64, len + p.1));
        let mut curr = 0;
        let mut mid = 0.;
        for i in 0..count.len() {
            curr += count[i].1;
            if curr << 1 > len {
                mid = count[i].0 as f64;
            } else if curr << 1 == len {
                mid = (count[i].0 + count[i + 1].0) as f64 / 2.0;
            } else {
                continue;
            }
            break;
        }
        vec![min as f64, max as f64, sum / len as f64, mid, mode as f64]
    }
}
```

## AcWing 871 约数之和

给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 109+7109+7 取模。

**输入格式**

第一行包含整数 n。

接下来 n 行，每行包含一个整数 ai。

**输出格式**

输出一个整数，表示所给正整数的乘积的约数之和，答案需对 109+7109+7 取模。

**数据范围**

$1≤n≤100$,
$1≤a_i≤2×10^9$

**输入样例：**

```
3
2
6
8
```

**输出样例：**

```
252
```

**笔记：**

利用算数基本定理的公式有 $\forall N = \Pi p_i^{\alpha_i}, \sum \{v; N|v\} = \Pi\sum_{j = 0}^{\alpha_i} p_i^j$ 。在求最后那个连乘的时候，可以利用秦九韶算法写成

```c++
// alpha_i = a, p_i = p
int sum = 1;
while(a--) sum = (sum * p + 1) % mod;
```

