---
title: 某科学的算法错题集
date: 2021-11-23 22:42:43
tags: 错题集
---

------------

# 某科学的算法错题集

>   平时写完大呼 CNM 的题目集合

## Lc 1093. 大样本统计

我们对 `0` 到 `255` 之间的整数进行采样，并将结果存储在数组 `count` 中：`count[k]` 就是整数 `k` 的采样个数。

我们以 **浮点数** 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。

我们先来回顾一下中位数的知识：

-   如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；
-   如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。

**示例 1：**

```
输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
```

**示例 2：**

```
输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
```

**提示：**

1.  `count.length == 256`
2.  `1 <= sum(count) <= 10^9`
3.  计数表示的众数是唯一的
4.  答案与真实值误差在 `10^-5` 以内就会被视为正确答案

**笔记：**

其他几个数都好求，麻烦在中位数上。如果通过判断当前的 `sum` 值和 `len/2` 之间的关系，需要判断奇偶数等多种情况，因此用 `sum << 1` 和 `len` 之间直接比较即可，这样只需要处理一种特殊情况。

```rust
impl Solution {
    pub fn sample_stats(count: Vec<i32>) -> Vec<f64> {
        let count = count.into_iter().enumerate().filter(|pair| pair.1 != 0).collect::<Vec<_>>();
        let max = count.iter().max_by_key(|i| i.0).unwrap().0;
        let min = count.iter().min_by_key(|i| i.0).unwrap().0;
        let mode = count.iter().max_by_key(|i| i.1).unwrap().0;
        let (sum, len) = count.iter().fold((0., 0), |(sum, len), p| (sum + p.0 as f64 * p.1 as f64, len + p.1));
        let mut curr = 0;
        let mut mid = 0.;
        for i in 0..count.len() {
            curr += count[i].1;
            if curr << 1 > len {
                mid = count[i].0 as f64;
            } else if curr << 1 == len {
                mid = (count[i].0 + count[i + 1].0) as f64 / 2.0;
            } else {
                continue;
            }
            break;
        }
        vec![min as f64, max as f64, sum / len as f64, mid, mode as f64]
    }
}
```

## AcWing 871 约数之和

给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 109+7109+7 取模。

**输入格式**

第一行包含整数 n。

接下来 n 行，每行包含一个整数 ai。

**输出格式**

输出一个整数，表示所给正整数的乘积的约数之和，答案需对 109+7109+7 取模。

**数据范围**

$1≤n≤100$,
$1≤a_i≤2×10^9$

**输入样例：**

```
3
2
6
8
```

**输出样例：**

```
252
```

**笔记：**

利用算数基本定理的公式有 $\forall N = \Pi p_i^{\alpha_i}, \sum \{v; N|v\} = \Pi\sum_{j = 0}^{\alpha_i} p_i^j$ 。在求最后那个连乘的时候，可以利用秦九韶算法写成

```c++
// alpha_i = a, p_i = p
int sum = 1;
while(a--) sum = (sum * p + 1) % mod;
```



## Lc 300. 最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**

-   `1 <= nums.length <= 2500`
-   `-104 <= nums[i] <= 104`

**进阶：**

-   你可以设计时间复杂度为 `O(n^2)` 的解决方案吗？
-   你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

**解答：**

LIS 问题的 dp 数组有两种定义方式，分别对应两种复杂度的解决方法。

**解法1：** $dp[i]$ 表示以 $nums[i]$ 结尾的 LIS 长度

设 $j\in [0, i)$ 。考虑 $nums[i]$ 和 $nums[j]$ 的大小关系，有

1.   $nums[i]$ <= $nums[j]$

     添加 $nums[i]$ 不能严格递增，跳过

2.   $nums[i] > nusm[j]$

     满足条件的 $j$ 都可以添加一个 $nums[i]$ 在其序列后，$dp[i]$ 对应这些序列里最长的一个，因此 $dp[i] = max(dp[i], dp[j] + 1)$

该算法需要二重循环，复杂度 $O(n^2)$

**解法2：** 解法 1 中计算每个 $dp[j]$ 的复杂度为 $O(n)$ 。实际上，利用递增的性质，我们可以记录 $tail[j]$ 为长度为 $j$ 的 LIS 的结尾。那么在计算到 $nums[i]$时，若

1.   $nums[i] > \forall tail[j]$

     则当前元素可以作为所有当前 LIS 的结尾，并且使得所有 LIS 长度加 1 。将其插入到 $tail$ 数组的结尾

2.   $\exist j\ s.t. tail[j - 1] < nums[i] < tails[j]$

     则当前元素可以更新对应长度 LIS 的结尾。$tails[j] = nums[i]$

由于 $tails$ 元素按照定义显然是严格递增的，所以插入操作可以用二分优化到 $O(\log N)$，整体复杂度 $O(N\log N)$

```rust
impl Solution {
    pub fn length_of_lis(nums: Vec<i32>) -> i32 {
        let mut tail: Vec<i32> = vec![];
        for num in nums {
            let pos = tail.partition_point(|&x| x < num);
            if pos == tail.len() {
                tail.push(num);
            } else {
                tail[pos] = num;
            }
        }
        tail.len() as i32
    }
}
```

