---
title: AcWing 算法基础课笔记
date: 2021-10-11 22:53:15
tags: 算法笔记
---

---

# AcWing 算法基础课笔记

>   笔记内容最终将由 `markmap` 工具生成思维导图

## 基础算法

### 快速排序

-   核心思想
    -   分治法
-   算法步骤
    -   确定分界点
        -   左端点
        -   右端点
        -   中间点
        -   随机点
    -   调整区间
        -   目标：使得左半边所有的数小于等于分界点，右半边所有的数大于等于分界点
        -   调整方法：
            -   暴力：直接开两个数组，扫描一遍
            -   常用：左右各一个游标。左边找第一个大于分点的，右边找第一个小于分点的，然后交换即可
    -   递归处理

-   模板

    ```c++
    void quick_sort(int q[], int l, int r)
    {
        if (l >= r) return;
    
        int x = q[(l + r) >> 1], i = l - 1, j = r + 1;
    
        while (i < j)
        {
            do i++; while (q[i] < x);
            do j--; while (q[j] > x);
            if (i < j) swap(q[i], q[j]);
        }
    
        quick_sort(q, l, j);
        quick_sort(q, j + 1, r);
    }
    ```
    

### 归并排序

-   核心思想

    -   归并

-   算法步骤

    -   先递归左右两侧
    -   左右有序数组合并成一个有序数组


### 二分

-   核心思想
    -   充分不必要条件
        -   单调性
    -   本质
        -   将序列按照某个性质从中间一分为二，二分法可以寻找两个性质的边界
    -   关注点
        -   根据查找的答案属于哪个性质，确定更新方式
    
-   模板

    -   右侧二分

    ```c++
    // 找左边界
    int l = 0, r = n - 1;
    while (l < r)
    {
        int m = l + r >> 1;	// 不加 1 会出现 [l, l] 死循环
        check(m)? r = m; l = m + 1;
    }
    ```

    -   左侧二分

    ```c++
    // 找右边界
    int l = 0, r = n - 1;
    while (l < r)
    {
        int m = l + r + 1>> 1;
        check(m)? l = m; r = m - 1;
    }
    ```

-   扩展
    -   浮点数二分
        -   停止条件是区间长度小于 $\varepsilon$
        -   不需要整数二分的考虑边界，直接往 `mid` 靠近即可

### 高精度

-   核心思想
    -   将大整数的每一位存入数组
    -   先存低位，后存高位
-   优化
    -   一次存 4 位

### 前缀和

-   核心思想
    -   快速求出原数组里一段数的和
-   技巧
    -   定义 $S[0] = 0$ 可以减少很多特判

### 差分

-   核心思想
    -   前缀和的逆运算，构造一个数组使得该数组的前缀和为原数组
-   技巧
    -   在差分数组里做出两个修改 `b[l] += c, b[r + 1] -= c` 等价于原数组 `a[l: r] += c`

### 双指针

-   核心思想
    -   优化暴力二重循环到 $O(N)$ 复杂度
    
-   模板

    ```c++
    for (int i = 0, j = 0; i < n; ++i)
    {
        while (j < i && check(i, j)) ++j;
        /* Do sth here */
    }
    ```

### 离散化

-   核心思想
    -   跨度较大但稀疏的整数映射到排序后的下标
    -   核心是保序和二分查找

### 区间合并

-   算法步骤
    -   按区间左端点排序
    -   扫描过程中维护一个当前区间，考虑下一个区间和当前区间的关系
        -   包含：不处理
        -   相交：更新当前区间右端点
        -   相离：当前区间结束，更新左右端点为新区间

## 数据结构

### 链表

-   动态链表
    -   每次 new 一个 Node ，较慢
-   静态链表
    -   数组模拟 Elem 和 Next 域，快
    -   应用
        -   邻接表
        -   链式前向星
    -   扩展
        -   双向链表
            -   模拟 Prev 域和 Next 域
            -   维护一个 head 变量和一个 tail 变量

### 单调栈

-   常见题型
    -   给定序列，求每一个数左边最近的最小数
-   时间复杂度
    -   `O(N)`

### 单调队列

-   常见题型
    -   滑动窗口最值

### KMP

-   核心思想

    -   暴力思想中，当前匹配失败，会有部分串已匹配
    -   记录向后移动多少可以使得已匹配的串和新的位置仍然匹配
    -   这个记录只和模板串有关！这就是 Next 数组
    -   `next[i] = j` 意味着 `p[1..=j] == p[i - j + 1..=i]`
    -   假设从 `s[i]` 开始不再匹配，即目前 `s[i - 1] == p[j] && s[i] != p[j + 1] `，此时直接向后移动模式串，将 `p[next[j]]` 对齐到 `s[i-1]`
    -   预处理思想与匹配相似，如果匹配不上，就回退到 `next` 对应位置，直到退到下标 0
    
- 代码模板

    -   匹配过程

        ```c++
    	// p[N] 匹配 s[M]
    	for (int i = 1, j = 0; i <= M; ++i) // j 和 i 错开一位
    	{
    	    while (j && s[i] != p[j + 1]) j = next[j];	// j 不能退到开头之前
    	    if (s[i] == p[j + 1]) ++j;
    	    if (j == N) 
    	    { 
    	        /* 匹配成功; */  
    	        j = next[j]; 	// 准备匹配下一次
    	    }
    	}
    	```
    
    -   预处理
    
        ```c++
        for (int i = 2, j = 0; i <= N; ++i)	// next[1] === 0
        {
            while (j && p[i] != p[j + 1]) j = next[j];
            if (p[i] == p[j + 1]) ++j;
            next[i] = j;
        }
        ```
    
    -   注意
    
        -   本模板字符串下标均从 1 开始

### Trie 树

-   核心思想
-   作用
    -   存储字符串
    -   查找字符串
-   实现
    -   每个单词结尾的节点标记 `is_end = true`
    -   类似数组模拟链表，用 `tot` 表示当前位置

### 并查集

-   核心思想

    -   路径压缩

    	>    ​	我愿将之称为最优美的一行代码

    	```c++
    	return x == parent[x]? x: parent[x] = find(parent[x]);
    	```

    -   按秩合并
    
        ```c++
        if (rank[fy] > rank[fx]) swap(fy, fx);
        parent[fy] = fx;
        if (rank[fx] == rank[fy]) rank[fx]++;
        ```
    
-   作用

    -   合并区间
    -   查询是否同类

-   复杂度

    -   $O(\alpha(N))$

### 二叉堆

-   核心操作
    -   Down
        -   和较小的孩子交换
        -   继续 Down
    -   Up
        -   和父亲交换
        -   继续 Up

-   实现操作

    -   建堆

        -   从 $n/2$ 到 1 执行 down 操作
        -   跳过了最后一层叶子节点
        -   复杂度 $O(N)$

    -   插入

        ```c++
        heap[++tot] = x, up(tot);
        ```

    -   删除

        ```c++
        heap[k] = heap[tot--], if (k != 1) up(k), down(k);	// up 和 down 至多执行一个
        ```

    -   修改

        ```c++
        heap[k] = x, up(k), down(k);
        ```

    -   修改第 k 个元素

        -   每个元素额外处理两个“指针”
        -   ph[k] 储存索引 i
        -   hp[i] 储存索引 i 对应的元素 k

        -   swap 需要交换 ph[hp[a]], ph[hp[b]] 以及 hp[a] 和 hp[b]
        -   交换完成后堆的元素和 ph 依旧是双向指向关系。交换 ph 修改 ph 指向堆的指针，交换 hp 修改堆指向 ph 的指针

### 散列表

## 搜索与图论

### 搜索

-   深度优先
    -   数据结构
        -   栈
    -   空间
        -   $O(h)$
    -   思想
        -   回溯
        -   剪枝
    -   关键操作
        -   恢复现场
-   广度优先
    -   数据结构
        -   队列
    -   空间
        -   $O(2^h)$
    -   性质
        -   具有最短路性质
        -   要求边权相等才可以用于求最短路

### 图

-   图的储存
    -   邻接矩阵
    -   邻接表
        -   链式前向星
    
-   拓扑排序
    
    -   拓扑序列
        -   拓扑序列的边一定从前向后
        -   只针对有向图
        -   有向无环图一定存在拓扑序列
    -   拓扑排序
        -   入度为 0 的点可以排在当前序列最前作为入口
        -   入度为 0 的点入队
        -   BFS 枚举所有出边并删掉
        -   新的入度为 0 的点入队
        -   队空结束
    

### 最短路问题

-   分类
    -   单源最短路
        -   正权图
        -   负权图
    -   多源汇最短路
-   难点
    -   抽象原问题到最短路问题
    -   建图
-   方法
    -   朴素 Dijkstra
        -   复杂度 $O(V^2)$
    -   堆优化 Dijkstra
        -   复杂度 $O(E\log V)$
    -   Bellman-Ford 算法
        -   复杂度
    -   SPFA
