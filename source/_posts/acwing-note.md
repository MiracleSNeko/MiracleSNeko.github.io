---
title: AcWing 算法基础课笔记
date: 2021-10-11 22:53:15
tags: 算法笔记
---

---

# AcWing 算法基础课笔记

>   笔记内容最终将由 `markmap` 工具生成思维导图

## 基础算法

### 快速排序

-   核心思想
    -   分治法
-   算法步骤
    -   确定分界点
        -   左端点
        -   右端点
        -   中间点
        -   随机点
    -   调整区间
        -   目标：使得左半边所有的数小于等于分界点，右半边所有的数大于等于分界点
        -   调整方法：
            -   暴力：直接开两个数组，扫描一遍
            -   常用：左右各一个游标。左边找第一个大于分点的，右边找第一个小于分点的，然后交换即可
    -   递归处理

-   模板

    ```c++
    void quick_sort(int q[], int l, int r)
    {
        if (l >= r) return;
    
        int x = q[(l + r) >> 1], i = l - 1, j = r + 1;
    
        while (i < j)
        {
            do i++; while (q[i] < x);
            do j--; while (q[j] > x);
            if (i < j) swap(q[i], q[j]);
        }
    
        quick_sort(q, l, j);
        quick_sort(q, j + 1, r);
    }
    ```
    

### 归并排序

-   核心思想

    -   归并

-   算法步骤

    -   先递归左右两侧
    -   左右有序数组合并成一个有序数组


### 二分

-   核心思想
    -   充分不必要条件
        -   单调性
    -   本质
        -   将序列按照某个性质从中间一分为二，二分法可以寻找两个性质的边界
    -   关注点
        -   根据查找的答案属于哪个性质，确定更新方式
    
-   模板

    -   右侧二分

    ```c++
    // 找左边界
    int l = 0, r = n - 1;
    while (l < r)
    {
        int m = l + r >> 1;	// 不加 1 会出现 [l, l] 死循环
        check(m)? r = m; l = m + 1;
    }
    ```

    -   左侧二分

    ```c++
    // 找右边界
    int l = 0, r = n - 1;
    while (l < r)
    {
        int m = l + r + 1>> 1;
        check(m)? l = m; r = m - 1;
    }
    ```

-   扩展
    -   浮点数二分
        -   停止条件是区间长度小于 $\varepsilon$
        -   不需要整数二分的考虑边界，直接往 `mid` 靠近即可

### 高精度

-   核心思想
    -   将大整数的每一位存入数组
    -   先存低位，后存高位
-   优化
    -   一次存 4 位

### 前缀和

-   核心思想
    -   快速求出原数组里一段数的和
-   技巧
    -   定义 $S[0] = 0$ 可以减少很多特判

### 差分

-   核心思想
    -   前缀和的逆运算，构造一个数组使得该数组的前缀和为原数组
-   技巧
    -   在差分数组里做出两个修改 `b[l] += c, b[r + 1] -= c` 等价于原数组 `a[l: r] += c`

### 双指针

-   核心思想
    -   优化暴力二重循环到 $O(N)$ 复杂度
    
-   模板

    ```c++
    for (int i = 0, j = 0; i < n; ++i)
    {
        while (j < i && check(i, j)) ++j;
        /* Do sth here */
    }
    ```

### 离散化

-   核心思想
    -   跨度较大但稀疏的整数映射到排序后的下标
    -   核心是保序和二分查找

### 区间合并

-   算法步骤
    -   按区间左端点排序
    -   扫描过程中维护一个当前区间，考虑下一个区间和当前区间的关系
        -   包含：不处理
        -   相交：更新当前区间右端点
        -   相离：当前区间结束，更新左右端点为新区间

## 数据结构

### 链表

-   动态链表
    -   每次 new 一个 Node ，较慢
-   静态链表
    -   数组模拟 Elem 和 Next 域，快
    -   应用
        -   邻接表
        -   链式前向星
    -   扩展
        -   双向链表
            -   模拟 Prev 域和 Next 域
            -   维护一个 head 变量和一个 tail 变量

### 单调栈

-   常见题型
    -   给定序列，求每一个数左边最近的最小数
-   时间复杂度
    -   `O(N)`

### 单调队列

-   常见题型
    -   滑动窗口最值

### KMP

-   核心思想

    -   暴力思想中，当前匹配失败，会有部分串已匹配
    -   记录向后移动多少可以使得已匹配的串和新的位置仍然匹配
    -   这个记录只和模板串有关！这就是 Next 数组
    -   `next[i] = j` 意味着 `p[1..=j] == p[i - j + 1..=i]`
    -   假设从 `s[i]` 开始不再匹配，即目前 `s[i - 1] == p[j] && s[i] != p[j + 1] `，此时直接向后移动模式串，将 `p[next[j]]` 对齐到 `s[i-1]`
    -   预处理思想与匹配相似，如果匹配不上，就回退到 `next` 对应位置，直到退到下标 0
    
- 代码模板

    -   匹配过程

        ```c++
    	// p[N] 匹配 s[M]
    	for (int i = 1, j = 0; i <= M; ++i) // j 和 i 错开一位
    	{
    	    while (j && s[i] != p[j + 1]) j = next[j];	// j 不能退到开头之前
    	    if (s[i] == p[j + 1]) ++j;
    	    if (j == N) 
    	    { 
    	        /* 匹配成功; */  
    	        j = next[j]; 	// 准备匹配下一次
    	    }
    	}
    	```
    
    -   预处理
    
        ```c++
        for (int i = 2, j = 0; i <= N; ++i)	// next[1] === 0
        {
            while (j && p[i] != p[j + 1]) j = next[j];
            if (p[i] == p[j + 1]) ++j;
            next[i] = j;
        }
        ```
    
    -   注意
    
        -   本模板字符串下标均从 1 开始

### Trie 树

-   核心思想
-   作用
    -   存储字符串
    -   查找字符串
-   实现
    -   每个单词结尾的节点标记 `is_end = true`
    -   类似数组模拟链表，用 `tot` 表示当前位置

### 并查集

-   核心思想

    -   路径压缩

    	>    ​	我愿将之称为最优美的一行代码

    	```c++
    	return x == parent[x]? x: parent[x] = find(parent[x]);
    	```

    -   按秩合并
    
        ```c++
        if (rank[fy] > rank[fx]) swap(fy, fx);
        parent[fy] = fx;
        if (rank[fx] == rank[fy]) rank[fx]++;
        ```
    
-   作用

    -   合并区间
    -   查询是否同类

-   复杂度

    -   $O(\alpha(N))$

### 二叉堆

-   核心操作
    -   Down
        -   和较小的孩子交换
        -   继续 Down
    -   Up
        -   和父亲交换
        -   继续 Up

-   实现操作

    -   建堆

        -   从 $n/2$ 到 1 执行 down 操作
        -   跳过了最后一层叶子节点
        -   复杂度 $O(N)$

    -   插入

        ```c++
        heap[++tot] = x, up(tot);
        ```

    -   删除

        ```c++
        heap[k] = heap[tot--], if (k != 1) up(k), down(k);	// up 和 down 至多执行一个
        ```

    -   修改

        ```c++
        heap[k] = x, up(k), down(k);
        ```

    -   修改第 k 个元素

        -   每个元素额外处理两个“指针”
        -   ph[k] 储存索引 i
        -   hp[i] 储存索引 i 对应的元素 k

        -   swap 需要交换 ph[hp[a]], ph[hp[b]] 以及 hp[a] 和 hp[b]
        -   交换完成后堆的元素和 ph 依旧是双向指向关系。交换 ph 修改 ph 指向堆的指针，交换 hp 修改堆指向 ph 的指针

### 散列表

## 搜索与图论

### 搜索

-   深度优先
    -   数据结构
        -   栈
    -   空间
        -   $O(h)$
    -   思想
        -   回溯
        -   剪枝
    -   关键操作
        -   恢复现场
-   广度优先
    -   数据结构
        -   队列
    -   空间
        -   $O(2^h)$
    -   性质
        -   具有最短路性质
        -   要求边权相等才可以用于求最短路

### 图

-   图的储存
    -   邻接矩阵
    -   邻接表
        -   链式前向星
    
-   拓扑排序
    
    -   拓扑序列
        -   拓扑序列的边一定从前向后
        -   只针对有向图
        -   有向无环图一定存在拓扑序列
    -   拓扑排序
        -   入度为 0 的点可以排在当前序列最前作为入口
        -   入度为 0 的点入队
        -   BFS 枚举所有出边并删掉
        -   新的入度为 0 的点入队
        -   队空结束
    

### 最短路问题

-   分类
    -   单源最短路
        -   正权图
        -   负权图
    -   多源汇最短路
-   难点
    -   抽象原问题到最短路问题
    -   建图
-   方法
    -   朴素 Dijkstra
        -   复杂度 $O(V^2)$
        -   算法流程
            -   寻找不在集合中且距离最小点的编号
            -   用找到的点松弛相邻的点
    -   堆优化 Dijkstra
        -   复杂度 $O(E\log V)$
    -   Bellman-Ford 算法
    
        -  循环 $k \in [1, E]$ 次
          -  此时的 dist 数组代表从初始点出发，经过不超过 k 条边的最短路径
          -  如果一条最短路上有 $E$ 条边，则必有负环
        -  每次循环遍历所有边，进行一次松弛操作
    -   SPFA
        -   时间复杂度一般 $O(E)$，最坏 $O(EV)$
        -   队列优化的 Bellman-Ford
        -   将松弛后的边入队
    -   Floyd 算法
        -   多源最短路
        -   时间复杂度 $O(E^3)$
        -   暴力 dp，三重循环
            -   $dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])$

### 判断负环

-   SPFA
    -   添加一个 cnt 数组
    -   cnt 数组记录从初始点出发最短路径经过路径的边数
    -   如果 $ cnt[x] \geq V$ ，由抽屉原理可知存在负环

### 最小生成树

-   Prim 算法
    -   朴素 Prim
        -   复杂度 $O(V^2)$
        -   适合稠密图
        -   算法流程
            -   初始化距离 `dist`
            -   找到不在当前联通块中距离最近的点
            -   用找到的点更新其他点到**联通块**的距离（ 这个点到联通块上点相连边的最短长度）
            -   将找到的点入队，循环直到所有点都在联通块上
    -   堆优化 Prim
        -   复杂度 $O(ElogV)$
        -   适合稀疏图
-   Kruscal 算法
    -   复杂度 $O(ElogE)$
    -   算法流程
        -   按边长排序所有边
        -   维护并查集，贪心添加最短的两端点不同时在集内的边

### 二分图

-   定理
    -   一个图是二分图，当且仅当该图不含有奇数环
    
-   染色法判断二分图
    -   复杂度 $O(V+E)$
    -   基本思路
        -   深度优先遍历，如果冲突则不是二分图
    
-   匈牙利算法
    -   最坏复杂度 $O(VE)$
    
    -   基本思路
    
        -   YXC 的奇妙比喻——男女配对
        -   男2尝试匹配属于男1的女1，查找发现男1与女2有连线，则断链
        -   每一步都需要更新 vis 数组，防止渣男反复勾搭已经连线的女朋友
    
    -   代码模板
    
        ```c++
        bool find(int u)
        {
            for (int e = hd[u]; e != -1; e = nxt[e]) {
                int v = to[e];
                if (!vis[v]) {
                    vis[v] = 1;
                    if (match[v] == 0 || find(match[v])) {
                        match[v] = u;
                        return true;
                    }
                }
            }
            return false;
        }
        ```
    

## 数学

### 初等数论

-   质数判定

    -   试除法
        -   时间复杂度 $O(\sqrt N)$
        -   利用约数成对出现
        -   判断条件 `i <= n / i`

-   分解质因数

    -    试除法
        -   从小到大尝试所有因数
        -   对因数循环求次数
        -   额外处理最后一个因数 `if (n > 1)` 

-   素数筛

    -   朴素算法

        -   从 2 开始，筛掉所有没被筛掉的数的倍数
        -   留下的即是质数

    -   埃拉托色尼筛

        -   筛掉质数的倍数
        -   由质数定理：1 ~ n 中有  $\frac{n}{\ln n}$ 个质数，总复杂度降到 $O(n\log\log n)$

    -   欧拉筛

        -   保证每个合数都被其最小质因子筛掉

            -   `i % pj == 0` pj 一定是 i 的最小质因子，因此 pj 也一定是 pj * i 的最小质因子
            -   `i % pj != 0` pj 一定小于 i 的所有因子，因此 pj 也一定是 pj * i 的最小质因子
        
        -   线性复杂度
        
        -   代码
        
            ```c++
            void euler_seive(int n)
            {
                FI(i, 2, n + 1)
                {
                    if (!vis[i]) primes[tot++] = i;
                    for(int j = 0; primes[j] <= n / i; ++j)
                    {
                        vis[primes[j] * i] = true;
                        if (i % primes[j] == 0) 
                            // 这里可以对当前primes[j]做点操作
                            break;
                    }
                }
            }
            ```
    
-   约数

    -   试除法求约数
    -   约数个数
        -   算数基本定理
            -   $\forall N = \Pi p_i^{\alpha_i}, |\{v; N|v\}| = \Pi(\alpha_i + 1)$
    -   约数之和
        -   算数基本定理
            -   $\forall N = \Pi p_i^{\alpha_i}, \sum \{v; N|v\} = \Pi\sum_{j = 0}^{\alpha_i} p_i^j$
        -   处理求和部分可以使用秦九韶算法优化
    
-   欧拉函数

    -   定义

        -   $1-N$ 中所有与 $N$ 互质的数的个数，记为 $\varphi(N)$
        -   $\forall N = \Pi p_i^{\alpha_i},\ \varphi(N) = N\Pi(1 - \frac{1}{p_i})$
        -   由容斥原理上式显然成立

    -   素数筛法求欧拉函数

        -   在素数筛中分情况讨论

            -   如果 $p_j$ 不是 $i$ 的质因子，那么对 $n = ip_j$ 有
        
                $$\varphi(n) = i p_j(1 - \frac{1}{p_j})\Pi_{i != j}(1 - \frac{1}{p_i}) = \varphi(i)(p_j - 1)$$
        
            -   如果 $p_j$ 是 $i$ 的质因子，那么 $n$ 和 $i$ 公式中连乘的部分显然相同
        
                $\varphi(n) = p_j\varphi(i)$
        
        -   代码
        
        ```c++
        void euler_seive(int n)
        {
            primes.fill(0);
            phi.fill(0);
            phi[1] = 1;
            for (int i = 2; i <= n; ++i) {
                if (!vis[i]) {
                    primes[tot++] = i;
                    phi[i] = i - 1;
                }
                for (int j = 0; primes[j] <= n / i; ++j) {
                    vis[primes[j] * i] = 1;
                    if (i % primes[j] == 0) {
                        phi[i * primes[j]] = primes[j] * phi[i];
                        break;
                    }
                    phi[i * primes[j]] = phi[i] * (primes[j] - 1);
                }
            }
        }
        ```

-   欧拉定理
	- 公式
      $$\forall a, n \in \mathbb{N}, \gcd(a, n) = 1 => a^{\varphi(n)} \equiv 1 (\mod n)$$
    - 证明思路
        - 构造完全剩余类
    
-   快速幂

-   乘法逆元

    -   存在逆元的充要条件是互质
    
    -   快速幂+费马小定理
    
        $a^{p-1} \equiv 1 (\mod p) => aa^{p-2} \equiv 1 (\mod p)$
    
    -   费马小定理+素数筛+扩展欧几里得
    
        -   公式
    
            $aa^{p-2}\equiv 1 (\mod p) => \exist b, s.t. aa^{p-2} + bp = 1$
    
        -   结合素数筛和逆元的结合性
        
    - 线性递推
    
      >   ```
      >   let ka + b = p, then a = p / k, b = p % k
      >   take b = p - ka in b * b^-1 === 1 mod p
      >   we have (p - ka) * b=^-1 === 1 mod p => -kab^-1 === 1 mod p
      >   then we have -k (p / k) (p % k)^-1 === 1 mod p
      >   then k^-1 = -p/k (p % k) ^-1 = (p - p/k)(p % k)^-1
      >   ```
    
-   裴蜀定理

    $\forall a_i\in\mathbb{N}, \exist x_i, s.t. \sum a_ix_i = \gcd(a_i) $

-   扩展欧几里得

    -   在每次辗转相除时交换 $x$ 和 $y$
    -   当 $b = 0$ 时显然有 $x = 1, y = 0$
    -   递归结束后令 $y = y - x * (a / b)$
    -   `exgcd` 求出基础解 $x_0, y_0$，有通解 $x = x_0 - \frac{b}{\gcd(a, b)}k, y = y_0 + \frac{a}{\gcd(a, b)}k$


-   中国剩余定理

    -   通解

        $$x = \sum a_iM_iM_i^{-1}, M_i = \Pi_{j \neq i} m_i$$

### 组合数学

### 高斯消元

### 博弈论基础



